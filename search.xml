<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈LOG之Logback]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%B5%85%E8%B0%88LOG%E4%B9%8BLogback%2F</url>
    <content type="text"><![CDATA[logback 同样是由log4j的作者设计完成的，拥有更好的特性，是用来取代 log4j 的一个日志框架。logback 是 slf4j 的原生实现 。 logback 和 log4j 的大多数概念类似，这里不作赘述。 官方文档 : Logback 浅谈LOG之Log4j 认识 Logback日志架构 涉及 说明 logback-core 其它两个模块的基础模块。包含Appender 和 Layout接口 。 logback-classic 它是 log4j 的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统(如 log4j 或 JDK1.4 Logging) 。包含 Logger 对象 。 logback-access 访问模块与Servlet容器集成提供通过Http来访问日志的功能。 核心对象Logger命名层次结构 和Log4j相同的命名规范和继承关系。 如果记录器的名称后跟一个点是后代记录器名称的前缀，则称该记录器是另一个记录器的祖先。如果记录器本身和后代记录器之间没有祖先，则称记录器是子记录器的父节点。 Appender Appender 和 Logger 具有一样的继承关系。 Appender 控制日志输出目标，例如：控制台，文件，远程套接字服务器，数据库，JMS和远程UNIX Syslog守护程序等。 LayoutLayout 负责定制输出格式，它是通过 Appender 相关联来实现的。 支持对象LoggerContext各个logger 都被关联到一个 LoggerContext，LoggerContext负责制造logger，也负责以树结构排列各logger。 Level 如果给定的记录器没有分配级别，那么它将 从具有指定级别的最近祖先继承 一个级别。 如果Logger请求的级别高于或等于其Logger的有效级别，则为启动，反之禁用。 级别（优先级：desc） 描述 OFF 最高级别，用于关闭日志。 FATAL 指明非常严重的错误事件，可能会导致应用终止执行。 ERROR 指明错误事件，但应用可能还能继续运行。 WARN 指明潜在的有害状况。 INFO 指明描述信息，从粗粒度上描述了应用运行过程。 DEBUG 指明细致的事件信息，对调试应用最有用。 TRACE 比 DEBUG 级别的粒度更细。 ALL 所有级别，包括定制级别。 使用 LogbackLogback的默认配置 尝试在 classpath 下查找文件 logback-test.xml 。 若文件不在，则查找 logback.xml 。 若两个文件都不在，使用 BasicConfigurator 默认配置，日志输出到控制台。 123456&lt;!--logback(自动依赖：logback-core,slf4j-api)--&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; logback.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 根节点： scan: 配置文件改变时，是否重新加载，默认为true； scanPeriod: 扫描文件间隔时间，在 scan="true" 后生效，默认单位为毫秒； debug: 是否打印logback的内部日志信息，默认为false。 --&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义变量: 在下文中可以使用 $&#123;&#125; 使用该变量 --&gt; &lt;property name="logfolder" value="/users/gushi/developer/log/demo" /&gt; &lt;!-- appender: 控制台输出 --&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!-- 对日志进行格式化 --&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 输出&gt;=DEBUG级别的日志（因为mybatis的sql日志级别为DEBUG） --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- appender: 滚动记录日志，先记录指定文件，再按照滚动策略将日志记录到其他文件 --&gt; &lt;appender name="demo" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;File&gt;$&#123;logfolder&#125;/demo.log&lt;/File&gt; &lt;!-- 是否追加日志，默认为true，置为false会先清空 --&gt; &lt;append&gt;true&lt;/append&gt; &lt;!-- 滚动策略: 根据文件大小和时间来制定 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt; &lt;FileNamePattern&gt;$&#123;logfolder&#125;/daily/daily-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!-- 归档文件最大保留数 --&gt; &lt;MaxHistory&gt;10&lt;/MaxHistory&gt; &lt;!-- 最大文件大小 --&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;!-- 总大小 --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="error" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;File&gt;$&#123;logfolder&#125;/demo.log&lt;/File&gt; &lt;!-- 滚动策略: 根据时间来制定 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;logfolder&#125;/demo.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt; &lt;append&gt;true&lt;/append&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--级别过滤--&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 设置具体包/类的打印级别，以及指定appender name: 约束某个包/类; level: 打印级别，和大小写无关，默认为DEBUG; additivity：是否继承上级的级别，默认为true; --&gt; &lt;logger name="org.demo" additivity="false" level="INFO" &gt; &lt;appender-ref ref="demo" /&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt; &lt;!-- mybatis log 日志 （因为mybatis的sql日志级别为DEBUG）--&gt; &lt;logger name="org.demo.dao" level="DEBUG"/&gt; &lt;!-- 根loger: 所有logger的上级，默认为DEBUG --&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="console"/&gt; &lt;appender-ref ref="error"/&gt; &lt;/root&gt;&lt;/configuration&gt; *.java123456789101112package org.Demo;import org.slf4j.Logger;public class Demo&#123; // 获取与类同名的日志对象 private final static Logger logger = LoggerFactory.getLogger(HelloJob.class); public void log()&#123; logger.info("用户**访问了***"); &#125;&#125; 附录优化logback 已自身优化，不用考虑因为使用日志功能而降低业务执行效率。注意使用占位符即可。 关闭日志时（多参数日志）java中对String的直接拼接的消耗是巨大的。 由于日志级别Level的限制，一些日志可能不会输出，但是构造消息参数依然会消耗巨大成本。 1logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i])); 方式一 即使输出，所需时间也增加不到 1% 。 123if(logger.isDebugEnabled()) &#123; logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));&#125; 方式二 推荐 使用类似 占位符 的方式，在日志被禁用的情况下，至少优化了30倍。 123456logger.debug("The new entry is &#123;&#125;.", entry);logger.debug("The new entry is &#123;&#125;. It replaces &#123;&#125;.", entry, oldEntry); Object[] paramArray = &#123;newVal, below, above&#125;;logger.debug("Value &#123;&#125; was inserted between &#123;&#125; and &#123;&#125;.", paramArray); 开启日志记录时（默认继承）Logger对象在创建时已明确了日志级别，不会动态继承。在基于有效级别接受或拒绝请求之前，记录器可以做出准瞬时决定，而无需咨询其祖先（不需要遍历记录器层次结构。）。 实际记录（格式化和写入输出设备）已优化Layout和Appdender，一些logback组件已被重写几次以提高性能。 记录到本地计算机上的文件时，实际记录的典型成本约为9到12微秒。登录到远程服务器上的数据库时，它会持续几毫秒。]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>LOG</tag>
        <tag>SL4J</tag>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈LOG之Log4j]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%B5%85%E8%B0%88LOG%E4%B9%8BLog4j%2F</url>
    <content type="text"><![CDATA[一个成熟的项目，日志系统是必不可少的。当前流行的框架有 log4j , logback ，它们都是基于 slf4j 日志规范/接口 开发。本文就来介绍一下 Log4j 。 认识 Log4J日志架构Log4j API 采用分层架构，每一层有不同的对象，完成不同的任务。这种分层架构让设计变得灵活，且易于日后扩展。 核心对象★ 涉及一览 说明 Logger 负责获取日志信息，并存储于一个分层的命名空间之中。 Layout 负责格式化日志信息的对象，在发布日志信息之前，它为 appender 对象提供支持。 Appender 负责将日志信息输出到不同目的地，比如数据库、文件、控制台、Unix Syslog 等。 Logger该对象位于分层架构中的最上层，负责获取日志信息，并存储于一个分层的命名空间之中。 对象获取 Logger 类不允许初始化一个新的实例，但提供了三个静态方法用来获取 Logger 对象： 实际上是从 LogManager 的Logger工厂中 获取 / 设置 和参数同名的Logger对象。 123456/** 获得根日志对象*/public static Logger getRootLogger();/** 通过calzz的名字（getName()）获取对应的日志对象，底层和 getLogger(String name)是相同的 */public static Logger getLogger(Class clazz);/** 通过字符串获取对应的日志对象 */public static Logger getLogger(String name); 日志对象继承 &amp; 日志对象名 可以通过Logger对象来触发打印日志。 Logger具有 父子/继承关系 ，且所有日志对象都是RootLogger的子对象。子logger会继承父logger的appender等，触发打印后会从子类向上依次调用appender。 12345# 设置两个日志对象，日志对象名为com.ibatis和com.ibatis.common.jdbc.SimpleDataSource# 其中com.ibatis是com.ibatis.common.jdbc.SimpleDataSource的父logger# 且com.ibatis包下所有类获得的日志对象都是com.ibatis日志对象的子loggerlog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=INFO Logger对象的继承关系是通过 日志对象名 来管理的。 除了以上在获取Logger对象的同时设置日志对象名外，还可以在 log4j.properties 设置并细化配置 1234# 自定义一个日志对象，日志对象名为securityLog# 从上面的解释可能会认为日志对象securityLog是作用于securityLog包下的类# 但一般也可以用Logger.getLogger(&quot;securityLog&quot;)来获取日志对象log4j.logger.securityLog = INFO,log_security,database 日志信息级别 一旦获取一个有名字的 logger 实例，就可以使用如下方法用于打印日志信息。 注意 ：日志信息不一定会被输出，其会被日志对象（及其父logger）的最低日志级别 过滤 并且还需要对应的appender，才能输出到指定位置。 优先级 方法和描述 1 public void fatal(Object message) 使用 Level.FATAL 级别打印日志。 2 public void error(Object message) 使用 Level.ERROR 级别打印日志。 3 public void warn(Object message) 使用 Level.WARN 级别打印日志。 4 public void info(Object message) 使用 Level.INFO 级别打印日志。 5 public void debug(Object message) 使用 Level.DEBUG 级别打印日志。 6 public void trace(Object message) 使用 Level.TRACE 级别打印日志。 最低日志级别 可以设置Logger对象打印日志信息的最低级别，只有大于或等于该级别的信息才会被输出 例如以下配置中：com.ibatis.common.jdbc.SimpleDataSource 日志对象会无法输出日志，而 com.ibatis.Demo 日志对象可以使用根日志对象的appender(CONSOLE)将日志信息输出到控制台。 12345678910# 设置根日志对象最低日志级别为INFO，并设置一个appender(CONSOLE)log4j.rootLogger = INFO,CONSOLElog4j.logger.com.ibatis=INFOlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUG# print the message to console(ENABLE)log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n 12//最低日志级别也可以在java中设置log.setLevel(Level.WARN); Layout负责格式化日志信息的对象，在发布日志信息之前，它为 appender 对象提供支持。 所有 Layout 对象从 Appender 对象那里接收一个 LoggingEvent 对象，然后从 LoggingEvent 对象那里获取信息，并使用恰当的 ObjectRenderer 对象获取该信息的字符串形式。 位于继承关系顶层的是抽象类 org.apache.Log4j.Layout，这是所有 Log4j API 中 Layout 类的基类。 在应用中我们从不直接使用该类，而是使用它的子类，如下所示： 其中最常用的是 PatternLayout , 本wiki主要主要针对其进行讲解。 DateLayout HTMLLayout PatternLayout SimpleLayout XMLLayout Appender该对象位于分层架构中的较低一层，负责将日志信息输出到不同目的地，比如数据库、文件、控制台、Unix Syslog 等。 支持对象☆这些是框架的可选对象，它们支持核心对象做一些额外的任务，同样在框架中发挥着重要作用。 LevelLevel 对象定义了日志信息的粒度和优先级。 org.apache.Log4j.Level 类定义了日志级别，您可通过继承 Level 类定制自己的级别。 级别（优先级：desc） 描述 OFF 最高级别，用于关闭日志。 FATAL 指明非常严重的错误事件，可能会导致应用终止执行。 ERROR 指明错误事件，但应用可能还能继续运行。 WARN 指明潜在的有害状况。 INFO 指明描述信息，从粗粒度上描述了应用运行过程。 DEBUG 指明细致的事件信息，对调试应用最有用。 TRACE 比 DEBUG 级别的粒度更细。 ALL 所有级别，包括定制级别。 FilterFilter 对象用来分析日志信息，进而决定该条日志是否被记录。 一个 Appender 对象可对应多个 Filter 对象，当日志信息传给 Appender 对象时，与其关联的所有 Filter 对象需要判断是否将日志信息发布到目的地。 ObjectRendererObjectRenderer 对象负责为传入日志框架的不同对象提供字符串形式的表示，Layout 对象使用该对象来准备最终的日志信息。 LogManagerLogManager 对象管理日志框架，它负责从系统级的配置文件或类中读取初始配置参数。 使用 Log4j单纯的使用只需要 slf4j-api , log4j ; 一些项目需要 slf4j-log4j12 （如： MyBatis ）。 12345678910111213141516&lt;!-- log (slf4j, log4j, slf4j-log4j整合)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; log4j.properties默认情况下， LogManager 会在 classpath 中寻找 log4j.properties 文件。 以下是较为详细的配置示例，模式转换字符请参考：附录：PatternLayout 12345678910111213141516171819202122232425262728293031323334353637# 设置根日志，最低日志级别为INFO，并添加了2个appender（CONSOLE,log_error）确定输出详情log4j.rootLogger = INFO,CONSOLE,log_error# 自定义securityLog日志对象，最低日志级别为INFO，并添加了2个appender（log_security,database）确定输出详情log4j.logger.securityLog = INFO,log_security,databaselog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=INFOlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=INFOlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUGlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=INFOlog4j.logger.java.sql.PreparedStatement=DEBUG,stdout# 使用控制台输出日志log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n# 使用文件输出日志log4j.appender.log_security = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.log_security.file = D:/PHIMP/logs/log_securitylog4j.appender.log_security.DatePattern = &apos;_&apos;yyyyMMdd&apos;.log&apos;log4j.appender.log_security.layout = org.apache.log4j.PatternLayoutlog4j.appender.log_security.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n# 使用文件输出日志，最低级别为errorlog4j.appender.log_error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.log_error.Threshold = errorlog4j.appender.log_error.file = D:/PHIMP/logs/log_errorlog4j.appender.log_error.DatePattern = &apos;_&apos;yyyyMMdd&apos;.log&apos;log4j.appender.log_error.layout = org.apache.log4j.PatternLayoutlog4j.appender.log_error.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n# 使用数据库输出日志，最低级别为info# 推荐继承org.apache.Log4j.jdbc.JDBCAppender（org.log.LogJdbcAppender）直接获得数据库相关信息log4j.appender.database = org.log.LogJdbcAppenderlog4j.appender.database.Threshold = infolog4j.appender.database.layout = org.apache.log4j.PatternLayoutlog4j.appender.database.sql = INSERT INTO %X&#123;tableName&#125; (%X&#123;fields&#125;) VALUES (%X&#123;values&#125;) *.java获取日志对象，设置日志信息。 控制台 / 文件 输出日志 控制台输出: [INFO] 2017-01-17 17:01:17 [org.Demo] - 用户**访问了*** 12345678910package org.Demo;import org.apache.log4j.Logger;public class Demo&#123; // 获取与类同名的日志对象 private Logger logger = Logger.getLogger(this.getClass()); public void log()&#123; logger.info("用户**访问了***"); &#125;&#125; 数据库 输出日志JDBCAppender.java 继承org.apache.Log4j.jdbc.JDBCAppender直接获得数据库相关信息，不需要单独配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LogJdbcAppender extends JDBCAppender &#123; protected final Logger logger = Logger.getLogger(getClass()); public LogJdbcAppender() &#123; super(); &#125; @Override protected Connection getConnection() &#123; try &#123; connection =((SqlMapClient)ServiceLocator.getBean("sqlMapClient")).getDataSource().getConnection(); return connection; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void closeConnection(Connection con) &#123; try &#123; if (con != null &amp;&amp; !con.isClosed()) &#123; con.close(); con = null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void flushBuffer() &#123; removes.ensureCapacity(buffer.size()); for (Iterator i = buffer.iterator(); i.hasNext();) &#123; try &#123; LoggingEvent logEvent = (LoggingEvent)i.next(); String sql = getLogStatement(logEvent); removes.add(logEvent); execute(sql); &#125; catch (SQLException e) &#123; errorHandler.error("Failed to excute sql", e, ErrorCode.FLUSH_FAILURE); &#125; &#125; buffer.removeAll(removes) removes.clear(); &#125;&#125; 调用 控制台/文件输出: [INFO] 2017-01-17 17:01:17 [org.Demo] - 用户**访问了*** 数据库表 VISIT_LOG 插入了 values 记录。 1234567891011121314151617package org.Demo;public class Demo&#123; // 获取securityLog日志对象 private Logger logger = Logger.getLogger("securityLog"); public void log()&#123; // 字段 String fields = "ID, USER_ID, USER_NAME, RESOURCES_ID, VISIT_TIME"; StringBuffer values = new StringBuffer(); //...设置values值 MDC.put("tableName", "VISIT_LOG"); MDC.put("fields", fields); MDC.put("values", values.toString()); logger.info("用户**访问了***"); &#125;&#125; 附录PatternLayoutPatternLayout 是一个简单的 Layout 对象，提供了如下属性，该属性可通过配置文件更改： 序号 属性 &amp; 描述 1 conversionPattern设置转换模式，默认为 %r [%t] %p %c %x - %m%n。 模式转换字符下面的表格解释了上面模式中用到的字符，以及所有定制模式时能用到的字符： 转换字符 含义 c 输出日志对象名，一般为发起记录日志请求类的全名/自设置的日志对象名。比如对于类 org.apache.xyz.SomeClass ，模式 %C{1} 会输出 SomeClass 。也有可能是自定义日志对象名，比如 log4j.logger.securityLog = INFO 为 securityLog 。 d 输出记录日志的日期，比如 %d{HH:mm:ss,SSS} 或 %d{dd MMM yyyy HH:mm:ss,SSS} 。 F 在记录日志时，使用它输出文件名。 l 输出生成日志的调用者的地域信息。 L 输出发起日志请求的行号。 m 输出和日志事件关联的，由应用提供的信息。 M 输出发起日志请求的方法名。 n 输出平台相关的换行符。 p 输出日志事件的优先级。 r 输出从构建布局到生成日志事件所花费的时间，以毫秒为单位。 t 输出生成日志事件的线程名。 x 输出和生成日志事件线程相关的 NDC (嵌套诊断上下文)。 X 该字符后跟 MDC 键，比如 X{clientIP} 会输出保存在 MDC 中键 clientIP 对应的值。 % 百分号， %% 会输出一个 % 。 格式修饰符缺省情况下，信息保持原样输出。但是借助格式修饰符的帮助，就可调整最小列宽、最大列宽以及对齐。 下面的表格涵盖了各种修饰符： 格式修饰符 左对齐 最小宽度 最大宽度 注释 %20c 否 20 无 如果列名少于 20 个字符，左边使用空格补齐。 %-20c 是 20 无 如果列名少于 20 个字符，右边使用空格补齐。 %.30c 不适用 无 30 如果列名长于 30 个字符，从开头剪除。 %20.30c 否 20 30 如果列名少于 20 个字符，左边使用空格补齐，如果列名长于 30 个字符，从开头剪除。 %-20.30c 是 20 30 如果列名少于 20 个字符，右边使用空格补齐，如果列名长于 30 个字符，从开头剪除。]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>LOG</tag>
        <tag>SL4J</tag>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java之枚举]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B5%85%E8%B0%88Java%E4%B9%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[使用关键字 enum 可以定义枚举类型，枚举类型可以包含一组序列集，可以作为常规的程序组件使用。当我们需要从固定的序列中获取值时，使用枚举类型是一个很好的方式。 基本特性尽管 enum 看起来像是一个新的数据类型，但是这个关键字只是为 enum 生成对应的类时，产生某些编译器行为。 可以将 enum 当做其他任何类来处理。 创建 enum 时，编译器会自动生成一个对应的类，这个类会继承 java.lang.Enum 。 由此可知，枚举类型具有以下 特性 ： enum 不能再继承。 enum 可以使用 Enum类 的方法。 enum 除了不能继承以外，基本可以看做一个常规的类。 除此之外，枚举类型还具有以下 特性 ： enum 也不能被继承。 enum 内可以定义一些序列，这些值实际上enum实例，默认是 public static final 。 enum 需要提供和实例声明对应的构造函数，enum构造函数默认是 private 。 123public enum SimpleEnum &#123; SUCCESS, WARNING, ERROR;&#125; 继承于 Enum的方法 说明 ordinal() 返回 enum实例 在声明时的次序。 name() 返回 enum实例 在声明时的名字。 toString() 默认与 name() 相同。 getDeclaringClass() 获取 enum实例 所属的类类型。 1234567System.out.println(SimpleEnum.SUCCESS.ordinal());System.out.println(SimpleEnum.SUCCESS == SimpleEnum.SUCCESS);System.out.println(SimpleEnum.WARNING.name());System.out.println(SimpleEnum.WARNING.toString());System.out.println(SimpleEnum.ERROR.getDeclaringClass()); 123450trueWARNINGWARNINGclass org.demo.enumdemo.SimpleEnum 与 name() 方法对应，也可以通过枚举的名字获取枚举类型。 方法 说明 valueOf(Class&lt;T&gt; enumType, String name) 通过枚举的名字获取枚举类型，可被继承的 static 方法。 valueOf(String name) 通过枚举的名字获取枚举类型，由编译器添加。 1234System.out.println(Enum.valueOf(SimpleEnum.class, "ERROR") == SimpleEnum.ERROR);System.out.println(SimpleEnum.valueOf(SimpleEnum.class, "ERROR") == SimpleEnum.ERROR);System.out.println(SimpleEnum.valueOf("ERROR") == SimpleEnum.ERROR); 123truetruetrue 添加属性和方法一般枚举会用来定义数据字典，为了增加可用性，我们可以向枚举类型中添加属性和方法。 12345678910111213141516171819public enum DictCode &#123; SUCCESS("0", "成功"), WARNING("1", "警告"), ERROR("2", "错误"); private String code; private String codeName; DictCode(String code, String codeName) &#123; this.code = code; this.codeName = codeName; &#125; // getter and setter ...&#125; 需要注意的是： 向枚举中添加属性和方法后，实例声明一定要使用 ; 结尾。 虽然当enum中只有实例时可以省略 ; 的 ，但不推荐。 实例声明实际上会调用构造方法，故需要提供对应的构造方法。 解析 values()enum 提供了一个遍历的方法 values() 。 123for (DictCode item : DictCode.values()) &#123; System.out.println(item.name() + ": " + item.getCodeName() + "-" + item.getCode());&#125; 123SUCCESS: 成功-0WARNING: 警告-1ERROR: 错误-2 实际上， values() 是编译器添加的静态方法，而不是继承自Enum。 如果我们想遍历Enum可以使用 Class类 的 getEnumConstants() 方法。 因为该方法来自 Class类，故也可用在没枚举类型上，但会报空指针异常。 12345678Enum e = DictCode.SUCCESS;// Enum.values(); // Cannot resolve method 'values()'// e.values(); // Cannot resolve method 'values()'for (Enum enumConstant : e.getClass().getEnumConstants()) &#123; DictCode item = (DictCode) enumConstant; System.out.println(item.name() + ": " + item.getCodeName() + "-" + item.getCode());&#125; 123SUCCESS: 成功-0WARNING: 警告-1ERROR: 错误-2]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java之注解]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B5%85%E8%B0%88Java%E4%B9%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解 (又被称为 元数据 ) ，是 Java 提供的一种让我们可以为代码添加信息的一种方式。 元数据 : 中介数据，为描述数据的数据，主要是描述数据属性的信息。 通过注解可以有效的减少样板式代码 ，所以注解式开发是现在框架的主流趋势。除此之外，注解还可以进行类型检查 和 注释说明 等作用。 认识注解从 Class类 可以看出，对于 JVM 而言，注解是一种特殊的接口，并且所有的注解类型都继承了 Annotation接口 。 我们知道一些框架需要一些额外信息才能与源代码协同工作。以前一般是配置文件，现在更喜欢使用注解。因为源代码已经提供了一些有用的信息，例如类名，包名等，所以使用注解会有效的减少配置。 元注解元注解 : Java 中内置了一些元注解，元注解专职负责注释其他注解。 涉及 说明 @Target 目标，指注解的作用位置。 @Retention 保留期，指注解的生命周期。 @Inherited 继承，允许子类继承父类的该注解。只会继承作用在 ElementType.TYPE 的注解。 @Documented 文档，生成 javadoc 时会包含注解信息。 @Repeatable 可重复，表示可多次使用，JDK8新增。 @Target@Target : 表示注解的作用位置，需要设置元素类型集 ElementType[] 。 ElementType枚举值 说明 ElementType.TYPE 类，接口（包括注释类型）或枚举声明。 ElementType.FIELD 字段声明（包括枚举常量）。 ElementType.METHOD 方法声明。 ElementType.PARAMETER 正式参数声明。 ElementType.CONSTRUCTOR 构造函数声明。 ElementType.LOCAL_VARIABLE 局部变量声明。 ElementType.ANNOTATION_TYPE 注释类型声明。 ElementType.PACKAGE 包声明。 ElementType.TYPE_PARAMETER 输入参数声明， JDK8新增。 ElementType.TYPE_USE 使用一种类型， JDK8新增。 @Retention@Retention : 表示注解的生命周期，需要设置存活策略 RetentionPolicy 。 RetentionPolicy枚举值 说明 RetentionPolicy.SOURCE 只存在于源码，编译器将丢弃注释。 RetentionPolicy.CLASS 注释将由编译器*记录在类文件中，但在运行时不需要由VM保留。 这是默认的行为 。 RetentionPolicy.RUNTIME 注释将由编译器记录在类文件中，并且在运行时由VM保留，因此 可以反射性地读取它们 。 @Inherited@Inherited : 表示被修饰的注解作用于超类后，超类的子类会继承该注解。但只会继承作用在 ElementType.TYPE 的注解。 这种继承是隐蔽的，光从子类无法看出，但可以通过反射获取所继承注解。 @Documented@Documented : 表示在生成 javadoc 时，被修饰的注解会被包含在文档中。 @Repeatable@Repeatable : 表示被修饰的注解可多次使用，是 JDK8 新增的注解，例如 Spring 的 @Scheduled 可以设置多种定时策略。 注解分类按注解的生命周期分类： 按生命周期分类 说明 应用 源码注解 注解只在源码中存在，编译成 *.class 文件就不存在了。 编译时注解 注解在源码和 *.class 文件中都存在。 TODO一般用于编译期检查。 运行时注解 注解在运行阶段还会起作用，甚至会影响运行逻辑。 第三方技术喜欢用其实现功能逻辑。 按注解来源分类： 按来源分类 示例 JDK自带 @Override , @Deprecated , @SuppressWarnings 等 来自第三方的注解 @Service , @Autowired 等Spring常用注解。 自定义的注解 可以使用 @interface 等来创建自定义注解。 JDK注解这里介绍一下，日常开发时常会使用到的 JDK注解 。 注解是 JDK1.5 时添加的特性，JDK5只提供了这3个注解。 涉及 说明 @Override 覆盖，覆盖来自超类型（父类或接口）的方法。 @Deprecated 标识元素过时，使用处编译器会显示警告信息。 @SuppressWarnings 抑制编译器警告，可以制定警告集。例如 @SuppressWarnings(&quot;unchecked&quot;) 抑制未检查的警告。 @Override@Override : 可以使用它来表示覆盖超类型（父类或接口）的方法，它是一个源码注解。 实际上， @Override 是可选的，不写编译器不会报错，但使用在非继承来的方法上会报错。 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Deprecated@Deprecated : 标识元素过时，使用处编译器会显示警告信息，它是一个运行时注解。 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; @SuppressWarnings@SuppressWarnings : 抑制编译器警告，可以制定警告集，它是一个源码注解。 123456789101112/** * @jls 4.8 Raw Types * @jls 4.12.2 Variables of Reference Type * @jls 5.1.9 Unchecked Conversion * @jls 5.5.2 Checked Casts and Unchecked Casts * @jls 9.6.3.5 @SuppressWarnings */@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 这里仅列出几个常用的警告关键字，详情可以查看 JLS 。 抑制警告的关键字 用途 all 压制所有警告。 unchecked 禁止相对于未经检查的操作的警告。 cast 禁止相对于强制转换操作的警告。 rawtypes 在类params上使用泛型时，禁止相对于非特定类型的警告。 deprecation 禁止相对于弃用的警告。 使用注解除去 JDK 和 框架技术外，大多数时候需要 自定义注解 并 编写处理器来解析它们。 自定义注解基础语法 定义注解需要使用关键字 @interface ，其语法类似接口 ，但不允许继承。 注解中可以添加 元素 ，看起来十分像接口的方法。 注解类可以没有元素，没有元素的注解称为 标识注解 。 元素 的类型受限，只能使用 : 基本类型 , String , Class , enum , Annotation 和 以上类型的数组 。 不能使用基本类型的包装类型，但支持自动装箱。 虽然看上去像抽象方法，但 元素 是不允许有 入参 和 异常声明的。 元素 不能有不确定的值，即要么使用 default 设置默认值，要么使用时提供元素值。 默认值不允许使用 null ，为绕开这个约束，可以使用 空字符串 或 负数，来表示不存在。 约定俗成的规范 : 如果只有一个注解元素，则取名为 value() ，这样在使用时可以忽略成员名和赋值号 = 。 1234567891011@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String value(); // 可以用default指定默认值 int id() default 100;&#125; 自定义注解 @Description 注解可以作用于 类型 和 方法 上。 注解的元素赋值一般采用 元素名=元素值 的方式设置，符合约定俗称的规范除外。 1234567891011121314151617181920212223@Description(value="It's Person class annotation.", id=10 )public class Person &#123; private String name; private int age; @Description("It's Person method annotation.") public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; @Description 注解可以被继承，可以看出注解的继承是比较隐蔽的，无法直接看出。 1234567891011121314151617181920212223public class User extends Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Description("It's User method annotation.") public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 编写注解处理器如果没有用来读取注解的工具，那注解也不会比注释更有用。 使用 反射 可以获取 注解 提供的 元数据 。 从没有打印 getName:It&#39;s User method annotation. ，可以看出 @Inherited 只会继承作用在 ElementType.TYPE 的注解。 12345678910111213141516171819202122@Testpublic void test()&#123; Class clazz = User.class; boolean isExist = clazz.isAnnotationPresent(Description.class); if (isExist)&#123; Description d1 = (Description) clazz.getAnnotation(Description.class); System.out.println(d1.value()); // It's Person class annotation. &#125; Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; boolean isMExist = method.isAnnotationPresent(Description.class); if (isMExist)&#123; Description d2 = method.getAnnotation(Description.class); System.out.println(method.getName() + ":" + d2.value()); // getAge:It's User method annotation. &#125; &#125;&#125; 常见应用ORM这里用注解简单实现一个ORM框架的查询功能，类似于 Hibernate。 定义注解先定义两个注解，用于表示 数据表 和 字段 。 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 123456@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String value();&#125; 定义注解解析器定义一个工具类用于解析注解，并完成简单查询的 SQL 拼接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ORM &#123; private static final String SELECT = "SELECT"; private static final String FROM = "FROM"; private static final String WHERE = "WHERE"; private static final String SPLIT_BLANK = " "; private static final String EQUALS = "="; private static final String AND = "AND"; public static &lt;T&gt; String query(T obj) throws Exception &#123; StringBuilder sql = new StringBuilder(); Class clazz = obj.getClass(); Field[] fields = clazz.getDeclaredFields(); String BASE_COLUMN_LIST = Arrays.stream(fields) .filter(item -&gt; item.isAnnotationPresent(Column.class)) .map(item -&gt; item.getAnnotation(Column.class).value()) .collect(Collectors.joining(",")); String TABLE_NAME = ((Table) clazz.getAnnotation(Table.class)).value(); sql.append(SELECT).append(SPLIT_BLANK) .append(BASE_COLUMN_LIST).append(SPLIT_BLANK) .append(FROM).append(SPLIT_BLANK) .append(TABLE_NAME); StringBuilder condition = new StringBuilder(); for (Field field : fields) &#123; String fieldName = field.getAnnotation(Column.class).value(); PropertyDescriptor descriptor = new PropertyDescriptor(field.getName(), clazz); Method getter = descriptor.getReadMethod(); Object fieldValue = getter.invoke(obj); if (fieldValue == null || (fieldValue instanceof Integer &amp;&amp; fieldValue.equals(0))) &#123; continue; &#125; condition.append(AND).append(SPLIT_BLANK).append(fieldName).append(EQUALS); if (fieldValue instanceof String) &#123; condition.append("'").append((String) fieldValue).append("'"); &#125; else if (fieldValue instanceof Integer) &#123; condition.append((Integer) fieldValue); &#125; &#125; if (condition.length() &gt; 0) &#123; sql.append(SPLIT_BLANK).append(WHERE).append(SPLIT_BLANK).append(condition.substring(4)); &#125; return sql.toString(); &#125;&#125; 注解的使用将两个注解用于实体类上，形成对象和数据表的映射关系。 12345678910111213141516171819202122232425@Table("USER")public class Filter &#123; @Column("USER_NAME") private String userName; @Column("USER_AGE") private int userAge; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getUserAge() &#123; return userAge; &#125; public void setUserAge(int userAge) &#123; this.userAge = userAge; &#125;&#125; 如此这般，一个简单的动态的条件查询就完成了。 123456789@Testpublic void test() throws Exception &#123; Filter filter = new Filter(); filter.setUserName("张三"); filter.setUserAge(18); System.out.println(ORM.query(filter)); // SELECT USER_NAME,USER_AGE FROM USER WHERE USER_NAME='张三'AND USER_AGE=18&#125;]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java之RTTI与反射]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%B5%85%E8%B0%88Java%E4%B9%8BRTTI%E4%B8%8E%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射机制 是 Java 提供的一种让我们在运行时识别对象类型的方式。 通过反射可以进行更加动态的编程，这也正是框架技术十分喜欢使用的方式，了解反射后，也会对 Java 有更加深刻的认识。 RTTIRTTI（Run-Time Type Identification） : 运行时识别对象类型。 Java 提供了三种方式， 让我们可以在运行时识别一个对象的类型。 RTTI方式 说明 表现形式 传统的RTTI 假定在编译时已知道了所有的类型。 主要是类型转换，例如 主动强制类型转换 和 泛型的自动转换 等。 反射 在运行时发现和使用类的信息。 通过 Class类 和 reflect包 发现和使用类信息。 instanceof / isInstance java 关键字和Class 方法，可以判断对象是不是某个特定类型的实例。 比直接进行 Class 的 == 和 equal() 判断更好，保持了类型的概念，是考虑继承的。 传统RTTI 和 反射 的 真正区别 传统的 RTTI 是在编译时打开和检查 *.class 文件的； 反射机制中，编译时无法获得 *.class 文件，所以在运行时才打开和检查的。 认识反射JDK 提供了 Class类 和 java.lang.reflect包 来支持反射功能。 Class简单理解 Java 中万物皆对象，类本身也是 Class类 的对象。通过 Class类 可以获取类的相关信息，但有不仅限于类。 java 中只有两种不是面向对象的 基本数据类型：会有对应的封装类。 静态的成员：属于类，不面向对象。 深入了解 Class类 的实例表示 Java 应用运行时的类和接口。 enum 是一种类，注解 是一种接口。所有 数组 属于类。 基本类型 和 void 也有 类Class 的实例对象。 一般称 Class对象 为对应类的 类类型（class type） 或 字节码对象 。 *.java 文件编译后会生成字节码 *.class 文件，其在应用运行时，被第一次使用时才会被 JVM 动态加载。 获取方式任何类都可以获取 Class实例对象。Class的构造方法式私有的，但提供了 三种获取方式 ： 12345678910Foo foo1 = new Foo();// 1. 通过类获取。 类字面常量：可以看做，任何一个类都有一个隐含的静态成员变量class。Class c1 = Foo.class;// 2. 通过对象获取。已知该类的对象，通过getClass()方法。Class c2 = foo1.getClass();// 3. 通过类的全称获取。也称之为动态加载类 (throws ClassNotFoundException)。Class c3 = Class.forName("org.demo.reflect.Foo"); 任何类的类类型只有一个。 12System.out.println(c1 == c2 &amp;&amp; c2 == c3);// true 通过该对象也可以对应类的实例对象。 12// 需要有无参数的构造方法Foo foo2 = (Foo) c1.newInstance(); 获取类信息 类Class 的实例表示 Java 应用运行时的类和接口。 enum 是一种类，注解 是一种接口。所有 数组 属于类。 基本类型 和 void 也有 类Class 的实例对象。 12345678910111213Class c1 = Integer.class; Class c2 = Collection.class;Class c3 = ElementType.class;Class c4 = Override.class;Class c5 = int[].class;Class c6 = int.class;Class c7 = void.class;// 基本类型和对应包装类的类类型不相同，但和包装类型的标准字段相同。System.out.println(c1 == c6);// falseSystem.out.println(c6 == Integer.TYPE);// true 通过 类类型 可以获得对应类的相关信息。例如类名： 1234567System.out.println(c1.getSimpleName());// IntegerSystem.out.println(c2.getName());//java.util.CollectionSystem.out.println(c3.getName());// java.lang.annotation.ElementTypeSystem.out.println(c4.getName());// java.lang.OverrideSystem.out.println(c5.getName());// [ISystem.out.println(c6.getName());// intSystem.out.println(c7.getName());// void 这里列举一些常用的获取类信息的方法， Field 、 Method 和 Constructor 等会在之后着重说明。 Class 常用方法 说明 String getName() 获取完整类名，包括包名。 String getSimpleName() 获取简单类名，不包括报名。 Field[] getDeclaredFields() 获取所有该类自己声明的成员变量，不论访问权限。 Method[] getDeclaredMethods() 获取所有该类自己声明的方法，不论访问权限。 Constructor[] getDeclaredConstructors 获取所有该类自己声明的构造函数，不论访问权限。 Field : 字段Field类 : 通过 Field 可以获取和操作字段。 1234567891011121314public static void printFieldMessage(Object obj) &#123; Class clazz = obj.getClass(); // Field类: 成员变量也是对象 // getFields(): 所有public成员变量，包括由父类继承来的 // getDeclaredFields: 所有该类自己声明的成员变量，不论访问权限 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; Class fieldType = field.getType(); String fieldName = field.getName(); System.out.println(fieldType + " " + fieldName + ";"); &#125;&#125; 123456// 获取成员变量信息ClassUtil.printFieldMessage(1);// int MIN_VALUE;// int MAX_VALUE;// class java.lang.Class TYPE;// ... Method : 方法Method类 : 通过 Method 可以获取和操作方法。 12345678910111213141516171819202122232425public static void printClassMethodMessage(Object obj)&#123; // 获取类类型: JNI本地方法获取，通过c语言实现。 Class clazz = obj.getClass(); System.out.println("类的名称: " + clazz.getName()); // Method类：方法也是对象，一个方法对应一个Method对象 // getMethods(): 所有public方法，包括由父类继承来的 // getDeclaredMethods(): 所有该类自己声明的方法，不论访问权限 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; Class returnType = method.getReturnType(); String methodName = method.getName(); Class[] paramTypes = method.getParameterTypes(); String methodInfo = returnType.getName() + " " + methodName; methodInfo += "("; for (Class item : paramTypes) &#123; methodInfo += item.getName() + ","; &#125; methodInfo += ")"; System.out.println(methodInfo); &#125;&#125; 12345// 获取方法信息ClassUtil.printClassMethodMessage(Class.class);//类的名称: java.lang.Class//void checkPackageAccess(java.lang.ClassLoader,boolean,)//java.lang.Class forName(java.lang.String,) Constructor : 构造器Constructor类 : 通过 Constructor 可以获取和操作构造方法。 12345678910111213141516171819public static void printConstructMessage(Object obj)&#123; Class clazz = obj.getClass(); // Constructor 构造方法也是函数 // getFields(): 所有public成员变量，包括由父类继承来的 // getDeclaredFields: 所有该类自己声明的构造函数 Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor cs : constructors) &#123; String csName = cs.getName(); Class[] paramTypes = cs.getParameterTypes(); String csInfo = csName + "("; for (Class item : paramTypes) &#123; csInfo += item.getName() + ","; &#125; csInfo += ")"; System.out.println(csInfo); &#125;&#125; 12345// 构造方法信息ClassUtil.printConstructMessage("hello");// java.lang.String([B,int,int,)// java.lang.String([B,java.nio.charset.Charset,)// java.lang.String([B,java.lang.String,) 使用反射方法反射1234567891011121314public class Foo &#123; public void print()&#123; System.out.println("I'm Foo!"); &#125; public void print(String s1, String s2)&#123; System.out.println(s1 + " " + s2); &#125; public void print(Integer n1, Integer n2)&#123; System.out.println(n1 + " " + n2); &#125;&#125; 1234567891011Foo foo = new Foo();Class clazz = Foo.class;Method method1 = clazz.getMethod("print", String.class, String.class);method1.invoke(foo, "abc", "def");// abc defMethod method2 = clazz.getMethod("print", new Class[]&#123;Integer.class, Integer.class&#125;);method2.invoke(foo, 12, 21);// 12 21Method method3 = clazz.getDeclaredMethod("print");method3.invoke(foo);// I'm Foo! 字段反射反射字段可以让我们直接访问和操作字段，下面通过两个示例来看一下。 提供模拟数据： 12345Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("username", "张三");map.put("age", 10);map.put("birthdate", new Date());map.put("salary", new BigDecimal("123.321")); 直接反射反射会进行访问域检查，一般只能访问到 public 域，可以使用 setAccessible(true) 来跳过检查。 虽然不会有什么影响，但 一般还是不推荐使用这种方式 。 1234567891011121314151617Class clazz = User.class;Object obj = clazz.newInstance();Field[] fields = clazz.getDeclaredFields();for (Field field : fields) &#123; int mod = field.getModifiers(); if (Modifier.isStatic(mod) || Modifier.isFinal(mod)) &#123; continue; &#125; // 操作私有域：不进行访问域检查 field.setAccessible(true); field.set(obj, map.get(field.getName()));&#125;System.out.println(obj);// User&#123;username='张三', age=10, birthdate=Mon Mar 04 15:50:19 CST 2019, salary=123.321&#125; 反射Getter和Setter这里推荐使用 PropertyDescriptor ，通过它可以友好的使用 Getter 和 Setter 。 123456789101112Class clazz = User.class;Object obj = clazz.newInstance();Field[] fields = clazz.getDeclaredFields();for (Field field : fields) &#123; PropertyDescriptor pd = new PropertyDescriptor(field.getName(), clazz); Method wm = pd.getWriteMethod(); // 写方法 wm.invoke(obj, map.get(field.getName()));&#125;System.out.println(obj);// User&#123;username='张三', age=10, birthdate=Mon Mar 04 16:13:26 CST 2019, salary=123.321&#125; 构造反射反射无参构造器： 1234Class c1 = Foo.class;// 需要有无参数的构造方法Foo foo = (Foo) c1.newInstance(); 反射有参构造器： 123456Class clazz = User.class;Constructor constructor = clazz.getConstructor(new Class[]&#123;String.class, int.class&#125;);Object object = constructor.newInstance("Hello", 123);System.out.println(object);// User&#123;username='Hello', age=123, birthdate=null, salary=null&#125; 常见应用动态加载 Class.forName(...) 方法又称之为 动态加载 。 静态加载 作用于编译期，而 动态加载 作用于运行期。 JVM在运行时才会去加载 *.class 文件，若找不到会 throw ClassNotFoundException 。 我们常会看到使用它来加载数据库驱动。 JDBCDriver 都要求自我注册 DriverManager.registerDriver(...) ，所以只要加载即可，不需要初始化。 1Class.forName("com.mysql.jdbc.Driver"); 绕过编译: 认识泛型反射方法作用于运行期，通过反射可以绕过泛型检查，说明编译后是去泛型化的。 实际上，编译会擦除泛型，这些容器持有对象时会将其都视为 Object 对象，取出时会进行类型转换。 123456789101112131415161718192021222324252627@Testpublic void test() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; List list1 = new ArrayList(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); list1.add(1d); list2.add("abc"); list3.add(1000); Class c1 = list1.getClass(); Class c2 = list2.getClass(); Class c3 = list3.getClass(); // 泛型不会影响类类型 System.out.println(c1 == c2 &amp;&amp; c2 == c3);//true Method method = c2.getMethod("add", Object.class); // 反射方法作用于运行期，通过反射可以绕过泛型检查，说明编译后是去泛型化的。 method.invoke(list2, 100); method.invoke(list3, "def"); System.out.println(list1);// [1.0] System.out.println(list2);// [abc, 100] System.out.println(list3);// [1000, def]&#125;]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>RTTI</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈JDK8新特性]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%B5%85%E8%B0%88JDK8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java8（又称为 JDK8）是 Java 语言开发的一个重要版本，于2014年发布。 JDK8 可以说是里程碑式的版本，提供了很多的新功能，支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。 本文仅涉及编程开发中常用的特性 。 官网：JDK8新功能 函数式编程JDK8 提供了函数式编程支持，不再是单纯的面对对象。 函数编程语言 最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入和输出。 JDK8 提供了一些特性来支持函数式编程：Lambda表达式 , 函数式接口 , 方法引用 等。 这三者具有紧密联系，需要结合理解。 默认方法 和 stream API 及 增强API 则另行说明。 函数式接口 就是只有一个抽象方法的接口。 Lambda表达式 只能作用于 函数式接口 。 若 Lambda 表达式 表示的逻辑已经被抽取为方法， 方法引用 可以替换 Lambda表达式 ，简化代码。 Lambda 表达式Lambda Expressions : 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 Lambda表达式 主要用来定义行内执行的 函数式接口（只有一个抽象方法的接口）。 lambda表达式 又名：闭包 、 匿名方法 。 语法格式1234// 格式一(parameters) -&gt; expression // 格式二(parameters) -&gt;&#123; statements; &#125; 语法特征: 可选的参数类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但没有参数或多个参数需要定义圆括号。 可选的参数大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 基本语法特征示例： 1234567891011121314151617181920212223242526272829303132333435363738package org.demo.jdk8.lambda;import org.junit.Test;public class LambdaTest &#123; /** * 带返回值的lambda表达式：四则运算 */ @Test public void test1()&#123; LambdaTest tester = new LambdaTest(); // 类型声明 MathOperation addition = (int a, int b) -&gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; // 大括号中的返回语句 MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;; // 没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; System.out.println("10 + 5 = " + tester.operate(10, 5, addition)); System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction)); System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication)); System.out.println("10 / 5 = " + tester.operate(10, 5, division)); &#125; interface MathOperation &#123; int operation(int a, int b); &#125; private int operate(int a, int b, MathOperation mathOperation)&#123; return mathOperation.operation(a, b); &#125;&#125; 变量作用域123public interface Converter&lt;T1, T2&gt; &#123; void convert(int i);&#125; Lambda表达式 的局部变量具有隐性的 final 的语义。 可以不用声明为 final，但是必须不可被后面的代码修改。 123456int num = 1;Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));s.convert(2);// ERROR : Local variable num defined in an enclosing scope must be final or effectively finalnum = 5; 在 Lambda表达式 当中不允许声明一个与局部变量同名的参数或者局部变量。 1234String first = "";// ERROR : Variable 'first' is already defined in the scopeComparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); 方法引用Method references : 通过方法的名字来指向一个方法。可以理解为Lambda表达式的缩写。 用途 : 当要传递给Lambda体内的操作，已经有实现的方法了，就直接可以使用方法引用。 推荐优先使用方法引用，替代 lambda 表达式 ，这样代码会更加简洁清晰。 语法格式 数组也可以使用构造器方法引用，例如 : int[3]::new 。 引用类型 语法格式 构造器方法引用（调用默认构造器） Class::new 类静态方法引用 Class::static_method 类普通方法引用（被调用方法不能具有参数） Class::method 实例方法引用 instance::method 方法引用的语法格式示例： 1234567891011121314151617181920@Testpublic void test()&#123; // 1. 构造器方法引用(调用默认构造器) : Class::new，或者更一般的Class&lt; T &gt;::new Car car1 = Car.create( Car::new ); Car car2 = Car.create( Car::new ); Car car3 = Car.create( Car::new ); List&lt; Car &gt; cars = Arrays.asList( car1, car2, car3 ); // 2. 类静态方法引用 : Class::static_method cars.forEach( Car::collide ); // 3. 类普通方法引用(被调用方法不能具有参数) : Class::method cars.forEach( Car::repair ); // 4. 实例方法引用 : instance::method Car police = Car.create( Car::new ); cars.forEach( police::follow );&#125; 12345678910111213141516171819202122class Car &#123; /** 创造 **/ public static Car create(Supplier&lt;Car&gt; supplier) &#123; return supplier.get(); &#125; /** 碰撞 **/ public static void collide(Car car) &#123; System.out.println("Collided " + car.toString()); &#125; /** 跟随 **/ public void follow( Car another) &#123; System.out.println(this.toString() + " Following the " + another.toString()); &#125; /** 修理 **/ public void repair() &#123; System.out.println("Repaired " + this.toString()); &#125;&#125; 函数式接口functional interfaces : 仅有一个抽象方法的接口，可以有多个非抽象方法。 函数式接口可以包含Object的public方法（即使它们是抽象方法），因为任何一个函数式接口的实现，默认都继承了 Object 类，包含了来自 java.lang.Object 里对这些抽象方法的实现。 JDK8 引入了新注解 @FunctionalInterface ，用于函数式接口的编译级错误检查（非必须）。 用途 : 函数式接口可以被隐式转换为 lambda表达式 ，与 lambda 配合使用。 常用函数式接口使用 lambda表达式 就需要函数式接口，除了现有的函数式接口，JDK8还提供了 java.util.function包 ，其包含一些常用的函数式接口。 常用接口 说明 Function&lt;T,R&gt; 接受一个输入参数 T ，返回一个结果 R 。 Supplier&lt;T&gt; 无参数，返回一个结果 T 。 Consumer&lt;T&gt; 接受一个输入参数 T ，无返回结果。 自定义一个函数式接口与使用示例： 1234567891011121314151617/** * 自定义类Function函数式接口 * 数组构造引用 */@Testpublic void test()&#123; FunctionInterfaceDemo&lt;Integer, int[]&gt; fid1 = (i) -&gt; new int[i]; int[] arr1 = fid1.get(5); System.out.println(arr1 + ":" + arr1.length); // 数组构造引用 FunctionInterfaceDemo&lt;Integer, int[]&gt; fid2 = int[]::new; int[] arr2 = fid2.get(5); System.out.println(arr2 + ":" + arr2.length);&#125; 1234567891011121314/** * 函数式接口示例 * 该接口类似：Function * @FunctionalInterface jdk8 新增，用于函数式接口的编译级错误检查（非必须）。 */@FunctionalInterfacepublic interface FunctionInterfaceDemo&lt;T, R&gt; &#123; R get(T t); /** 函数式接口，仅有一个抽象方法，Object的public方法除外。 **/ boolean equals(Object obj);&#125; 默认方法Default methods : 允许将新功能添加到库的接口，并确保与为这些接口的旧版本编写的代码的二进制兼容性。 简单的说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。(🤣接口和抽象类都可以有实现方法了) 用途 : 解决接口的修改与现有的实现不兼容的问题。 JDK8 以前，接口是个双刃剑， 好处是面向抽象而不是面向具体编程， 缺陷是当需要修改接口时候，需要修改全部实现该接口的类。 123456789101112131415161718/** 车 **/public interface Vehicle &#123; /** * 在接口中使用 default 就可以添加实现方法了 */ default void print()&#123; System.out.println("我是一辆车!"); &#125; /** * jdk8后，可以在接口中添加静态的实现方法（静态默认方法，🤣不能用default修饰） */ static void blowHorn()&#123; System.out.println("按喇叭!!!"); &#125;&#125; 12345678/** 四轮车 */public interface FourWheeler &#123; default void print()&#123; System.out.println("我是一辆四轮车!"); &#125;&#125; 1234567891011public class Car implements Vehicle, FourWheeler &#123; public void print()&#123; // 使用 super 来调用指定接口的默认方法： Vehicle.super.print(); FourWheeler.super.print(); Vehicle.blowHorn(); &#125;&#125; forEach 解析forEach 是经典的默认方法，是 jdk8 集合框架可使用的遍历方法（实现于Iterable接口）。 12345678910@Testpublic void test() &#123; List names = new ArrayList(); names.add("Google"); names.add("Runoob"); names.forEach(System.out::println); // names.forEach(item -&gt; System.out.println(item)); // 等同于以上的函数引用&#125; JDK8 在 Iterable接口 中新增了默认方法 forEach 。 其会遍历集合，并调用 Consumer接口 的 accept方法 。 123456default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; Consumer接口 是 jdk8新增的 函数式接口 。 其提供的接口方法是：一个入参，没有出参。 123456package java.util.function;@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; 这里 System.out::println 和 Consumer接口 有相同的出入参。 故，这里集合会遍历执行 相应逻辑，即遍历打印。 1names.forEach(System.out::println); Stream APIStream(流) : 一个来自数据源的元素队列并支持聚合操作。 元素 : 特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源 : 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。 聚合操作 : 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。和以前的Collection操作不同， Stream操作还有两个基础的特征： Pipelining : 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代 ： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。 得益于 默认方法 ， Stream方法 被整合到 Collection接口 中。现在可以十分简洁高效的方式操作元素集合。 Stream操作 的一般流程 : 转换为Stream -&gt; 中间操作 -&gt; 最终操作 。 123456789List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abc", "", "jkl");List&lt;String&gt; filtered = strings.stream() .filter(string -&gt; !string.isEmpty()) .distinct() .collect(Collectors.toList());System.out.println(filtered);// [abc, bc, efg, jkl] Stream种类JDK8 中，集合接口提供了两种方法生成流。 stream() : 为集合创建串行流。 parallelStream() : 为集合创建并行流。 中间操作 Stream 常用方法 说明 filter 筛选出元素。例如: .filter(String::isEmpty) 为筛选出所有空字符串。 distinct 去重，通过 equals方法 判断。 map 映射每个元素到对应的结果。例如: .map(i -&gt; i * i) 为获取获取对应的平方数。 sorted 排序（升序），通过 Comparable接口 判断。 count 统计个数。 collect 实现归约操作，即转换类型。 最终操作常见的 最终操作 是 归约操作 。 Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。 Collectors常用方法 说明 toList / toSet / toMap 转换成集合。 joining 转换成字符串。 groupingBy 分组，根据函数式接口的返回值分组。]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Thymeleaf之Layout]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%B5%85%E8%B0%88Thymeleaf%E4%B9%8BLayout%2F</url>
    <content type="text"><![CDATA[一般来说，网站会有一些共享的常见的页面组件，如页眉，页脚，菜单等，我们可以使用布局来共享它们， Thymeleaf 很好的支持了这种功能，不需要依赖其他布局引擎，例如： Apache Tiles 。 本文内容基于 Thymeleaf3.0 。 Thymeleaf : Template-Layout Thymeleaf Layout Thymeleaf Layout Dialect Thymeleaf 有两种主要的布局方式，各有优势，配合使用更佳。 布局方式 说明 优劣性 包含式布局(include style) Thymeleaf标准布局。通过在每个视图中直接嵌入公共页面组件代码来生成页面。 使用简单，但不利于维护。 分层式布局(hierarchical style) 由布局方言提供支持。模板通常使用父子关系创建，从一般的部分（布局）到具体的部分（子视图;例如页面内容） 模块化维护简单，但配置更复杂。 标准布局系统包含式布局★包含式布局 ，也称之为 标准布局 ，十分简单，先定义模板片段，再引用片段即可。 定义片段 定义片段需要使用 th:fragment ，片段只是 th:fragment 所在标签及子标签内容。所有片段都可以在一个文件中定义或在单独的文件中定义。 当前片段位于 classpath:templates/fragments/footer.html 。 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt; &lt;body&gt; &lt;p th:fragment="copyright"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 引用片段 引用片段语法： th:引用方式=&quot;~{templatename :: selector}&quot; 。 片段表达式（ ~{} ）是在 Thymeleaf 3.0 引入的，为向上兼容，引用片段时可以不使用 ~{} 包含。 语法 说明 引用方式 Thymeleaf 提供了三种 引用方式 。 片段模板名称（ templatename ） 可以是文件, this 或没有关键字。 片段选择器（ selector ） 片段名称 或 标记选择器 。 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;body&gt; ... &lt;div th:insert="fragments/footer :: copyright"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 作用效果 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt; &lt;body&gt; ... &lt;div&gt; &lt;p&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 片段表达式片段表达式 可以将片段做对象使用，其有三种格式。 ~{templatename::selector} templatename : 模板名称，包含了相对模板根路径的位置。 selector : 标记选择器，可以只是片段名称，也可以使用完善的 标记选择器语法 。 由于标记选择器的强大，甚至可以使用 id选择器（ #id ）直接选择片段，而不需要 th:fragment 。 ~{templatename} 在 th:insert / th:replace 标签中使用必须由模板解析器解析。 ~{::selector} / ~{this::selector} 优先从当前模板查找片段，若没找到，会从模板根路径开始遍历查找匹配。 引用方式Thymeleaf 提供了三种片段引用方式。 片段引用方式 说明 th:insert 插入指定的片段到引用标签中。 th:replace 使用指定的片段替换引用的标签。 th:include 只插入片段内容（不包括标签）到引用标签中， v3.0后不推荐使用。 下面通过示例，感受一下三种方式的区别 定义片段，当前片段位于 classpath:templates/fragments/footer.html 。 123&lt;p th:fragment="copyright"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/p&gt; 使用三种方式引用片段。 1234567891011&lt;body&gt; ... &lt;div th:insert="fragments/footer :: copyright"&gt;&lt;/div&gt; &lt;div th:replace="fragments/footer :: copyright"&gt;&lt;/div&gt; &lt;div th:include="fragments/footer :: copyright"&gt;&lt;/div&gt;&lt;/body&gt; 三种引用方式的作用效果。 12345678910111213141516171819&lt;body&gt; ... &lt;div&gt; &lt;p&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;/div&gt; &lt;p&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/div&gt;&lt;/body&gt; 更多特性Thymeleaf 模板布局还拥有很多特性和高级应用，这里列举了一些以供参考。 参数化片段 : 模板片段可以向函数一样传递参数。 灵活布局 : 参数化片段 + 片段表达式 = 灵活布局 。 布局继承 : 灵活布局的利用方案，理论上可以直接实现第三方的 布局方言 的分层布局功能。 布局方言布局方言 实际上是一个基于 Thymeleaf方言 的第三方扩展包，可以轻松的完成分层式布局。 Spring Boot 1.x 中包含了布局方言，但在 Spring Boot 2.x 中被移除。 123456&lt;!-- https://github.com/ultraq/thymeleaf-layout-dialect --&gt;&lt;dependency&gt; &lt;groupId&gt;nz.net.ultraq.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-layout-dialect&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt;&lt;/dependency&gt; 可以在页面中引入命名空间，使 IDE 更好的支持。 1&lt;html xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"&gt; 分层式布局★分层式布局需要使用 布局方言 （Layout Dialect）。 定义布局装饰器 可以定义一个通用的布局样式（父页面），使用 layout:fragment 定义布局片段（子页面占位符）。 当前片段位于 classpath:templates/layout/default.html 。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;!--/* 标准布局 可以和 布局方言 混合使用 */--&gt; &lt;div th:replace="fragments/header :: header"&gt;&lt;/div&gt; &lt;div class="container"&gt; &lt;!--/* 当前标签会被替换，类似th:replace */--&gt; &lt;div layout:fragment="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div th:replace="fragments/footer :: footer"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 引用装饰器 在需要被装饰的页面（子页面），使用 layout:decorate 引用装饰器，并使用 layout:fragment 设置布局片段的具体内容。 子页面并不是被简单的 th:replace ， &lt;head&gt;&lt;/head&gt; 的内容也会一并被合理带入。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~&#123;layout/default&#125;"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Springboot - thymeleaf&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div layout:fragment="content" title="布局成功"&gt; &lt;div&gt; ... 真实的内容 ... &lt;/div&gt; &lt;!--/* 在子页面依然可以使用布局 */--&gt; &lt;div data-th-insert="thymeleaf/common :: #commonT"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方言扩展布局方言 不仅提供了分层式布局方法，还扩展了标准布局的语法，可以直接替代标准布局方言。例如： layout:fragment , layout:include 等。具体参考 官方文档。]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
        <tag>Thymeleaf Layout</tag>
        <tag>Thymeleaf Layout Dialect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jackson: 全面的数据处理工具]]></title>
    <url>%2F2019%2F01%2F28%2FJackson-%E5%85%A8%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[鉴于对 json 的需求更多，且 Jackson 对 json 和 xml 的处理方式基本相同，故 本文更侧重对 JSON 的处理 。 日常开发中常需要 Json 、 Java 、 Xml之间的互相转换，相关 数据处理工具（data-processing tools） 有很多，鉴于 Jackson 更加全面且操作简单，这里就介绍一下 Jaxckson 的简单用法。 json相关： jackson-databind xml 相关：jackson-dataformat-xml 下面是一些主流的转换工具： 转换工具 说明 json-lib 老牌的转换工具，功能全面， 但第三方依赖多，效率低等，基本停止更新，不推荐使用 。 jackson 当前流行的工具，全面且操作简单。 fastjson alibaba 的产品，以快而闻名，操作简单，但 不支持 xml 。 JSONJackson 支持 对 JSON 的读写操作，以下是需要的 maven 依赖： 123456&lt;!-- https://github.com/FasterXML/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Jackson 提供了三种方式处理 JSON 三种方式并不是相互孤立的，可以相互配合使用。 处理方式 说明 适用场景 数据绑定 需要有对应的 Java类 来 支持 JSON 和 POJO 的互转，包括 JDK对象 和 自定义对象。 适用于数据绑定映射 树模型 以树模型来操作 JSON ，针对树节点操作，更加灵活。 适用于复杂的数据结构 流式API 最佳效率来处理 JSON ，和 树模型 一样良好，操作相对复杂。 适用于追求效率的工作 数据绑定数据绑定 处理方式极其简单，只需要的提供与 Json 相互对应的 Java类 就可以快速完成 java 与 Json 的相互转换。 但局限也是在此，需要场景明确数据结构。 POJO.java 12345678910111213141516public class User &#123; private String username; private int age; // getter and setter ... @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 数据绑定 需要 ObjectMapper 对象，该对象可以重用。该方式同样适用于 Map 和 List 。 123456789101112131415161718192021222324@Testpublic void test() &#123; User user = new User(); user.setUsername("Jack"); user.setAge(18); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // object to json String strJson = objectMapper.writeValueAsString(user); System.out.println(strJson); // &#123;"username":"Jack","age":18&#125; // json to object User obj = objectMapper.readValue(strJson, User.class); System.out.println(obj); // User&#123;username='Jack', age=18&#125; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 树模型树模型 引入了 JsonNode 对象，允许使用操作树节点的方式对 json 进行读写，并且利于遍历。 12345678910111213141516171819202122232425262728293031323334@Testpublic void test() &#123; ObjectMapper objectMapper = new ObjectMapper(); try &#123; // json wirte JsonNode rootNode1 = objectMapper.createObjectNode(); ((ObjectNode) rootNode1).put("username", "Jack"); ((ObjectNode) rootNode1).put("age", 18); String strJson = objectMapper.writeValueAsString(rootNode1); System.out.println(strJson); // &#123;"username":"Jack","age":18&#125; // json read JsonNode rootNode2 = objectMapper.readTree(strJson); System.out.println(rootNode2); // &#123;"username":"Jack","age":18&#125; // iter Iterator&lt;String&gt; fields = rootNode2.fieldNames(); while (fields.hasNext())&#123; String field = fields.next(); System.out.println(field + ":" + rootNode2.get(field)); &#125; // username:"Jack" // age:18 &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 当然此时如果不想使用 JsonNode 对象，可以使用如下方式转换为对应的 Java对象 。 1234// JsonNode to POJOUser obj = objectMapper.treeToValue(rootNode2, User.class);System.out.println(obj);// User&#123;username='Jack', age=18&#125; 流式API流式API 引入了 JsonParser 和 JsonGenerator 两个对象，JsonGenerator 负责写操作， JsonParser 负责读操作。 1234567891011121314151617181920212223242526272829303132/** * 流式写入：JsonGenerator */@Testpublic void test()&#123; StringWriter sw = new StringWriter(); JsonGenerator jsonGen = null; try &#123; jsonGen = new JsonFactory().createGenerator(sw); jsonGen.writeStartObject(); jsonGen.writeStringField("username", "Jack"); jsonGen.writeNumberField("age", 18); jsonGen.writeEndObject(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (jsonGen != null) &#123; try &#123; jsonGen.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // jsonGenerator close 后内容才会被写入 System.out.println(sw.toString()); // &#123;"username":"Jack","age":18,&#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * 流式读取：JsonParser */@Testpublic void test() &#123; String strJson = "&#123;\"age\":28,\"username\":\"Jack\"&#125;"; JsonParser jsonParser = null; try &#123; jsonParser = new JsonFactory().createParser(strJson); if (jsonParser.nextToken() != JsonToken.START_OBJECT) &#123; throw new IOException("解析失败：非JSON格式"); &#125; while (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123; String fieldname = jsonParser.getCurrentName(); if ("username".equals(fieldname))&#123; jsonParser.nextToken(); System.out.println(fieldname + ":" + jsonParser.getText()); // username:Jack &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (jsonParser != null) &#123; try &#123; jsonParser.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 由以上的代码，可以看出单纯的 流操作 比较繁杂，操作起来有些得不偿失。 正如之前所说，这三种方式并不是相互孤立的，可以相互配合使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 流式操作配合数据绑定 */@Testpublic void test() throws ParseException &#123; User user = new User(); user.setUsername("Jack"); user.setAge(19); // object to json JsonFactory jsonFactory = new JsonFactory(); JsonGenerator jsonGen = null; StringWriter sw = new StringWriter(); try &#123; jsonGen = jsonFactory.createGenerator(sw); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.writeValue(jsonGen, user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (jsonGen != null) &#123; try &#123; jsonGen.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println(sw.toString()); // &#123;"username":"Jack","age":19&#125; JsonParser jsonParser = null; // json to object try &#123; jsonParser = jsonFactory.createParser(sw.toString()); ObjectMapper objectMapper = new ObjectMapper(); User obj = objectMapper.readValue(sw.toString(), User.class); System.out.println(obj); // User&#123;username='Jack', age=19&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (jsonParser != null) &#123; try &#123; jsonParser.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JSON 与 XMLJackson 支持 对 XML 的读写操作，以下是需要的 maven 依赖： 123456&lt;!-- https://github.com/FasterXML/jackson-dataformat-xml --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 对 XML 的操作类似于 JSON，这里仅展示 JSON 与 XML 的互转。 12345678910111213141516171819202122232425262728293031323334@Testpublic void test() &#123; String userJson1 = "&#123;\"age\":28,\"username\":\"Jack\"&#125;"; ObjectMapper objectMapper = new ObjectMapper(); XmlMapper xmlMapper = new XmlMapper(); StringWriter sw = new StringWriter(); try &#123; // json to xml JsonNode root = objectMapper.readTree(userJson1); xmlMapper.enable(SerializationFeature.INDENT_OUTPUT); String xml = xmlMapper.writeValueAsString(root); System.out.println(xml); // &lt;ObjectNode&gt; // &lt;age&gt;28&lt;/age&gt; // &lt;username&gt;Jack&lt;/username&gt; // &lt;/ObjectNode&gt; // xml to json JsonParser jsonParser = xmlMapper.getFactory().createParser(xml); JsonGenerator jsonGenerator = objectMapper.getFactory().createGenerator(sw); while (jsonParser.nextToken() != null) &#123; jsonGenerator.copyCurrentEvent(jsonParser); &#125; jsonParser.close(); jsonGenerator.close(); System.out.println(sw.toString()); // &#123;"age":"28","username":"Jack"&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Jackson配置: FeatureJackson 预定义了一些配置，可以通过 configure方法 启用和禁用相关特性（ Feature ），在 Jackson2.5 又进行了细化，新添加了 enable方法 和 disable方法 ，两种方式都可以使用，但推荐后者。 1234567// 启用与禁用：缩进特性mapper.configure(SerializationFeature.INDENT_OUTPUT, true);mapper.configure(SerializationFeature.INDENT_OUTPUT, false);// Jackson2.5 后的等效方法mapper.enable(SerializationFeature.INDENT_OUTPUT);mapper.disable(SerializationFeature.INDENT_OUTPUT); 常用的配置这里列举了一些常用的配置，基本可以满足日常开发。 Jackson 的 Json解析 是严格按照 JSON标准 的，而 JavaScript 中的 json 并不严格按照这个标准的。 1234567891011121314// 支持单引号（兼容 js ）mapper.enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES);// 支持字段名不带引号（兼容 js ）mapper.enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);// 接收 "" 等同 nullmapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);// 时间类型正常输出（默认Date , Calendar会输出为数字，这里禁用）mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);// 遇到未知属性时不抛出异常mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);// null 属性不进行序列化mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); Jackson特性（ JacksonFeatures ）主要包含以下两种，并含有默认值。 数据绑定特性 : MapperFeature , SerializationFeature , DeserializationFeature 。 流式API特性：JsonFactory.Feature , JsonParser.Feature , JsonGenerator.Feature 。 类型格式化Jackson 对于不同的数据类型，实现不同的格式化，这里以 日期类型 为例说明。 默认行为默认序列化 日期类型默认序列化为时间戳（数值型），即 Java 中的日期类型 会默认转换为 JSON中的数值类型 : 距离 1970-01-01 08:00:00 的毫秒差。 默认反序列化 对于日期类型，Jackson 有默认的反序列化格式 StdDateFormat ，即 以下格式字符串 可以转换为 Java 中的日期类型。 JSON数值型 也可以被转换为 java日期类型 。 1234DATE_FORMAT_STR_ISO8601, // "yyyy-MM-dd'T'HH:mm:ss.SSSZ""yyyy-MM-dd'T'HH:mm:ss.SSS", // ISO-8601 but no timezoneDATE_FORMAT_STR_RFC1123, // "EEE, dd MMM yyyy HH:mm:ss zzz"DATE_FORMAT_STR_PLAIN //"yyyy-MM-dd" 自定义格式化： ModuleJackson 提供了功能扩展接口 Module（模块） ， 一般使用 SimpleModule 就可以了， 向其添加 序列化器 和 反序列化器 ，再 注册模块 。 这种方式会覆盖 StdDateFormat ，但是数值型还是可以被正常解析的。 123456// 定义扩展模块SimpleModule module = new SimpleModule();// 添加自定义序列化器module.addSerializer(Date.class, new DateSerializer(false, new SimpleDateFormat("yyyy-MM-dd")));// 注册扩展模块mapper.registerModule(module); 实际上，对于日期类型可以直接使用以下方式简单实现： 两种方式可以并存， module 的优先级更高，推荐使用 module 统一管理扩展。 12// 自定义 序列化格式 与 反序列化格式mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));]]></content>
      <categories>
        <category>Enter</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>JSON</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Maven]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%B5%85%E8%B0%88Maven%2F</url>
    <content type="text"><![CDATA[Maven基于 项目对象模型（POM） ，是纯 Java 开发的开源项目，可以用于 构建和管理各种项目 。类似工具还有： Ant 、 gradle 。 官网： Apache Maven 公共仓库 https://search.maven.org/ https://mvnrepository.com/ https://maven.aliyun.com 构件 &amp; 仓库maven构件 : 在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。 maven仓库 : 存放项目构件的地方。 构件在 Maven 中，任何依赖（jar包，tomcat等），或项目（自己打包的jar,war等）输出都可成为构件。每个构件都有自己的唯一标识（唯一坐标），由 groupId ， artifactId ，和 version 三要素 构成。 构件要素 说明 groupId 必需，当前Maven构件隶属的项目名，一般为 反写的公司公司网址(+项目) 。 artifactId 必需，隶属项目中的模块名，一般为 项目名-模块名 。 version 必需，当前版本。 packaging 默认为 jar，打包方式：jar, war, ear, pom。 versionverison 一般命名格式为 大版本号.分支版本号.小版本号-版本类型 。 版本类型 说明 snapshot 快照版本 alpha 内部版本 beta 公测版本 release 稳定版本 GA 正式版本 packagingpackaging 表示打包种类如 : jar , war , ear 。 pom 表示当前 pom 为引用，一般用于父模块，详情如下： 打包方式 说明 jar Java Archive file，把开发时要引用通用(JAVA)类及资源做封装，打成包后便于存放管理。 war Web Archive file，一个(web)完整的应用，通常是网站或WEB平台，打成包部署到容器中。 ear Enterprise Archive file，企业级应用，实际上EAR包中包含WAR包和几个企业级项目的配置文件而已，服务器中间件通常选择WebSphere等都会使用EAR包。通常是EJB打成ear包。 仓库maven的仓库可以分为 本地仓库 和 远程仓库 两种。 运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。 本地仓库Maven在本地存储构件的地方。其在第一次执行maven命令的时才会被创建。 本地仓库的默认位置为用户的目录下 .m2/repository/。 修改 apache-maven-*\conf\settings.xml 可以更改默认的本地仓库位置。 123&lt;settings&gt; &lt;localRepository&gt;/developer/Repo/MavenRepo&lt;/localRepository&gt; &lt;/settings&gt; 远程仓库远程仓库中可以三种：中央仓库 , 私服 , 其它公共库 。 中央仓库 中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。 最核心的中央仓库是默认的远程仓库，maven在安装的时候，所有的maven项目都会继承超级pom，包含了中央仓库的配置，如下： 1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 私服 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。 当前主流的maven私服： Apache 的 Archiva JFrog 的 Artifactory Sonatype 的 Nexus 其他公共仓库 国外仓库速度较慢，可以国内的镜像仓库，在 settings.xml 的&lt;mirrors&gt;&lt;/mirrors&gt;中如下添加即可。 12345678&lt;!-- 使用阿里云的maven镜像仓库（保证速度稳定） --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;!-- 设置为中央仓库配置镜像 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 依赖管理依赖传递构件具有 依赖传递性 。例如：项目依赖构件A，而构件A又依赖B，Maven会将A和B都视为项目的依赖。 以下依赖范围的构件，不参与传递： provided , test , import 。 解析加载顺序 先 短路优先 ，后 声明优先 。 也可以在 pom.xml 中，使用 &lt;exclusions&gt;&lt;/exclusions&gt; 显式排除某个版本的依赖，以确保项目能够运行。 短路优先：项目声明依赖构件A和B，构件A → C → D(version:1.0.0)，构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.1.0)。 声明优先：项目声明依赖构件A和B，构件A → D(version:1.0.0)， 构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.0.0)。 依赖范围（scope）依赖范围（scope） : 编译期，运行期，测试期，分别对应Maven在项目构建过程中编译的三套 classpath 。而依赖范围，就是为构件指定它可以作用于哪套classpath。可在 &lt;scope&gt;&lt;/scope&gt; 设置。 依赖范围 编译期 测试期 运行期 说明 compile ✓ ✓ ✓ 默认范围 provided ✓ ✓ 希望运行期由web容器提供依赖， 依赖不可传递 。如servlet-api.jar。 runtime ✓ ✓ 编译期无需直接引用，如jdbc驱动的实现。 test ✓ 只在测试目录下才可使用，主目录下回报错， 依赖不可传递 。如设置junit依赖范围。 system ✓ ✓ 必须通过 &lt;systemPath&gt;&lt;/systemPath&gt;元素，显示指定依赖文件的路径，与本地系统相关联，可移植性差。 import 导入依赖，它只使用在 dependencyManagement ，表示导入 此依赖pom 中的依赖，作用类似于 parent ， 依赖不可传递。 聚合 &amp; 继承聚合分层架构、分模块开发，可以提高代码的清晰和重用，在父模块使用&lt;modules&gt;&lt;/modules&gt; 即可聚合多个子模块。 构建父模块时，会自动构建所聚合的子模块。 12345&lt;modules&gt; &lt;module&gt;web&lt;/module&gt; &lt;module&gt;persistence&lt;/module&gt; &lt;module&gt;model&lt;/module&gt;&lt;/modules&gt; 同时需要 packaging 设置为 pom 。 1&lt;packaging&gt;pom&lt;/packaging&gt; 继承继承就是为了避免重复，maven的继承也是这样，它还有一个好处就是让项目更加安全。 在子模块中使用 &lt;parent&gt;&lt;/parent&gt; 即可继承父模块属性。 12345&lt;parent&gt; &lt;artifactId&gt;app-demo&lt;/artifactId&gt; &lt;groupId&gt;org.demo&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 模块化在模块化开发时，需要同时使用 聚合 和 继承。 父模块 123456789&lt;!-- 将packaging 改为 pom --&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;!-- 模块化 --&gt;&lt;modules&gt; &lt;module&gt;web&lt;/module&gt; &lt;module&gt;persistence&lt;/module&gt; &lt;module&gt;model&lt;/module&gt;&lt;/modules&gt; 子模块pom 12345&lt;parent&gt; &lt;artifactId&gt;first-app-demo&lt;/artifactId&gt; &lt;groupId&gt;org.demo&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 生命周期Maven有三个相互独立的标准的生命周期，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行。 涉及一览 说明 clean 项目清理的处理。 default（build） 项目部署的处理。 site 项目站点文档创建的处理。 Clean当执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段，并有相关命令对应。 mvn clean 就是下面的 clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于mvn pre-clean clean 。 clean生命周期 说明 pre-clean 执行实际项目清理之前所需的流程。 clean 删除之前构建生成的所有文件， target目录 等。 post-clean 执行完成项目清理所需的流程。 Default (Build)Default 是 Maven 的主要生命周期，被用于构建应用，包括的 23 个阶段，下面为简化的 7 个阶段： Default简化生命周期 说明 validate 检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。 compile 编译工程源码，生成 target目录 等。 test 自动运行测试用例并分析（如JUnit）。 package 获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。 verify 运行检查操作来验证工程包是有效的，并满足质量要求。 install 安装工程包到本地仓库中。 deploy 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。 Default 完整生命周期，包括了的 23 个阶段： Default完整生命周期 说明 validate 检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。 initialize 初始化构建状态，例如设置属性。 generate-sources 生成编译阶段需要包含的任何源码文件。 process-sources 处理源代码，例如，过滤任何值（filter any value）。 generate-resources 生成工程包中需要包含的资源文件。 process-resources 拷贝和处理资源文件到目的目录中，为打包阶段做准备。 compile 编译工程源码。 process-classes 处理编译生成的文件，例如 Java Class 字节码的加强和优化。 generate-test-sources 生成编译阶段需要包含的任何测试源代码。 process-test-sources 处理测试源代码，例如，过滤任何值（filter any values)。 test-compile 编译测试源代码到测试目的目录。 process-test-classes 处理测试代码文件编译后生成的文件。 test 使用适当的单元测试框架（例如JUnit）运行测试。 prepare-package 在真正打包之前，为准备打包执行任何必要的操作。 package 获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。 pre-integration-test 在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。 integration-test 处理和部署必须的工程包到集成测试能够运行的环境中。 post-integration-test 在集成测试被执行后执行必要的操作。例如，清理环境。 verify 运行检查操作来验证工程包是有效的，并满足质量要求。 install 安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。 deploy 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。 SiteMaven Site 插件一般用来创建新的报告文档、部署站点等。 site 生命周期 说明 pre-site 执行一些需要在生成站点文档之前完成的工作。 site 生成项目的站点文档。 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备。 site-deploy 将生成的站点文档部署到特定的服务器上。 POM元素解析pom.xml 是 maven 项目的配置文件。 因为 pom.xml 内的元素众多，为便于记忆，这里梳理了一些长常见的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- pom版本（模型版本）--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 构件坐标三要素 --&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;demo-maven&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!--打包类型，默认是jar，还有war/ear/pom--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 项目描述名 --&gt; &lt;name&gt;A Maven Project Demo&lt;/name&gt; &lt;!-- 项目地址 --&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 项目描述 --&gt; &lt;description&gt;A Maven Project Demo&lt;/description&gt; &lt;!-- 开发人员列表 --&gt; &lt;!--&lt;developers&gt;&lt;/developers&gt;--&gt; &lt;!-- 许可证 --&gt; &lt;!--&lt;licenses&gt;&lt;/licenses&gt;--&gt; &lt;!-- 组织信息 --&gt; &lt;!--&lt;organization&gt;&lt;/organization&gt;--&gt; &lt;!-- 属性列表: 提供公共变量值 --&gt; &lt;properties&gt; &lt;!-- 使用方式: $&#123;java.version&#125; --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!--依赖管理: 相当于提供了一些依赖的默认配置。 只有在依赖列表中引入了相关依赖，且没有提供相关配置时才会生效。 作用如：不显示提供版本号，用于依赖版本的统一管理。 --&gt; &lt;!--&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;--&gt; &lt;!--依赖列表--&gt; &lt;dependencies&gt;&lt;/dependencies&gt; &lt;!-- 项目构建相关 --&gt; &lt;build&gt; &lt;!-- 生成构件的命名，默认为$&#123;artifactId&#125;-$&#123;version&#125; --&gt; &lt;!--&lt;finalName&gt;MavenTest&lt;/finalName&gt;--&gt; &lt;!--插件列表--&gt; &lt;plugins&gt;&lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; dependency1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!-- 只在测试依赖范围内有用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--依赖是否可选，默认为false。设置为true表示不可继承--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!--排除依赖传递列表--&gt; &lt;!--&lt;exclusions&gt;&lt;/exclusions&gt;--&gt;&lt;/dependency&gt; 变量除了可以在.&lt;properties /&gt; 自定义变量，Maven 也提供了一些内置变量。 内置变量 说明 ${project.xxx} 当前pom文件的任意节点的内容。 ${basedir} 项目根目录(即pom.xml文件所在目录)。 ${project.build.directory} 构建目录，缺省为target目录。 ${project.build.outputDirectory} 构建过程输出目录，缺省为target/classes。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version}。 ${project.packaging} 打包类型，缺省为jar。 ${env.xxx} 获取系统环境变量。例如,”env.PATH”指代了$path环境变量（在Windows上是%PATH%）。 ${settings.xxx} 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt; 通过 ${settings.offline} 获得offline的值。 Java System Properties 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用，例如 ${JAVA_HOME}。 插件Maven插件 : maven 的所有工作都是由各种插件完成的，而 maven命令 会控制对应 maven插件 完成相应任务。 maven 自带了一些插件，在 pom.xml 中也可以配置自己需要的插件。 插件类型 配置位置 构建插件 &lt;build&gt;&lt;/build&gt; 报告插件 &lt;reporting&gt;&lt;/reporting&gt; archetypeArchetype插件 是一个 Maven 项目模板工具包，可以使用其来构建项目。输入以下命令后，会出现原型列表，一般选择 maven-archetype-webapp 即可。 -D 为定义所需参数，也可以直接使用 mvn archetype:generate 来构建，maven 会交互式询问所需参数。 123456# 回车键需要替换为空格mvn archetype:generate -DgroupId=组织名，反写网址名+项目名 -DartifactId=项目名/项目名-模块名 -Dversion=版本号 -Dpackage=包名（默认DgroupId） 默认目录骨架 以下是 maven 的默认目录结构，部分需要自行完善。 手动创建以下目录结构也是可行的。 12345678910111213.├── src│ ├── main│ │ ├── java│ │ ├── resources│ │ │ └── application.properties│ │ └── webapp│ │ └── WEB-INF│ │ └── web.xml│ └── test│ └── java├── pom.xml└── target compilerCompiler插件 ： maven 具有自带的编译插件，即 mvn compiler 所用插件，它有默认值。因为多个项目所需的编译环境可能不同，所以推荐在 pom 中单独配置。 有时可能不会配置这个插件，而是通过修改 本地 maven 配置 或 IDE的 maven 配置 来避免错误，但这是不推荐的方式，不利于项目管理。 1234567891011&lt;!-- compiler：编译插件设置 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; sourceSource插件 可以将源代码进行打包，其中会包含 代码注释 等。 123456789101112131415161718&lt;!-- source：打包源代码插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;attach&gt;true&lt;/attach&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在对应生命周期（阶段）触发 --&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;!-- 目标为jar: http://maven.apache.org/plugins/maven-source-plugin/ --&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Git]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%B5%85%E8%B0%88Git%2F</url>
    <content type="text"><![CDATA[Git 是一个开源的分布式版本控制系统（VCS），也是个内容管理系统(CMS)，可以高效地处理各种项目。 官网： Git Pro Git 基本操作以下是 Git 的基本命令和对应操作内容的示意图： 域新建的一个 git项目，会在项目根目录下创建一个隐藏的 .git 目录，用于存放 git 所需信息。当我们变更项目文件时是不会直接作用于 git 的，需要相关命令才能触发相应操作。一般也将 .git 目录 称之为 版本库。 域 说明 Remote 远程仓库。 Repository 仓库区（或本地仓库），存于 .git 目录 。 Index / Stage 暂存区，即缓存，存于 .git/index 文件。 Workspace 工作区，可视的，直接操作的目录。 操作命令 git pull 相当于 git fetch + git merge 。 git checkout 是个很危险的命令，不管是切换分支或文件，请确保已 commit ，否则可能会丢失文件记录。 操作命令 说明 git clone [url] 克隆远程仓库到本地，包括了工作区和版本库 。 git pull 拉取远程仓库到本地，并合并。 git add ./--all 添加所有到暂存区。 git commit -m &quot;info&quot; 提交并描述，提交到本地仓库。 git push 发布(publish)到远程仓库。 git checkout (branchname) 切换分支。 git fetch 从远程仓库获取最新到本地，不合并。 常用操作12# 查看帮助$ git help git 的部分命令可能会调用 vim 文本编辑器，这里简单列举一些常用操作： vim 涉及 说明 i 切换光标为输入/替换模式，光标将变成竖线/下划线。 Esc 退出当前模式 shift + : 进入底线命令模式。此时 q 为退出， w 为保存，! 为强制，可以叠加。 获取和初始化项目git init1234# 在当前目录新建一个Git代码库$ mkdir Hellow-World$ cd Hellow-World$ git init 12# 新建一个目录，将其初始化为Git代码库$ git init [project-name] git clone12# 下载项目和默认分支的代码历史$ git clone git@github.com:username/Hello-World.git 基本快照Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。这里将对操作项目快照的命令作介绍。 git add1234567# 新建文件$ touch README.md# 添加指定目录到暂存区，包括子目录：$ git add [dir]# 添加指定文件到暂存区：$ git add [file1] [file2] ...# 添加当前目录的所有文件到暂存区$ git add . git status12# 显示有变更的文件（未commit的文件）$ git status git diff12# 显示暂存区与工作区的差异(只针对暂存区已存在的文件)$ git diff git commit12# 提交暂存区到仓库区$ git commit -m "Repo init" 12# 使用一次新的commit，替代上一次提交$ git commit --amend -m [message] git reset123# 重置暂存区与工作区，与上一次commit保持一致# (工作区新增文件，且没有加入暂存区则不会变动)$ git reset --hard 12345# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit-hash]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit-hash] git rm / git mv12# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... 12# 重命名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 共享和更新项目git remote 如果项目是 git clone 下来的会自带连接的远程仓库。 12# 为本地仓库设置远程仓库origin$ git remote add origin [remote-url] git fetch12# 下载远程仓库的所有变动$ git fetch [remote-url] git pull git pull 相当于 git fetch + git merge 。 12# 拉取远程仓库的变化，并与本地分支合并$ git pull git push12# 推送本地指定分支到远程仓库$ git push 12345# 推送所有分支到远程仓库$ git push --all# 强行推送当前分支到远程仓库，即使有冲突$ git push --force 分支和合并使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 git branch12345678910# 列出所有远程分支：$ git branch -r# 列出所有本地分支和远程分支：$ git branch -a# 列出所有本地分支$ git branch# 新建一个分支，以当前分支和最新 commit 为基础$ git branch [branch-name]# 删除分支$ git branch -d [branch-name] 12# 新建一个分支，指向指定commit$ git branch [branch-name] [commit-hash] git checkoutgit checkout 是个很危险的命令，不管是切换分支或文件，请确保已 commit ，否则可能会丢失文件记录。 当两个分支的最新 commit 的散列码不相同时，若存在未 commit 文件，cheout 时会失败并提示； 当两个分支的最新 commit 的散列码相同时，cheout 时，未 commit 的文件会带入当另一个分支中。 12345# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout - 12# 新建一个分支，并切换到该分支$ git checkout -b [branch-name] git merge12# 合并指定分支到当前分支$ git merge [branch] git log12345678# 显示当前分支的commit历史$ git log# 历史记录的简洁的版本$ git log --oneline# 显示commit历史，以及变更的内容$ git log --stat 1234567# 展示当前版本树git log --graph# 展示所有版本树git log --graph --all# 显示指定文件相关的每一次diff$ git log -p [file] git tag如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 123456# 仅添加标签：$ git tag [tag-name]# 添加标签，并要求注释$ git tag -a [tag-name]# 带tag的commit记录$ git log --decorate 常用开发方案 .gitignore在 .gitignore 文件中配置的文件不会被 Git 管理。 12345678910111213141516171819202122232425262728293031323334*.class# package file*.war*.ear# kdiff3 ignore*.orig# maven ignoretarget/# idea.idea//idea/*.ipr*.iml*.iws# eclipse ignore.settings/.project.classpatch# temp file*.log*.cache*.diff*.patch*.tmp# system ignore.DS_StoreThumbs.db]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[附录:Thymeleaf表达式实用程序对象]]></title>
    <url>%2F2018%2F12%2F26%2F%E9%99%84%E5%BD%95%E4%B9%8BThymeleaf%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[本文用于记录 Thymeleaf中的表达式实用程序对象，原文地址：附录B：表达式实用程序对象 。 执行信息 #execInfo：表达式对象，提供有关在Thymeleaf标准表达式中处理的模板的有用信息。 123456789101112131415161718192021222324252627282930313233343536373839404142/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.ExecutionInfo * ====================================================================== *//* * Return the name and mode of the 'leaf' template. This means the template * from where the events being processed were parsed. So if this piece of * code is not in the root template "A" but on a fragment being inserted * into "A" from another template called "B", this will return "B" as a * name, and B's mode as template mode. */$&#123;#execInfo.templateName&#125;$&#123;#execInfo.templateMode&#125;/* * Return the name and mode of the 'root' template. This means the template * that the template engine was originally asked to process. So if this * piece of code is not in the root template "A" but on a fragment being * inserted into "A" from another template called "B", this will still * return "A" and A's template mode. */$&#123;#execInfo.processedTemplateName&#125;$&#123;#execInfo.processedTemplateMode&#125;/* * Return the stacks (actually, List&lt;String&gt; or List&lt;TemplateMode&gt;) of * templates being processed. The first element will be the * 'processedTemplate' (the root one), the last one will be the 'leaf' * template, and in the middle all the fragments inserted in nested * manner to reach the leaf from the root will appear. */$&#123;#execInfo.templateNames&#125;$&#123;#execInfo.templateModes&#125;/* * Return the stack of templates being processed similarly (and in the * same order) to 'templateNames' and 'templateModes', but returning * a List&lt;TemplateData&gt; with the full template metadata. */$&#123;#execInfo.templateStack&#125; 消息 #messages：用于在变量表达式中获取外部化消息的实用程序方法，与使用#{...}语法获取它们的方式相同。 123456789101112131415161718192021222324252627282930313233/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Messages * ====================================================================== *//* * Obtain externalized messages. Can receive a single key, a key plus arguments, * or an array/list/set of keys (in which case it will return an array/list/set of * externalized messages). * If a message is not found, a default message (like '??msgKey??') is returned. */$&#123;#messages.msg('msgKey')&#125;$&#123;#messages.msg('msgKey', param1)&#125;$&#123;#messages.msg('msgKey', param1, param2)&#125;$&#123;#messages.msg('msgKey', param1, param2, param3)&#125;$&#123;#messages.msgWithParams('msgKey', new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsg(messageKeyArray)&#125;$&#123;#messages.listMsg(messageKeyList)&#125;$&#123;#messages.setMsg(messageKeySet)&#125;/* * Obtain externalized messages or null. Null is returned instead of a default * message if a message for the specified key is not found. */$&#123;#messages.msgOrNull('msgKey')&#125;$&#123;#messages.msgOrNull('msgKey', param1)&#125;$&#123;#messages.msgOrNull('msgKey', param1, param2)&#125;$&#123;#messages.msgOrNull('msgKey', param1, param2, param3)&#125;$&#123;#messages.msgOrNullWithParams('msgKey', new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsgOrNull(messageKeyArray)&#125;$&#123;#messages.listMsgOrNull(messageKeyList)&#125;$&#123;#messages.setMsgOrNull(messageKeySet)&#125; URI #uris：用于在Thymeleaf标准表达式中执行URI / URL操作（尤其是转义/转义）的实用程序对象。 12345678910111213141516171819202122232425262728293031323334353637/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Uris * ====================================================================== *//* * Escape/Unescape as a URI/URL path */$&#123;#uris.escapePath(uri)&#125;$&#123;#uris.escapePath(uri, encoding)&#125;$&#123;#uris.unescapePath(uri)&#125;$&#123;#uris.unescapePath(uri, encoding)&#125;/* * Escape/Unescape as a URI/URL path segment (between '/' symbols) */$&#123;#uris.escapePathSegment(uri)&#125;$&#123;#uris.escapePathSegment(uri, encoding)&#125;$&#123;#uris.unescapePathSegment(uri)&#125;$&#123;#uris.unescapePathSegment(uri, encoding)&#125;/* * Escape/Unescape as a Fragment Identifier (#frag) */$&#123;#uris.escapeFragmentId(uri)&#125;$&#123;#uris.escapeFragmentId(uri, encoding)&#125;$&#123;#uris.unescapeFragmentId(uri)&#125;$&#123;#uris.unescapeFragmentId(uri, encoding)&#125;/* * Escape/Unescape as a Query Parameter (?var=value) */$&#123;#uris.escapeQueryParam(uri)&#125;$&#123;#uris.escapeQueryParam(uri, encoding)&#125;$&#123;#uris.unescapeQueryParam(uri)&#125;$&#123;#uris.unescapeQueryParam(uri, encoding)&#125; 转换 #conversions：允许在模板的任何位置执行转换服务的实用程序对象： 123456789101112/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Conversions * ====================================================================== *//* * Execute the desired conversion of the 'object' value into the * specified class. */$&#123;#conversions.convert(object, 'java.util.TimeZone')&#125;$&#123;#conversions.convert(object, targetClass)&#125; 常用类型日期 #dates：java.util.Date对象的实用方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Dates * ====================================================================== *//* * Format date with the standard locale format * Also works with arrays, lists or sets */$&#123;#dates.format(date)&#125;$&#123;#dates.arrayFormat(datesArray)&#125;$&#123;#dates.listFormat(datesList)&#125;$&#123;#dates.setFormat(datesSet)&#125;/* * Format date with the ISO8601 format * Also works with arrays, lists or sets */$&#123;#dates.formatISO(date)&#125;$&#123;#dates.arrayFormatISO(datesArray)&#125;$&#123;#dates.listFormatISO(datesList)&#125;$&#123;#dates.setFormatISO(datesSet)&#125;/* * Format date with the specified pattern * Also works with arrays, lists or sets */$&#123;#dates.format(date, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')&#125;/* * Obtain date properties * Also works with arrays, lists or sets */$&#123;#dates.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#dates.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#dates.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#dates.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#dates.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#dates.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#dates.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#dates.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#dates.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#dates.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#dates.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#dates.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./* * Create date (java.util.Date) objects from its components */$&#123;#dates.create(year,month,day)&#125;$&#123;#dates.create(year,month,day,hour,minute)&#125;$&#123;#dates.create(year,month,day,hour,minute,second)&#125;$&#123;#dates.create(year,month,day,hour,minute,second,millisecond)&#125;/* * Create a date (java.util.Date) object for the current date and time */$&#123;#dates.createNow()&#125;$&#123;#dates.createNowForTimeZone()&#125;/* * Create a date (java.util.Date) object for the current date (time set to 00:00) */$&#123;#dates.createToday()&#125;$&#123;#dates.createTodayForTimeZone()&#125; 日历 #calendars：类似于#dates，但对于java.util.Calendar对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Calendars * ====================================================================== *//* * Format calendar with the standard locale format * Also works with arrays, lists or sets */$&#123;#calendars.format(cal)&#125;$&#123;#calendars.arrayFormat(calArray)&#125;$&#123;#calendars.listFormat(calList)&#125;$&#123;#calendars.setFormat(calSet)&#125;/* * Format calendar with the ISO8601 format * Also works with arrays, lists or sets */$&#123;#calendars.formatISO(cal)&#125;$&#123;#calendars.arrayFormatISO(calArray)&#125;$&#123;#calendars.listFormatISO(calList)&#125;$&#123;#calendars.setFormatISO(calSet)&#125;/* * Format calendar with the specified pattern * Also works with arrays, lists or sets */$&#123;#calendars.format(cal, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.arrayFormat(calArray, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.listFormat(calList, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.setFormat(calSet, 'dd/MMM/yyyy HH:mm')&#125;/* * Obtain calendar properties * Also works with arrays, lists or sets */$&#123;#calendars.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#calendars.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#calendars.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#calendars.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#calendars.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#calendars.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#calendars.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#calendars.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#calendars.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#calendars.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#calendars.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#calendars.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./* * Create calendar (java.util.Calendar) objects from its components */$&#123;#calendars.create(year,month,day)&#125;$&#123;#calendars.create(year,month,day,hour,minute)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second,millisecond)&#125;$&#123;#calendars.createForTimeZone(year,month,day,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,millisecond,timeZone)&#125;/* * Create a calendar (java.util.Calendar) object for the current date and time */$&#123;#calendars.createNow()&#125;$&#123;#calendars.createNowForTimeZone()&#125;/* * Create a calendar (java.util.Calendar) object for the current date (time set to 00:00) */$&#123;#calendars.createToday()&#125;$&#123;#calendars.createTodayForTimeZone()&#125; 数字 #numbers：数字对象的实用方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Numbers * ====================================================================== *//* * ========================== * Formatting integer numbers * ========================== *//* * Set minimum integer digits. * Also works with arrays, lists or sets */$&#123;#numbers.formatInteger(num,3)&#125;$&#123;#numbers.arrayFormatInteger(numArray,3)&#125;$&#123;#numbers.listFormatInteger(numList,3)&#125;$&#123;#numbers.setFormatInteger(numSet,3)&#125;/* * Set minimum integer digits and thousands separator: * 'POINT', 'COMMA', 'WHITESPACE', 'NONE' or 'DEFAULT' (by locale). * Also works with arrays, lists or sets */$&#123;#numbers.formatInteger(num,3,'POINT')&#125;$&#123;#numbers.arrayFormatInteger(numArray,3,'POINT')&#125;$&#123;#numbers.listFormatInteger(numList,3,'POINT')&#125;$&#123;#numbers.setFormatInteger(numSet,3,'POINT')&#125;/* * ========================== * Formatting decimal numbers * ========================== *//* * Set minimum integer digits and (exact) decimal digits. * Also works with arrays, lists or sets */$&#123;#numbers.formatDecimal(num,3,2)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2)&#125;$&#123;#numbers.listFormatDecimal(numList,3,2)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2)&#125;/* * Set minimum integer digits and (exact) decimal digits, and also decimal separator. * Also works with arrays, lists or sets */$&#123;#numbers.formatDecimal(num,3,2,'COMMA')&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2,'COMMA')&#125;$&#123;#numbers.listFormatDecimal(numList,3,2,'COMMA')&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2,'COMMA')&#125;/* * Set minimum integer digits and (exact) decimal digits, and also thousands and * decimal separator. * Also works with arrays, lists or sets */$&#123;#numbers.formatDecimal(num,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.listFormatDecimal(numList,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.setFormatDecimal(numSet,3,'POINT',2,'COMMA')&#125;/* * ===================== * Formatting currencies * ===================== */$&#123;#numbers.formatCurrency(num)&#125;$&#123;#numbers.arrayFormatCurrency(numArray)&#125;$&#123;#numbers.listFormatCurrency(numList)&#125;$&#123;#numbers.setFormatCurrency(numSet)&#125;/* * ====================== * Formatting percentages * ====================== */$&#123;#numbers.formatPercent(num)&#125;$&#123;#numbers.arrayFormatPercent(numArray)&#125;$&#123;#numbers.listFormatPercent(numList)&#125;$&#123;#numbers.setFormatPercent(numSet)&#125;/* * Set minimum integer digits and (exact) decimal digits. */$&#123;#numbers.formatPercent(num, 3, 2)&#125;$&#123;#numbers.arrayFormatPercent(numArray, 3, 2)&#125;$&#123;#numbers.listFormatPercent(numList, 3, 2)&#125;$&#123;#numbers.setFormatPercent(numSet, 3, 2)&#125;/* * =============== * Utility methods * =============== *//* * Create a sequence (array) of integer numbers going * from x to y */$&#123;#numbers.sequence(from,to)&#125;$&#123;#numbers.sequence(from,to,step)&#125; 字符串 #strings：String对象的实用方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Strings * ====================================================================== *//* * Null-safe toString() */$&#123;#strings.toString(obj)&#125; // also array*, list* and set*/* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets */$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;/* * Perform an 'isEmpty()' check on a string and return it if false, defaulting to * another specified string if true. * Also works with arrays, lists or sets */$&#123;#strings.defaultString(text,default)&#125;$&#123;#strings.arrayDefaultString(textArr,default)&#125;$&#123;#strings.listDefaultString(textList,default)&#125;$&#123;#strings.setDefaultString(textSet,default)&#125;/* * Check whether a fragment is contained in a String * Also works with arrays, lists or sets */$&#123;#strings.contains(name,'ez')&#125; // also array*, list* and set*$&#123;#strings.containsIgnoreCase(name,'ez')&#125; // also array*, list* and set*/* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */$&#123;#strings.startsWith(name,'Don')&#125; // also array*, list* and set*$&#123;#strings.endsWith(name,endingFragment)&#125; // also array*, list* and set*/* * Substring-related operations * Also works with arrays, lists or sets */$&#123;#strings.indexOf(name,frag)&#125; // also array*, list* and set*$&#123;#strings.substring(name,3,5)&#125; // also array*, list* and set*$&#123;#strings.substringAfter(name,prefix)&#125; // also array*, list* and set*$&#123;#strings.substringBefore(name,suffix)&#125; // also array*, list* and set*$&#123;#strings.replace(name,'las','ler')&#125; // also array*, list* and set*/* * Append and prepend * Also works with arrays, lists or sets */$&#123;#strings.prepend(str,prefix)&#125; // also array*, list* and set*$&#123;#strings.append(str,suffix)&#125; // also array*, list* and set*/* * Change case * Also works with arrays, lists or sets */$&#123;#strings.toUpperCase(name)&#125; // also array*, list* and set*$&#123;#strings.toLowerCase(name)&#125; // also array*, list* and set*/* * Split and join */$&#123;#strings.arrayJoin(namesArray,',')&#125;$&#123;#strings.listJoin(namesList,',')&#125;$&#123;#strings.setJoin(namesSet,',')&#125;$&#123;#strings.arraySplit(namesStr,',')&#125; // returns String[]$&#123;#strings.listSplit(namesStr,',')&#125; // returns List&lt;String&gt;$&#123;#strings.setSplit(namesStr,',')&#125; // returns Set&lt;String&gt;/* * Trim * Also works with arrays, lists or sets */$&#123;#strings.trim(str)&#125; // also array*, list* and set*/* * Compute length * Also works with arrays, lists or sets */$&#123;#strings.length(str)&#125; // also array*, list* and set*/* * Abbreviate text making it have a maximum size of n. If text is bigger, it * will be clipped and finished in "..." * Also works with arrays, lists or sets */$&#123;#strings.abbreviate(str,10)&#125; // also array*, list* and set*/* * Convert the first character to upper-case (and vice-versa) */$&#123;#strings.capitalize(str)&#125; // also array*, list* and set*$&#123;#strings.unCapitalize(str)&#125; // also array*, list* and set*/* * Convert the first character of every word to upper-case */$&#123;#strings.capitalizeWords(str)&#125; // also array*, list* and set*$&#123;#strings.capitalizeWords(str,delimiters)&#125; // also array*, list* and set*/* * Escape the string */$&#123;#strings.escapeXml(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJavaScript(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJavaScript(str)&#125; // also array*, list* and set*/* * Null-safe comparison and concatenation */$&#123;#strings.equals(first, second)&#125;$&#123;#strings.equalsIgnoreCase(first, second)&#125;$&#123;#strings.concat(values...)&#125;$&#123;#strings.concatReplaceNulls(nullValue, values...)&#125;/* * Random */$&#123;#strings.randomAlphanumeric(count)&#125; 对象 #objects：一般对象的实用程序方法 1234567891011121314/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Objects * ====================================================================== *//* * Return obj if it is not null, and default otherwise * Also works with arrays, lists or sets */$&#123;#objects.nullSafe(obj,default)&#125;$&#123;#objects.arrayNullSafe(objArray,default)&#125;$&#123;#objects.listNullSafe(objList,default)&#125;$&#123;#objects.setNullSafe(objSet,default)&#125; 布尔 #bools：布尔评估的实用程序方法 12345678910111213141516171819202122232425262728293031323334353637383940/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Bools * ====================================================================== *//* * Evaluate a condition in the same way that it would be evaluated in a th:if tag * (see conditional evaluation chapter afterwards). * Also works with arrays, lists or sets */$&#123;#bools.isTrue(obj)&#125;$&#123;#bools.arrayIsTrue(objArray)&#125;$&#123;#bools.listIsTrue(objList)&#125;$&#123;#bools.setIsTrue(objSet)&#125;/* * Evaluate with negation * Also works with arrays, lists or sets */$&#123;#bools.isFalse(cond)&#125;$&#123;#bools.arrayIsFalse(condArray)&#125;$&#123;#bools.listIsFalse(condList)&#125;$&#123;#bools.setIsFalse(condSet)&#125;/* * Evaluate and apply AND operator * Receive an array, a list or a set as parameter */$&#123;#bools.arrayAnd(condArray)&#125;$&#123;#bools.listAnd(condList)&#125;$&#123;#bools.setAnd(condSet)&#125;/* * Evaluate and apply OR operator * Receive an array, a list or a set as parameter */$&#123;#bools.arrayOr(condArray)&#125;$&#123;#bools.listOr(condList)&#125;$&#123;#bools.setOr(condSet)&#125; 集合类型数组 #arrays：数组的实用程序方法 123456789101112131415161718192021222324252627282930313233343536373839/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Arrays * ====================================================================== *//* * Converts to array, trying to infer array component class. * Note that if resulting array is empty, or if the elements * of the target object are not all of the same class, * this method will return Object[]. */$&#123;#arrays.toArray(object)&#125;/* * Convert to arrays of the specified component class. */$&#123;#arrays.toStringArray(object)&#125;$&#123;#arrays.toIntegerArray(object)&#125;$&#123;#arrays.toLongArray(object)&#125;$&#123;#arrays.toDoubleArray(object)&#125;$&#123;#arrays.toFloatArray(object)&#125;$&#123;#arrays.toBooleanArray(object)&#125;/* * Compute length */$&#123;#arrays.length(array)&#125;/* * Check whether array is empty */$&#123;#arrays.isEmpty(array)&#125;/* * Check if element or elements are contained in array */$&#123;#arrays.contains(array, element)&#125;$&#123;#arrays.containsAll(array, elements)&#125; List #lists：列表的实用程序方法 123456789101112131415161718192021222324252627282930313233/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Lists * ====================================================================== *//* * Converts to list */$&#123;#lists.toList(object)&#125;/* * Compute size */$&#123;#lists.size(list)&#125;/* * Check whether list is empty */$&#123;#lists.isEmpty(list)&#125;/* * Check if element or elements are contained in list */$&#123;#lists.contains(list, element)&#125;$&#123;#lists.containsAll(list, elements)&#125;/* * Sort a copy of the given list. The members of the list must implement * comparable or you must define a comparator. */$&#123;#lists.sort(list)&#125;$&#123;#lists.sort(list, comparator)&#125; Set #sets：集合的实用程序方法 1234567891011121314151617181920212223242526/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Sets * ====================================================================== *//* * Converts to set */$&#123;#sets.toSet(object)&#125;/* * Compute size */$&#123;#sets.size(set)&#125;/* * Check whether set is empty */$&#123;#sets.isEmpty(set)&#125;/* * Check if element or elements are contained in set */$&#123;#sets.contains(set, element)&#125;$&#123;#sets.containsAll(set, elements)&#125; Map #maps：地图的实用程序方法 1234567891011121314151617181920212223/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Maps * ====================================================================== *//* * Compute size */$&#123;#maps.size(map)&#125;/* * Check whether map is empty */$&#123;#maps.isEmpty(map)&#125;/* * Check if key/s or value/s are contained in maps */$&#123;#maps.containsKey(map, key)&#125;$&#123;#maps.containsAllKeys(map, keys)&#125;$&#123;#maps.containsValue(map, value)&#125;$&#123;#maps.containsAllValues(map, value)&#125; 集合操作 #aggregates：用于在数组或集合上创建聚合的实用程序方法 1234567891011121314151617/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Aggregates * ====================================================================== *//* * Compute sum. Returns null if array or collection is empty */$&#123;#aggregates.sum(array)&#125;$&#123;#aggregates.sum(collection)&#125;/* * Compute average. Returns null if array or collection is empty */$&#123;#aggregates.avg(array)&#125;$&#123;#aggregates.avg(collection)&#125; 标识 #ids：用于处理id可能重复的属性的实用程序方法（例如，作为迭代的结果）。 12345678910111213141516171819202122/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Ids * ====================================================================== *//* * Normally used in th:id attributes, for appending a counter to the id attribute value * so that it remains unique even when involved in an iteration process. */$&#123;#ids.seq('someId')&#125;/* * Normally used in th:for attributes in &lt;label&gt; tags, so that these labels can refer to Ids * generated by means if the #ids.seq(...) function. * * Depending on whether the &lt;label&gt; goes before or after the element with the #ids.seq(...) * function, the "next" (label goes before "seq") or the "prev" function (label goes after * "seq") function should be called. */$&#123;#ids.next('someId')&#125;$&#123;#ids.prev('someId')&#125;]]></content>
      <categories>
        <category>附录</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Thymeleaf]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%B5%85%E8%B0%88Thymeleaf%2F</url>
    <content type="text"><![CDATA[Thymeleaf 是一个跟 FreeMarker、Velocity 类似的模板引擎，是 Spring 所推荐的模板技术 。 Thymeleaf 引以为傲的特性是 自然模板（natural templating） ，即由于主要语法基于标签属性等，使得模板可以直接在静态环境显示正常。 本文内容基于 Thymeleaf3.0 。 Thymeleaf文档 使用Thymeleaf Thymeleaf+Spring 本文内容只基于 html模板 ，虽然Thymeleaf 提供了文本模板模式（Textual template modes），使其可以作用于 .js 和 .css ，但是这里不会涉及。 方言和属性修改器方言 Thymeleaf 集成包定义了一种 标准方言 （ SpringStandard Dialect ），其兼容了 Spring EL ，而 Spring EL 基本和 OGNL 相同，所以使用起来十分友好。 属性修改器 标准方言的多数处理器都是属性处理器，Thymeleaf 可以使用两种属性修改器语法 ： 属性修改器语法 说明 示例 th:* 命名空间语法。 &lt;input th:value=&quot;${username}&quot;&gt; data-{prefix}-{name} html5自定义属性语法。 &lt;input data-th-value=&quot;${username}&quot;&gt; 一般来说，使用这种语法是可以直接在浏览器打开的（浏览器会忽略不可识别的属性），所以 Thymeleaf 是 自然模板 。但实际上 th:* 并不符合 HTML5 规范，IDE还是会提示错误。可以使用引入以下 xmlns 命名空间定义： 1&lt;html xmlns:th="http://www.thymeleaf.org"&gt; 可以看出 data-th-* 相较 th:* 对 HTML5 更加友好，两种方式都适用HTML5的各种属性。 但实际上 data-th-* 只是对 th:* 的补充，官方示例推崇 th:* 语法。 其实还有另一种语法：{prefix}:{name} 或 {prefix}-{name} ，其可以指定自定义标签。 例如： 可以使用 th:block 或 th-block 元素，来表示自定义标签。 标准表达式语法在属性修改器中可以使用一些标准表达式是语法。 在大括号外面的数据由Thymeleaf来处理。而在大括号内写的，将由OGNL / SpringEL引擎负责。 涉及一览 说明 ${...} 变量表达式 *{...} 选择变量表达式 #{...} 消息表达式 @{...} URL 链接表达式 变量表达式通过 ${...} 可以从 context 中获取变量。 使用 . 或者 [] 访问属性，相当于调用 getter 。 123$&#123;person.father.name&#125;$&#123;person['father']['name']&#125; 对于 Map对象，如下使用，相当于 get(...) 。 123$&#123;countriesByCode.ES&#125;$&#123;personsByName['Stephen Zucchini'].age&#125; 对于 数组 或 集合 对象，可以使用索引访问。 1$&#123;personsArray[0].name&#125; 甚至可以直接调用方法。 123$&#123;person.createCompleteName()&#125;$&#123;person.createCompleteNameWithSeparator('-')&#125; 实用对象（Expression Utility）Thymeleaf内置了许多实用对象，这里使用内置工具类格式化日期类型。 附录B：表达式实用程序对象 123&lt;p&gt; Today is: &lt;span th:text="$&#123;#calendars.format(today,'yyyy-MM-dd')&#125;"&gt;13 May 2018&lt;/span&gt;&lt;/p&gt; 选择表达式*{...} 一般配合 th:object 使用，优先从其选定的对象中取值，当没有th:object 时，其作用等同${...}。 当多次从一个对象中获取属性时，可以如下使用： 1234&lt;div th:object="$&#123;session.user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 其等同于以下写法： 1234&lt;div&gt; &lt;p&gt;Name: &lt;span th:text="$&#123;session.user.firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="$&#123;session.user.lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 消息表达式使用 #{...} 可以直接使用消息（message），其一般用于国际化。 配置国际化文件 classpath:i18n/messages_zh_CN.properties 。 1home.welcome=欢迎来到我们的杂货店！ 在模板中使用消息。 1&lt;p th:utext="#&#123;home.welcome&#125;"&gt;Welcome to our grocery store!&lt;/p&gt; URL链接表达式使用 @{...} 可以用于处理 URL链接。 12// 服务器中的上下文名称将自动添加@&#123;/itemdetails&#125; 片段表达式使用 ~{...} 可以将模板片段作为变量使用，这个会在谈Thymeleaf 布局（ Layout ）时再介绍 。 标准表达式支持的语法字面（Literals） 其实这里是介绍支持的各种数据类型。 1234567891011121314151617181920&lt;!-- 文字 --&gt;&lt;p&gt; Now you are looking at a &lt;span th:text="'working web application'"&gt;template file&lt;/span&gt;.&lt;/p&gt;&lt;!-- 数字 --&gt;&lt;p&gt;The year is &lt;span th:text="2013"&gt;1492&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;In two years, it will be &lt;span th:text="2013 + 2"&gt;1494&lt;/span&gt;.&lt;/p&gt;&lt;!-- 布尔 --&gt;&lt;!-- Thymeleaf处理 --&gt;&lt;div th:if="$&#123;user.isAdmin()&#125; == false"&gt;&lt;!-- OGNL / SpringEL引擎处理 --&gt;&lt;div th:if="$&#123;user.isAdmin() == false&#125;"&gt;&lt;!-- null --&gt;&lt;div th:if="$&#123;variable.something&#125; == null"&gt;&lt;!-- Token --&gt;// TODO 文本操作（Text operations）转义文本 与 非转义文本th:text 会转义其中的内容，而 th:utext 则不会转义，这更使用于包含标签 的文本。 1home.welcome=Welcome to our &lt;b&gt;fantastic&lt;/b&gt; grocery store! 123&lt;p th:text="#&#123;home.welcome&#125;"&gt;Welcome to our grocery store!&lt;/p&gt;&lt;!-- 解析结果如下 --&gt;&lt;p&gt;Welcome to our &amp;lt;b&amp;gt;fantastic&amp;lt;/b&amp;gt; grocery store!&lt;/p&gt; 123&lt;p th:utext="#&#123;home.welcome&#125;"&gt;Welcome to our grocery store!&lt;/p&gt;&lt;!-- 解析结果如下 --&gt;&lt;p&gt;Welcome to our &lt;b&gt;fantastic&lt;/b&gt; grocery store!&lt;/p&gt; 附加文本（Appending texts）无论是 文字 还是 评估变量 或 消息表达式的结果 ，都可以使用 + 运算符轻松附加： 1&lt;span th:text="'The name of the user is ' + $&#123;user.name&#125;"&gt; 字面替换（Literal substitutions）当需要将变量值包含到字符串中，可以使用字面替换，而不是用 + 附加文本。 1&lt;span th:text="|Welcome to our application, $&#123;user.name&#125;!|"&gt; 运算算术运算一些算术运算也可用： + ， - ， * ， / ， % 。 1&lt;div th:with="isEven=($&#123;prodStat.count&#125; % 2 == 0)"&gt; 比较运算在标签语言中需要对 &lt; 和 &gt; 进行转义，而 Thymeleaf 还支持别名。 比较运算符 别名 &gt; gt &lt; lt &gt;= ge &lt;= le ! not == eq != neq / ne 1234&lt;div th:if="$&#123;prodStat.count&#125; gt 1"&gt;&lt;!-- 等同于 --&gt;&lt;div th:if="$&#123;prodStat.count&#125; &amp;gt; 1"&gt; 条件运算属性修改器中也可以使用三目运算符： condition ? then : else 。 else 可以省略，即 condition ? then ，若条件为 false ，则返回 null值。 123&lt;tr th:class="$&#123;row.first&#125;? 'first' : 'even'"&gt; ...&lt;/tr&gt; 默认值（Elvis运算符） Elvis运算符 类似 条件运算 的变种，可以在取值为 null 时，提供默认值。 1234&lt;p&gt;Age: &lt;span th:text="&#123;age&#125;?:'(no age specified)'"&gt;27&lt;/span&gt;.&lt;/p&gt;&lt;!-- 相当于 --&gt;&lt;p&gt;Age: &lt;span th:text="&#123;age != null&#125;? &#123;age&#125; : '(no age specified)'"&gt;27&lt;/span&gt;.&lt;/p&gt; 无操作令牌 希望原文本为默认值，可以使用 _ 代替。 1234&lt;span th:text="$&#123;user.name&#125; ?: _"&gt;no user authenticated&lt;/span&gt;&lt;!-- 相当于 --&gt;&lt;span th:text="$&#123;user.name&#125; ?: 'no user authenticated'"&gt;no user authenticated&lt;/span&gt; 迭代当需要对集合进行循环遍历是可以使用 th:each 。 不显示设置迭代状态变量，则默认为 迭代变量 + Stat ，即 prodStat 。 12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 可以显示设置迭代状态变量 iterStat ，如下可以控制奇数行样式。 12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="item, iterStat : $&#123;list&#125;" th:class="$&#123;iterStat.odd&#125;? 'odd'"&gt; &lt;td th:text="$&#123;item.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;item.price&#125;"&gt;2.41&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 迭代状态变量 状态变量在 th:each 属性中定义，包含以下数据。 迭代变量属性 说明 index 当前迭代索引，从0开始。 count 当前迭代索引，从1开始。 size 迭代变量中元素的总量。 current 每次迭代的iter变量。 even / odd 当前迭代是否是偶数、奇数，布尔属性。 first 当前迭代是否是第一个迭代。 last 当前迭代是否是最后一次。 条件 注意： 条件不仅判断 布尔值，还有如下扩展。 如果value不为null，且为以下值则视为 true ，反之视为 false。 如果value是布尔值，且为true。 如果value是数字且不为零。 如果value是一个字符且不为零。 如果value是String并且不是“false”，“off”或“no”。 如果value不是布尔值，数字，字符或字符串。 如果value为null，则th：if将计算为 false 。 th:if 12&lt;a href="comments.html" th:if="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt; th:unless th:unless 意为除非，与 if 相反， 比使用 not 更加友好。 123456&lt;a href="comments.html" th:unless="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;&lt;!-- 等同于 --&gt;&lt;a href="comments.html" th:if="$&#123;not #lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt; 注释可以看出在注释方面，Thymeleaf 也具有很小的侵入性，完美融入HTML。 涉及一览 说明 &lt;!-- -- &gt; hmtl注释 &lt;!--/* */-- &gt; 解析器级注释 &lt;!--/*/ /*/-- &gt; 原型注释 标准HTML / XML注释Thymeleaf 兼容 html注释，其内容不会被解析。 1234&lt;!-- User info follows --&gt;&lt;div th:text="$&#123;...&#125;"&gt; ...&lt;/div&gt; 解析器级注释在解析的，直接删除 &lt;!--/* */-- &gt; 及其中内容。 1&lt;!--/* This code will be removed at Thymeleaf parsing time! */--&gt; 原型注释在解析完成后，删除 &lt;!--/*/ /*/-- &gt; ，释放其中内容。 12345&lt;!--/*/ &lt;div th:text="$&#123;...&#125;"&gt; ... &lt;/div&gt;/*/--&gt; 元素处理器Thymeleaf标准方言中包含了唯一的元素处理器（不是属性），即th:block。 th:block是一个纯粹的属性容器，允许模板开发人员指定他们想要的任何属性。Thymeleaf将执行这些属性，然后简单地使块，而不使它的内容消失。 因此，在创建 &lt;tr&gt; 每个元素需要多个迭代表时，它可能很有用，且当与仅原型注释块结合使用时尤其有用： 1234567891011&lt;table&gt; &lt;!--/*/ &lt;th:block th:each="user : $&#123;users&#125;"&gt; /*/--&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;!--/*/ &lt;/th:block&gt; /*/--&gt;&lt;/table&gt; 内联在 html模板中，不直接基于标签，而将 Thymeleaf 融入到到 html ，javaScript ， css 中。 涉及一览 说明 [[]] 转义表达式 [()] 非转义表达式 /*[[]]*/ 自然模板 HTML 内联表达内联 但在某些情况下我们可能更喜欢将表达式直接写入HTML文本，这是可以使用内联表达式 [[]] 或 [()] 。 注意 ：虽然看上去会更简洁，但 Thymeleaf表达式 会直接展示在静态环境中，不利于原型设计。 1234&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;&lt;!-- 等同于 --&gt;&lt;p&gt;Hello, &lt;span th:text="$&#123;session.user.name&#125;"&gt;Sebastian&lt;/span&gt;!&lt;/p&gt; 1234&lt;p&gt;Hello, [($&#123;session.user.name&#125;)]!&lt;/p&gt;&lt;!-- 等同于 --&gt;&lt;p&gt;Hello, &lt;span th:utext="$&#123;session.user.name&#125;"&gt;Sebastian&lt;/span&gt;!&lt;/p&gt; 禁用内联 可以看出 [[]] 标记会被 Thymeleaf 解析，在某些情况下并不好，这时可以使用 th:inline=&quot;none&quot; 禁用此机制。 1&lt;p th:inline="none"&gt;A double array looks like this: [[1, 2, 3], [4, 5]]!&lt;/p&gt; JavaScript 内联JavaScript内联中也支持 [[]] 和 [()] ，但都不能确保取值一定是合适的合法的 js变量 ，所以推荐使用 自然模板 ，即 /*[[]]*/ 。自然模板也支持默认值，所以对静态环境更加友好。 必须使用 th:inline=&quot;javascript&quot; 以下方式明确启用JavaScript 内联模式： 123456&lt;script th:inline="javascript"&gt; ... var username1 = /*[[$&#123;session.user.name&#125;]]*/ ; var username2 = /*[[$&#123;session.user.name&#125;]]*/ "Gertrud Kiwifruit"; ...&lt;/script&gt; CSS 内联CSS内联中同样支持 [[]] 和 [()] ，但更推荐自然模板 /*[[]]*/ 。 必须使用 th:inline=&quot;css&quot; 以下方式明确启用css内联模式： 12345&lt;style th:inline="css"&gt; .main\ elems &#123; text-align: /*[[$&#123;align&#125;]]*/ left; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Oracle之SQL中的函数与表达式]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%B5%85%E8%B0%88Oracle%E4%B9%8BSQL%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[针对 Oracle，本文会谈一谈，在 sql 中常会使用到的函数和表达式，适当的使用它们，可以提高开发效率和质量。 本文示例均使用 oracle 自带的示例表。 涉及一览 说明 CASE... WHEN... 类似于 IF/ELSE 。 WITH... AS 相当于创建临时表，适用于需要重复处理一类数据 NVL() / NVL2() NULL 处理，此时类似 IF/ELSE 。 DECODE() 值处理，此时类似 IF/ELSE 。 TRUNC() 时间截取函数。 TO_CHAR() / TO_DATE() 日期类型和字符串类型转换。 ROW_NUMBER() OVER 组内排序，并给出排序的编号。 LISTAGG(...) WITHIN GROUP(...) 列值拼接，一般配合分组使用。 START WITH...CONNECT BY PRIOR... 对树结构递归查询。 常用函数和表达式CASE... WHEN...类似于 IF/ELSE 12345678910111213141516171819-- 方式一select empno as 工号, (CASE ename WHEN 'SMITH' THEN '史密斯' WHEN 'ALLEN' THEN '艾伦' ELSE ename END) as 姓名from emp;-- 方式二select empno as 工号, (CASE WHEN ename='SMITH' THEN '史密斯' WHEN ename='ALLEN' THEN '艾伦' ELSE ename END) as 姓名from emp; WITH... AS相当于创建临时表，当需要重复处理一类数据时，可以起到优化作用。 12345678with a as (select * from emp where hiredate &gt; date'1981-01-01' and job = 'MANAGER'), b as (select * from emp where hiredate &lt; date'1981-06-01' and job = 'SALESMAN')select * from a where ename like '%A%' and ename not like '%B%'union allselect * from a where ename like '%B%' and ename not like '%A%'union allselect * from b DECODE()值处理，可以达到 IF/ELSE 的作用。 DECODE(value, if1, then1, if2,then2, . . . else ) 1234select empno as 工号, DECODE(ename, 'SMITH', '史密斯', 'ALLEN', '艾伦', ename) as 姓名from emp; NVL()NULL 处理，可以达到 IF/ELSE 的作用。 示例 说明 NVL(v1, v2) 若v1为null时，取v2, 否则取本身v1 NVL2(v1, v2, v3) 若v1为null时，取v3, 否则取v2 TRUNC()类似截取函数，按照指定的格式截取输入的数据。 12-- date 时间格式，fmt 日期格式。语法格式：trunc(date [, 'fmt']) SYSDATE ：系统时间。 示例 2018/3/19 14:31:13 结果 说明 select trunc(sysdate, &#39;dd&#39;) from dual 2018/03/20 返回当前时间：天 select trunc(sysdate, &#39;hh24&#39;) from dual 2018/3/20 14:00:00 返回当前时间：小时 select trunc(sysdate) from dual 2018/03/20 返回当前时间 select trunc(sysdate, &#39;yy&#39;) from dual 2018/01/01 返回当年第一天 select trunc(sysdate, &#39;mm&#39;) from dual 2018/03/01 返回当月的第一天 select trunc(sysdate, &#39;d&#39;) from dual 2018/03/19 返回当前信息的第一天 select trunc(sysdate, &#39;mi&#39;) from dual 2018/3/19 14:31:00 返回当前时间：分钟 TO_CHAR() / TO_DATE()这里仅说明 日期类型 和 字符串类型 的相互转换。 示例 2018/3/19 14:31:13 结果 select to_char( sysdate, &#39;YYYY-MM-DD&#39;) from dual 2018/3/19 select to_date(&#39;2018/3/19&#39;, &#39;YYYY-MM-DD&#39;) from dual 2018/3/19 12-- sql 调试时，可以直接使用以下方式。select date'2018-03-19' from dual; ROW_NUMBER() OVER12-- 将表按照a字段进行分组，之后按照b字段进行组内排序，并给出排序的编号。ROW_NUMBER() OVER (PARTITION BY a ORDER BY b) 根据工作进行分组，并按薪资进行降序排名。 123select empno,ename,job,sal, ROW_NUMBER() OVER(PARTITION BY job order by sal desc) as job_rankfrom emp 12345678910111213141516 EMPNO ENAME JOB SAL JOB_RANK---------- ---------- --------- ---------- ---------- 7902 FORD ANALYST 3000 1 7788 SCOTT ANALYST 3000 2 7934 MILLER CLERK 1300 1 7876 ADAMS CLERK 1100 2 7900 JAMES CLERK 950 3 7369 SMITH CLERK 800 4 7566 JONES MANAGER 2975 1 7698 BLAKE MANAGER 2850 2 7782 CLARK MANAGER 2450 3 7839 KING PRESIDENT 5000 1 7499 ALLEN SALESMAN 1600 1 7844 TURNER SALESMAN 1500 2 7654 MARTIN SALESMAN 1250 3 7521 WARD SALESMAN 1250 4 LISTAGG(...) WITHIN GROUP(...)列值拼接，根据 sal 排序。 123select listagg(ename, ',') within group(order by sal) as namefrom emp; 123NAME--------------------------------------------------------------------------------SMITH,JAMES,ADAMS,MARTIN,WARD,MILLER,TURNER,ALLEN,CLARK,BLAKE,JONES,FORD,SCOTT,KING 一般配合分组使用。 列举各部门的员工，并按工资排序。 12345select deptno, listagg(ename, ',') within group(order by sal) as namefrom empgroup by deptno; 12345DEPTNO NAME------- ---------------------------------------10 MILLER,CLARK,KING20 SMITH,ADAMS,JONES,FORD,SCOTT30 JAMES,MARTIN,WARD,TURNER,ALLEN,BLAKE START WITH...CONNECT BY PRIOR...对树结构的递归查询。 123456SELECT * FROM T-- 开始条件（父节点为空）START WITH p_id is null-- 连接条件：向prior跟随的节点类型方向遍历（向子节点方向递归遍历）CONNECT BY PRIOR id = p_id-- 等同 CONNECT BY p_id = PRIOR id 相关常见问题NULL问题字段处理当字段为 null 时，希望特殊处理可以使用函数： NVL() , DECODE() , CASE...WHEN... 。 排序处理当字段为 null 时，默认的排序可能不是我们希望的，此时可以特殊处理。 oracle 中默认排序时，当字段值为 null ，desc 时，null 会在最前面，asc 会在最后面。 字段处理，排除干扰 NVL() , DECODE() , CASE...WHEN... 。 nulls last / nulls first 1select * from emp order by sal desc nulls last; 日期问题时间重叠 不重叠的条件: t.endTime &lt; &#39;参数开始时间&#39; : 当前开始时间 大于 历史结束时间。 t.betginTime &gt; &#39;参数结束时间&#39; : 当前结束时间 小于 历史开始时间。 12-- 获得时间重叠的数据(验证时间是否重叠)select ... from table t where ... and not ( t.betginTime &gt; '参数结束时间' or t.endTime &lt; '参数开始时间' ) sequenceOracle 中没有自增主键，此时可以使用 sequence 代替。 123DROP SEQUENCE TAX_SEQUENCE;CREATE SEQUENCE TAX_SEQUENCE INCREMENT BY 1 START WITH 100000 MAXVALUE 100000000 MINVALUE 1 NOCYCLECACHE 20 NOORDER; 使用方式 1234-- 直接使用，可以直接在 SQL 中使用。TAX_SEQUENCE.NEXTVAL-- 间接使用，例如提供给 Java 程序。select TAX_SEQUENCE.NEXTVAL from dual]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈SpringMVC注解]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%B5%85%E8%B0%88SpringMVC%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文谈谈在 Spring MVC 中常会使用的注解。 @Controller &amp; @RequestMapping@Controller@Controller 作用于类， Controller 负责处理从 DispatcherServlet 分发的请求。 需要注意的是 @Controller 实际是 说明性注解 ，几乎等同于 @Component ，会被 Spring 识别为 bean ，需要配合 @RequestMapping 才能成为真正处理请求的处理器。 @RequestMapping@RequestMapping 注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上，作用于 Controller 类或方法。 属性 说明 value 指定请求的实际地址，指定的地址可以是 URI Template 模式。 method 指定请求的method类型， GET / POST / PUT / DELETE 等。 consumes 指定处理请求的提交内容类型（Content-Type），例如： application/json , text/html 。 produces 指定返回的内容类型，仅当 request 请求头中的( Accept )类型中包含该指定类型才返回。 params 指定 request 中必须包含某些参数值是，才让该方法处理。 headers 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。 @RequestParam &amp; @PathVariable两个都是作用于 Controller 方法参数，用于参数绑定。 注解 说明 @RequestParam 主要用于接受普通的请求参数，非必须。 @PathVariable 取出 URI 模板中的变量作为参数，主要用于处理 RESTful 风格的请求。 @RequestParam 1http://localhost:8080/Demo/list?userId=123 12345@RequestMapping(value = "/list", method = RequestMethod.GET)public String toUpload(@RequestParam String userId)&#123; model.addAttribute("userId", userId); return "upload";&#125; @PathVariable 1http://localhost:8080/Demo/list/123 12345@RequestMapping(value = "/list/&#123;userId&#125;", method = RequestMethod.GET)public String toUpload(@PathVariable String userId, Model model)&#123; model.addAttribute("userId", userId); return "upload";&#125; @RequestBody &amp; @ResponseBody 注解 说明 @RequestBody 用于 Controller 的方法参数 ，从 Request 对象的 Body 数据区中取出数据。一般用于解析字符串类型的 Json 信息。 @ResponseBody 用于 Controller 的方法 ，将返回的对象放入到 Response 对象的 Body 数据区中。使用后将不会返回页面而是数据，一般用于非 String 的对象作为 json 数据返回。 @ModelAttribute &amp; @SessionAttributes这两个注解可以实现在不同的模型（model）和控制器之间共享数据。 注解 说明 @ModelAttribute （若作用于普通方法） 若用于普通方法，该 Controller 的所有方法在调用前，先执行此方法。 @ModelAttribute （若作用于 Controller 的方法参数） 若作用于 Controller 的方法参数，进行参数绑定，类似 @RequestParam 。 @SessionAttributes 用于类上，将值放到session作用域中。]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈SpringMVC数据绑定]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%B5%85%E8%B0%88SpringMVC%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[Spring MVC 拥有强大的数据绑定数据功能 ，本文谈谈其对各种数据类型的绑定。 数据绑定 : 将请求中的字段按照 名字匹配 的原则填入模型对象中。 相关请求测试可以使用Chrome插件提交，推荐：Restlet Client 。 基本类型 &amp; 包装类型 &amp; 数组 对于这种类型的数据，直接使用 名字匹配 即可，不需要特殊处理。 基本类型 &amp; 包装类型 推荐直接使用 包装类型 代替 基本类型 。 数据类型 传递要求 类型要求 基本类型 （如 int ） 默认参数必须传，反之 HTTP Status 500 。 类型必须一致（如 int ），反之 HTTP Status 400 。 包装类型 （如 Integer ） 参数可以不传，若如此为 null 。 类型必须一致（如 int ），反之 HTTP Status 400 。 数组 推荐只作用于 基本类型 , 包装类型 , String 。 对于 基本类型 , 包装类型 , String 数组的数据绑定，和单个数据采取的 绑定方式 和 注意点 相同。 对象简单对象 / 多层级对象为了便于讲解，本文模拟使用 get 请求类型，且不进行转义（chrome 会自动转义）。 1234# 简单对象http://localhost:8080/binding/ObjectType1?username=Tom&amp;age=12# 多层级对象http://localhost:8080/binding/ObjectType1?username=Tom&amp;age=12&amp;contactInfo.phone=911 以下是 Controller 的对应方法， 其中 User类包含了同名属性。 123456/** 绑定简单对象 / 绑定多层级对象 */@RequestMapping(value = "/binding/objectType1")@ResponseBodypublic User objectType1(User user)&#123; return user;&#125; 同属性多对象因为 SpringMVC 是通过类的 setter 进行绑定的，所以当绑定多个对象且具有相同属性时，默认同属性都会被赋值，这时需要特殊处理。 1http://localhost:8080/binding/ObjectType2?user.username=Tom&amp;age=12&amp;admin.username=Jack 12345678910111213141516/** 绑定同属性多对象（User和Admin属性完全相同） */@RequestMapping(value = "/binding/objectType2")@ResponseBodypublic String objectType2(User user, Admin admin)&#123; return user.toString() + admin.toString();&#125;/** 在进入此Controller前，会先初始化此方法，完成绑定，再执行url对应方法 */@InitBinder("user")public void initUser(WebDataBinder binder) &#123; /** 将有user.前缀的属性绑定到user对象上（若没有前置，同属性都会赋值） */ binder.setFieldDefaultPrefix("user.");&#125;@InitBinder("admin")public void initAdmin(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix("admin.");&#125; List &amp; Set &amp; Map Spring 对于此类对象绑定需要使用 数据收集对象 。 List通过 数据收集对象 内的 setter 进行绑定，角标索引可确定 size 。 1http://localhost:8080/binging/listType?users[0].username=Tom&amp;users[1].username=Jack *From.java 12345678910111213141516171819public class UserListForm &#123; private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return "UserListForm&#123;" + "users=" + users + '&#125;'; &#125;&#125; *Controller.java 123456/** 绑定list */@RequestMapping(value = "/binging/listType")@ResponseBodypublic String listType(UserListForm userListForm)&#123; return userListForm.toString();&#125; Set 不推荐使用，当需要去重时，可以使用 List 接收再使用 Set 去重。 SpringMVC 对 Set 的支持不太好，不仅需要 数据收集对象 和手动初始化 Set ，还需要前后台 size 一致（自己的demo显示，重写 equals 和 hashCode 后无法添加多个元素，即使判定不同）。 Map1http://localhost:8080/binding/mapType?users[&apos;X&apos;].username=Tom&amp;users[&apos;Y&apos;].username=Jack *Form.java 12345678910111213141516171819public class UserMapForm &#123; private Map&lt;String, User&gt; users; public Map&lt;String, User&gt; getUsers() &#123; return users; &#125; public void setUsers(Map&lt;String, User&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return "UserMapForm&#123;" + "users=" + users + '&#125;'; &#125;&#125; *Controller.java 123456/** 绑定map */@RequestMapping(value = "mapType")@ResponseBodypublic String mapType(UserMapForm userMapForm)&#123; return userMapForm.toString();&#125; json绑定 json 数据需要 jackson-databind 依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt; *.json 1234567&#123; "username": "Tom", "age": 12, "contactInfo":&#123; "phone": "1234567890" &#125;&#125; *Controller.java 需要使用 @RequestBody注解 。 123456/** 绑定json */@RequestMapping(value = "jsonType")@ResponseBodypublic String jsonType(@RequestBody User user)&#123; return user.toString();&#125; xml绑定 xml 数据需要 spring-oxm 依赖。 123456&lt;!--xml数据绑定--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;4.1.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; *.xml 12345&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;people&gt; &lt;name&gt;Jim&lt;/name&gt; &lt;age&gt;16&lt;/age&gt;&lt;/people&gt; *entity.java 需要使用 @XmlRootElement 注解。 123456789101112131415161718192021222324252627282930313233/** 为xml绑定提供的实体类(注解需要JDK1.7以上支持) */@XmlRootElement(name = "people")public class People &#123; private String name; private Integer age; @XmlElement(name = "name") public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @XmlElement(name = "age") public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "People&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; *Controller.java 需要使用 @RequestBody 注解。 123456789/** * 绑定xml（推荐使用Restlet Client调试 ） * 注意People需要使用注解 */@RequestMapping(value = "xmlType")@ResponseBodypublic String xmlType(@RequestBody People people)&#123; return people.toString();&#125; Date 一般开发时，喜欢使用 String 类型接受，然后到 sql 层面进行类型转换。 123456/** 一般绑定时间类型方式 */@RequestMapping(value = "date")@ResponseBodypublic String date(@DateTimeFormat(iso = DateTimeFormat.ISO.DATE, pattern = "yyyy-MM-dd") Date date)&#123; return date.toString();&#125; 自定义类型转化器使用自定义的类型转化器可以满足 复杂多样的数据绑定 ，这里 模拟 对 2017-01-17 格式的字符串绑定到 Date 对象上。类似的还可以绑定：各种时间格式/货币格式/数据格式等。 Spring 提供了一些类型转化接口，如下： 类型转化接口 用途 说明 PropertyEditor 作用 局部 ；绑定借助 WebDataBinder 。 Spring3 前，内置的可扩展性。 Formatter 作用局部/全局；自动绑定； 参数为String 。 Spring3 后，内置的可扩展性。 Converter 作用局部/全局；自动绑定；参数为自定义。 Spring3 后，内置的不可扩展性。 Ⅰ PropertyEditor这种方式 只能作用于局部 ，需要配合 @InitBinder 使用。 1http://localhost:8888/binding/date1?date1=2017-01-17 *Controller.java 123456789101112/** 借助PropertyEditor转换数据，完成绑定 */@RequestMapping(value = "date1")@ResponseBodypublic String date1(Date date1)&#123; return date1.toString();&#125;@InitBinder("date1")public void initDate1(WebDataBinder binder)&#123; /** 将对应格式的字符串转化为Date类型(true:可以为空) */ binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true));&#125; Ⅱ Formatter这种方式 只能接受 String 参数 ，需要实现 Formatter接口 。 1http://localhost:8888/binding/date2?date2=2017-01-17 *Formatter.java 自定义格式化转换器，实现 Formatter接口 。 123456789101112/** 实现Formatter，自定义格式化转换器Demo */public class MyDateFormatter implements Formatter&lt;Date&gt; &#123; public Date parse(String text, Locale locale) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); return sdf.parse(text); &#125; public String print(Date object, Locale locale) &#123; return null; &#125;&#125; spring-web.xml 注册自定义格式化转化器。 12345678910&lt;mvc:annotation-driven conversion-service="myDateFormatter"/&gt;&lt;!--注册自定义格式化转化器--&gt;&lt;bean id="myDateFormatter" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="formatters"&gt; &lt;set&gt; &lt;bean class="org.demo.web.formatter.MyDateFormatter" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; *Controller.java 123456/** 借助Formatter转换数据，完成绑定（全局） */@RequestMapping(value = "date2")@ResponseBodypublic String date2(Date date2)&#123; return date2.toString();&#125; Ⅲ Converter这种方式可以接受自定义类型，需要实现实现 Converter接口 。 1http://localhost:8888/binding/date3?date3=2017-01-17 *Converter.java 自定义格式化转换器，实现 Converter接口 。 123456789101112/** 实现Converter，自定义格式化转换器Demo */public class MyDateConverter implements Converter&lt;String, Date&gt; &#123; public Date convert(String source) &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); try &#123; return sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; spring-web.xml 注册自定义格式化转化器。 12345678910&lt;mvc:annotation-driven conversion-service="myDateConverter"/&gt;&lt;!--注册自定义格式化转化器--&gt;&lt;bean id="myDateConverter" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="org.demo.web.converter.MyDateConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; *Controller.java 123456/** 借助Converter转换数据，完成绑定（全局） */@RequestMapping(value = "date3")@ResponseBodypublic String date3(Date date3)&#123; return date3.toString();&#125;]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Spring DI注解]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%B5%85%E8%B0%88Spring-DI%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring 在管理 Bean 时会使用到各种注解 ，本文谈谈其常会用到的注解。 以下是常用DI注解比较： DI 常用注解 说明 用途 @Autowired 自动装配，从ApplicationContext中取出 同类型 的bean装配到被注解项上。 属性 / setter / 构造器 @Qualifier 因为 @Autowired 按照类型自动装配可能存在多个bean实例，可以用 @Qualifier(&quot;beanId&quot;) 限定 id 筛选出指定的bean。 xml 中也有qualifier 标签。 配合 @AutoWired 使用，限定 id ， 但不推荐使用 ，可以直接使用 @Resource 代替。 @Resource 装配资源，默认从ApplicationContext中取出 同名 的bean装配到被注解项上。@Resource 可以通过 byName / byType 两种方式，只是一般使用默认 byName 匹配装载。 属性 / setter @Required 表示被修饰属性项，在初始化时一定要配置明确值。 setter @Required表示被修饰属性项，在初始化时一定要配置明确值。只能用于setter。 @Autowired自动装配，从ApplicationContext中取出 同类型 的bean装配到被注解项上。可以用于 属性 / setter / 构造器。 注意事项 : 当没有合适的bean时会抛异常，可以使用 @Autowired(required=false) 避免。 每个类只有一个构造器可以被标记为 required=true 。但 当有必要属性时推荐用 @Required 。 可以注解Spring众所周知的解析依赖性接口，即spring自带bean。 如 BeanFactory , Applicationcontext , Environment , ResourceLoader , ApplicationEventPublisher , MessageSource 等。 @Autowired 不能注解 BeanPostProcessor / BeanFactoryPostProcessor ，可以使用 @Bean 代替。 因为 @Autowired 为 BeanPostProcessor 处理，会产生循环依赖。 可以用来装配List/String的Map等集合，如果希望List有序，可以使用 @Order(n) 或使bean实现 Ordered 接口。 @Qualifier因为 @Autowired 按照类型自动装配可能存在多个bean实例，可以用 @Qualifier(&quot;beanId&quot;) 限定 id 筛选出指定的bean。 xml 中也有qualifier标签 。配合 @AutoWired 使用，限定 id ， 但 不推荐使用 ，可以直接使用 @Resource 代替。 和 @Component 一样，可以用作元注解，自定义限定注解。 即使不使用 @Qualifier 作注解依然可以注册自己的qualifier注解类型。 12345678&lt;bean id="customAutowireConfigurer" class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt; &lt;property name="customQualifierTypes"&gt; &lt;set&gt; &lt;value&gt;example.CustomQualifier&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; @Resource JSR-250 标准的注解，在 Java EE 5/6 通用，spring同样支持。 装配资源，默认从ApplicationContext中取出 同名 的bean装配到被注解项上。用于属性/只有一个多参数 setter 其实 @Resource 可以通过 byName / byType 两种方式，只是一般使用默认 byName 匹配装载。 注意事项 : 集合/Map类型很多都无法通过类型直接匹配， 即 @Autowired 不可使用。此时可以使用唯一名称 id 进行匹配。 使用 name 属性可以指定被注入bean的名称，默认是属性的名称或setter名称 之后，会由 ApplicationContext 中的 CommonAnnotationBeanPostProcessor 发现并处理。 当 CommonAnnotationBeanPostProcessor 在 ApplicationContext 中注册，不仅能识别 JSR-250 的 @Resource ，还支持 Spring2.5 引入的用于初始化回调/销毁回调的 @PostConstruct / @PreDestroy 。 @Bean基于java的容器注解，配置和初始化一个由SpringIoc容器管理的新对象的方法，类型于 xml 配置中的 &lt;bean&gt;&lt;/bean&gt; 。通常配合 @Configuration 使用。 以下的 java 配置 和 xml配置 等效。 12345678@Configurationpublic class AppConfig&#123; @Bean public DemoService myService()&#123; return new DemoServiceImpl(); &#125;&#125; 123&lt;beans&gt; &lt;bean id="myService" class="org.Demo.Service.MyServiceImpl"/&gt;&lt;/beans&gt; 可以使用 @Scope 注解控制作用域和代理方式。 123456789@Configurationpublic class AppConfig&#123; @Bean(name = "myService", initMethod="init", destroyMethod="cleanup") @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS) public DemoService myService()&#123; return new DemoServiceImpl(); &#125;&#125; 注意事项 : @Bean 的name默认是方法名，也可以使用 @Bean(&quot;Demo&quot;) 自定义bean名称。 可以使用 @Bean(initMethod=&quot;init&quot;) 和 @Bean(destroyMethod=&quot;cleanup&quot;) 指定初始化和销毁bean的方法（一般在return的类中定义相关方法）。 基于泛型的自动装配（//TODO） @Bean 和 @Autowired 配合可以实现泛型的自动装配。 @Inject / @Name从 Spring3.0 开始支持 JSR330 标准注解（依赖注入注解），其扫描方式与Spring注解一致。 需要以下依赖: 12345&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; @Inject @Inject 等效于 @Autowired ，可以用作类，属性，方法，构造器。 @Name 可以表示bean，和 @Component 等效。 可以限制依赖注入的bean名称，和 @Resource 等效。]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈字符编码]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%B5%85%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编程中常会遇到一些字符处理问题，这里来谈谈前后台关于字符编码的问题。 常见的字符编码种类如下： 常用字符编码 描述 补充说明 ASCII 1字节，字符范围0-127，包含26个基本拉丁字母、阿拉伯数目字和英式标点符号。 只能显示现代美国英语，即使其扩展 EASCII （字符范围0-255）也只解决了部分西欧语言的显示。 ISO-8859-1 1字节，字符范围0-255，兼容 ASCII 。 只支持欧洲语言，在其他编码的配合下可以显示中文等。 GB2312 / GBK 1-2字节，兼容 ISO-8859-1 ，一般ascii码占1字节，其他占2字节。 GB2312 支持简体字； GBK 支持简/繁体字，兼容 GB2312 。（注意：区分全角和半角） Unicode 定长2字节（也有4字节的）。 不兼容任何编码 ，但是定长编码便于计算机处理。包含所有语言的字符，但占用空间大。 UTF-8 1-6字节，一般英文占1字节，中文占3字节，包含所有语言。兼容 ISO-8859-1 。 针对 Unicode 与 ISO-8859-1 不兼容，且占用空间大的问题，产生了 UTF-8 。utf8为UTF-8的简写，只有数据库(mysql)中使用utf8，其他推荐使用UTF-8（IE可能不识别utf8）。 HTML 编码/解码（字符实体）因为HTML语言的本身特性导致一些字符需要转换为 字符实体 才可使用。这实际上是常见的 转义 操作， 和本文所要说的的 编码 并不是一件事。 在线工具：HTML编码/解码 ， 常见转义符号如下： 符号（描述） HTML转义 XHTML转义 （空格） &amp;nbsp; &amp;#160; &lt;（大于号） &amp;lt; &amp;#60; &gt; （小于号） &amp;gt; &amp;#62; &quot; （冒号） &amp;quot; &amp;#34; URL 编码/解码URL 只能使用 ASCII 字符集 来通过因特网进行发送，所以 非ASCII 需要编码才可以在URL中使用。 URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 URL 不能包含空格。URL 编码通常使用 + 来替换空格。 前端编码encodeURI() 与 encodeURIComponent() 常用方法 说明 encodeURI() 常用于URL整体编码，不会对URL保留字符进行URL转义，如 ? / ! / : 等共10个。 encodeURIComponent() 常用于参数值编码，会对URL保留字符进行URL转义。 URL 保留字符URL 具有一些保留字符，他们具有特殊含义，当传参中有保留字符，应该转义，否则可能导致异常。 URL 保留字符 说明 + 表示空格。 / 用于分隔目录或子目录。 ? 用于分隔 URL 和参数。 % 指定特殊字符。 # 表示页面中的书签。 &amp; 参数间的分隔符。 = 指定参数的值。 二次编解码问题 一般字符乱码问题，是因为 c/s 或 b/s 字符集不同造成的，所以先客户端编码，后服务端解码即可避免。但是我们会经常遇到，有时 不编解码 / 编解码 / 两次编解码 都不会出现字符乱码问题。 为了便于理解，需要知道以下信息： URL只能存在 ASCII字符 。 Tomcat的 request.getParameter(paramName) 默认是 iso-8859-1 解码。 encodeURI() 与 encodeURIComponent() 使用的是 UTF-8 编码。 UTF-8 / ISO-8859-1 / GBK 包含 ASCII 且都是相同的码值。 以下为字符 中 的二次编解码过程： 因为第一次编码后只存在 ASCII字符 ，所以第二次 UTF-8编码 等同于 iso-8859-1编码 。 12// js : 二次编码encodeURI(encodeURI(paramName)); 1234// servlet : 二次解码URLDecoder.decode(request.getParameter(paramName), "UTF-8")// struts2 : 二次解码URLDecoder.decode(URLDecoder.decode(paramName, "UTF-8"), "UTF-8"); IDE相关IDEA 中的 Reload 与 Convert一般IDE会使用其默认设置解读文件，如果IDE的字符集和文件本身的字符集不同就会出现乱码。 此时可以改变编码方式，如IDEA中会出现两种方式。 Reload : 重载，使用指定的编码方式解读文件，文件本身编码不改变。 Convert : 转变，将当前看到的内容以指定的编码方式写入到文件中，文件本身编码可能改变。]]></content>
      <categories>
        <category>知识梳理</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
        <tag>HTML</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Pages搭建个人博客]]></title>
    <url>%2F2018%2F10%2F31%2F%E4%BD%BF%E7%94%A8GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本教程基于 Mac 系统，所用指令可能不适用其他平台！ 使用 GitHub Pages + Hexo + NexT 快速搭建一个功能完善的个人博客。 准备工作 Git : 本地需要安装 git。 Github : 拥有账号，配置好 SSH keys，并了解基本操作，如：创建远程仓库等。 Node.js : Hero 和 NexT 是基于 Node.js 的，可以到Node.js官网下载，一路下一步即可。 初见成效：GitHub Pages + Hexo安装 Hexo Hexo官网教程 当 Node.js 和 Git 都安装好后 ，终端执行如下命令： 1$ sudo npm install -g hexo 是不是卡住了，没反应？😁 这就对了，好好感受天朝爸爸对你的爱 🤣 。。。 可能 npm 没法使用，需要安装 cnpm ，这是淘宝的做的镜像。 12345$ npm install -g cnpm --registry=https://registry.npm.taobao.org$ sudo cnpm install -g hexo# 查看版本$ hexo -v 初始化 Hexo创建一个文件夹（如 hexo），作为站点根目录，用于存放 Hexo 等配置文件。 1234$ cd hexo$ hexo init$ hexo install 以下为 Hexo 默认目录结构： 12345678910111213.├── README.md├── _config.yml # 站点配置文件├── db.json ├── .deploy # hexo d 生成，部署到GitHub上的内容目录├── node_modules ├── package.json # hexo参数和所依赖插件├── public # hexo g 生成，输出的静态网页内容目录├── scaffolds # layout模板文件目录，其中的md文件可以编辑├── source # 文章源码目录，该目录下的markdown可以被hexo解析│ ├── _drafts # 草稿文章，不会发布，可使用以下命令生成：hexo new draft "草稿名"│ ├── _posts # 发布文章└── themes # 主题文件目录 启动 Hero 服务器 可以缩写成 $ hexo s 1$ hexo server 如果一起顺利，可以在 http://localhost:4000 看到启动页面。 这就是当前博客的面貌，使用的是 Hexo 的默认主题，只是还在本地。 将 Hexo 部署到 GitHub Pages创建 GitHub Pages 仓库，即在 GitHub 上创建一个普通仓库，但是要符合以下命名规则： 用户名.github.io 。 该仓库地址为：https://github.com/用户名/用户名.github.io.git 修改 站点配置文件 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件 ， 后者称为 主题配置文件 。 123$ cd hexo$ vim _config.yml 修改 repository 仓库位置： 注意 : 号后面要加空格 。 1234deploy: type: git repository: https://github.com/用户名/用户名.github.io.git branch: master 生成网站静态页面 可以缩写成 $ hexo g 1$ hexo generate 123456若出现如下报错：ERROR Local hexo not found in ~/hexoERROR Try runing: &apos;npm install hexo --save&apos;则执行命令：$ cnpm install hexo --save若无报错，自行忽略此步骤。 把网站部署到 GitHub 可以缩写成 $ hexo d 1$ hexo deploy 1234若报错：无法连接git或找不到git则执行命令：$ cnpm install hexo-deployer-git --save若无报错，自行忽略此步骤。 如果一切顺利，一般需要等待3分钟，就可以在 https://用户名.github.io 看到和之前所见的博客页面了。 这表明你的博客网站已经发布成功，之前的仓库 用户名.github.io 也更新了，就是之前生成的静态网页， 不包含你的MarkDown源文件 。 安装主题 NexT 安装 NexT 能美化 Hexo ，而且其还提供了很多插件，完善博客功能。 细节请参考： NexT官网 下载主题123$ cd hexo# 将 next 克隆到 hexo/themes/next 目录git clone https://github.com/iissnan/hexo-theme-next themes/next 以下为 NexT 默认目录结构： 12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 启动主题 修改 站点配置文件 ，修改 theme 字段。 1theme: next 验证主题 启动 Hexo 本地站点，并开启调试模式，可以看到异常信息。 1$ hexo s --debug Blog 流程 Hexo 安装成功后，就可以发布博客了。发布流程如下： 可以不使用指令，直接 删除 和 新建 文件。 123456789101112# 创建文章，会在 hexo/source/_posts 新建 md 文件$ hexo new "文章名字"# 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo clean# 生成缓存和静态文件$ hexo g# 启动 Hexo 本地站点，预览效果。$ hexo s# 重新部署到服务器，将文章发布到 GitHub$ hexo d 站点文件管理完成以上步骤后，还会存在以下问题： 站点开发环境只存在本地，不利于随时管理站点。 实际发布的是 md 被转变后的 html 文件，md 源文件没有被有效保管。 🤣喜大普奔， 2019.01.07 ，GitHub 已提供免费私有仓库，站点文件放到私有仓库就好！！！ 创建分支管理对于以上问题，可以在 GitHub Pages 仓库创建了一个分支，来保管站点环境，其也就包含了 md 源文件。具体操作 ，如下： 1234567# 克隆 GitHub Pages 仓库$ git clone git@github.com:用户名/用户名.github.io.git# 查看当前分支$ git branch# 创建 并 切换 到分支 config$ git checkout -b config 清空文件夹(仅保留.git)，将 hexo 文件内所有文件 拷贝到 其中 。 因为 next 也是个 git 仓库，需要手动删除其 .git 目录，或者根据提示操作。 1234# 将 git 仓库变动保存，并 push 到 远程仓库分支 config$ git add .$ git commit -m "GitHub Pages 站点环境"$ git push origin config 登录 GitHub，将 默认分支 切换为 config ，以后 git push 会直接推送到 config 分支。 实际上， master分支 存放的是站点的静态文件，其都是由 Hexo 自动生成的，所以 master分支 对我们而言没有太大意义，以后再也不用切换到 master分支 了。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站日志]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[2019-04-05 图片预览: fancybox3 延迟加载: lazyload 2019-03-08 添加实时在线聊天 : DaoVoice 。 搜索功能切换 : Algolia Search -&gt; Local Search 。 开启版权声明。 2019-03-03 升级 NexT : 5.1.4 -&gt; 7.0.1 自定义样式迁移: highlight.styl , theme.styl post-details.js , algolia-search.styl 等。 添加 v6+ 移除和变更的插件 : 进度条: theme-next-pace 动画: theme-next-canvas-nest 字数统计: hexo-symbols-count-time Hexo 添加萌萌哒😁 : live2d hexo-helper-live2d live2d模型: live2d-widget-models 模型预览 标签样式修改 文章标签样式修改（ custom.styl ）。 文章摘要添加标签（ post.swig , custom.styl ）。 2019-02-13 修改 MakeDown 语法渲染样式。 调整 code 过小（ highlight.styl ）。 调整 td 等宽的不当样式（ tables.styl ）。 自定义语法高亮样式（ theme.styl ）。 去除修改文章后，文章目录的新增加标识（ post-details.js ）。 2019-02-02🤣由于将站点环境分离等，导致所有站点提交记录丢失，所以感觉有必要记录站点发展。 以下为丢失的站点提交记录概要，包括但不限于： 根据 官方文档 定制了 NexT 配置文件。 启动 algolia-search插件，并修改搜索列表不显示分页的 bug（algolia-search.styl）。 2018-10-30基于 GitHub Pages + Hexo + NexT 搭建博客。 NexT 为 5.1.4版本。 NexT官方 NexT仓库]]></content>
  </entry>
</search>
