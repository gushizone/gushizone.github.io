<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈SpringMVC之数据校验]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%B5%85%E8%B0%88SpringMVC%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[在 浅谈SpringMVC之数据绑定 已经介绍了如何获取数据，本文就来介绍一下 SpringMVC 中如何对数据进行校验。 认识 Validation自 Spring3.0 开始，SpringMVC 提供了对 Java校验API ( Java Validation API , 又称 JSR-303 ) 的支持，JSR303 是一个标准， 一般会使用它的实现，如 hibernate-validator 。 BTW : 当前已更新至 JSR380 。 若使用springboot ，则 spring-boot-starter-web 已包含，本文部分基于 springboot，存在差异（ 6.0+ 后包结构改变）。 123456&lt;!-- hibernate-validator (自动依赖 validation-api) --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.1.1.Final&lt;/version&gt;&lt;/dependency&gt; 校验注解这里介绍一下 javax.validation.constraints 所定义的常用注解，来自 validation-api ，它的实现在 hibernate-validator 下 org.hibernate.validator.internal.constraintvalidators.bv 。 hibernate-validator 下依然存在许多未过时的校验注解，这里不会介绍。 javax.validation 常用注解 说明 @AssertFalse 限制必须为false。 @AssertTrue 限制必须为true。 @DecimalMax(value) 限制必须为一个不大于指定值的数字。 @DecimalMin(value) 限制必须为一个不小于指定值的数字。 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction。 @Future 限制必须是一个将来的日期。 @Max(value) 限制必须为一个不大于指定值的数字。 @Min(value) 限制必须为一个不小于指定值的数字。 @NotBlank 验证注解的元素值不为空（不为null且去除首尾空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格。 @NotEmpty 验证注解的元素值不为 null 且不为空（字符串长度不为0、集合大小不为0）。 @NotNull 限制必须不为 null 。 @Null 限制只能为 null 。 @Size(max,min) 限制字符长度必须在 min 到 max 之间。 @Valid 与 @Validated一般校验注解会作用于 pojo类，而使用 @Valid 或 @Validated 可以通知 Spring 进行校验,，校验结果会被保存到 BindingResult 中。具体区别如下： 触发校验注解 提供者 说明 @Valid validation-api 标记用于验证级联的属性，方法参数或方法返回类型，并且递归应用。符合 JSR303 。 @Validated spring-context 对 @Valid 的特殊扩展，支持验证组 。支持 JSR303 ，特殊除外。 使用 Validation简单示例pojo.java 12345678910111213141516import javax.validation.constraints.NotEmpty;...public class SysUser &#123; @NotEmpty(message = "用户名不能为空!") private String username; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125;&#125; *Controller.java 在 Spring 中使用 @Valid 或 @Validated ，校验结果信息会被保存到 BindingResult 中。 12345678910111213141516171819202122import org.springframework.validation.annotation.Validated;import org.springframework.validation.BindingResult;..@Controller@RequestMapping("/validation")public class DemoValidationController &#123; @RequestMapping(value = "/check") @ResponseBody public String save(@Validated SysUser sysUser, BindingResult bindingResult) &#123; if (bindingResult.hasErrors())&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (FieldError error : bindingResult.getFieldErrors()) &#123; map.put(error.getField(), error.getDefaultMessage()); &#125; return map.toString(); &#125; return "OK"; &#125;&#125; 相关提示默认会做国际化兼容，自定义信息需要自己提供。 1&#123;username=用户名不能为空!&#125; BindingResult除了可以获取验证结果，还可以通过 BindingResult 直接注册错误。 123456789101112131415161718@RequestMapping(value = "/check")@ResponseBodypublic String save(@Validated SysUser sysUser, BindingResult bindingResult) &#123; if (!"admin".equals(sysUser.getUsername()) &amp;&amp; sysUser.getAge().compareTo(18) &lt; 0) &#123; bindingResult.rejectValue("age", "nonage", "未成年！"); &#125; if (bindingResult.hasErrors())&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (FieldError error : bindingResult.getFieldErrors()) &#123; map.put(error.getField(), error.getDefaultMessage()); &#125; return map.toString(); &#125; return "OK";&#125; @Validated@Validated是 Spring 对 @Valid 的特殊扩展，支持验证组 。如果有多个校验公用一个 POJO ，可以通过校验组进行区分。 定义校验组校验组接收 Class类 ，这里以接口为例，利于扩展。 1234// 编辑校验组public interface ValidateGroupEdit &#123;&#125;// 删除校验组public interface ValidateGroupDelete &#123;&#125; 使用校验组pojo.java pojo 同时用于编辑校验和删除校验。 1234567891011121314151617181920212223242526272829303132package org.demo.web.entity;import org.demo.web.validation.constraints.Length;import org.demo.web.validation.groups.ValidateGroupDelete;import org.demo.web.validation.groups.ValidateGroupEdit;import org.hibernate.validator.constraints.NotEmpty;public class SysUser &#123; @NotEmpty(message = "用户名不能为空!", groups = &#123;ValidateGroupEdit.class, ValidateGroupDelete.class&#125;) private String username; @NotEmpty(message = "年龄不能为空!", groups = ValidateGroupEdit.class) private Integer age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; *Controller.java 校验时只使用删除校验组。 12345678910111213@RequestMapping(value = "/check")@ResponseBodypublic String save(@Validated(ValidateGroupDelete.class) SysUser sysUser, BindingResult bindingResult) &#123; if (bindingResult.hasErrors())&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (FieldError error : bindingResult.getFieldErrors()) &#123; map.put(error.getField(), error.getDefaultMessage()); &#125; return map.toString(); &#125; return "OK";&#125; 测试和结果 1http://localhost:8080/validation/check 1&#123;username=用户名不能为空!&#125; 自定义 Validation我们也可以自定义校验规则来满足复杂需求，只需要定义一个校验注解并实现对应的校验实现逻辑类。这里通过一个简单示例来演示一下。 自定义校验注解校验注解 除了要满足普通注解的要求外，还需要满足以下条件： 使用 @Constraint 来指定校验逻辑类。（也有其他方式，但这种方式最简单直接。） 必须包含 groups() 和 payload() 。 123456789101112131415161718192021222324252627282930package tk.gushizone.framework.validation.constraints;import tk.gushizone.framework.validation.validator.LengthValidator;import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)@Constraint(validatedBy = &#123;LengthValidator.class&#125;)public @interface Length &#123; String fieldName() default ""; int min() default 0; int max() default 20; int length() default 0; String message() default "lengthCheck不通过！"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 实现校验逻辑类校验逻辑实现类需要实现 ConstraintValidator 接口。 12345678910111213141516171819202122232425262728293031323334353637383940package tk.gushizone.framework.validation.validator;import tk.gushizone.framework.validation.constraints.Length;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;public class LengthValidator implements ConstraintValidator&lt;Length, Object&gt; &#123; private String message; private int min; private int max; private int length; @Override public void initialize(Length constraintAnnotation) &#123; int max = constraintAnnotation.max(); int min = constraintAnnotation.min(); int length = constraintAnnotation.length(); if (min &gt; 0) &#123; this.min = min; &#125; if (max &gt; 0) &#123; this.max = max; &#125; &#125; @Override public boolean isValid(Object value, ConstraintValidatorContext context) &#123; if (value == null) &#123; return true; &#125; int strLength = value.toString().length(); return strLength &gt;= min &amp;&amp; strLength &lt;= max; &#125;&#125;]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>Java</tag>
        <tag>Java Validation API</tag>
        <tag>JSR-303</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok: 代码简洁之道]]></title>
    <url>%2F2019%2F07%2F28%2FLombok-%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[在日常开发中，我们常常需要重写 getter / setter , toString , equals / hashCode 等，虽然现在 IDE 都支持 generate , 但是字段变更后还需要再修改，最重要的是：重复而繁琐的代码会影响关键代码的可读性。本文就介绍 Lombok 开发插件，使用注解来有效的简化代码。 认识 LombokLombok 是一个Java 库，可以通过注解的方式简化代码，如 getter , equals 或日志变量等。 Lombok 非常适用于 pojo 等对象。 工作原理Lombok 本质上是实现 JSR 269 API 的程序，自 JDK6 后就被 javac 支持，其可以在 javac 时动态修改语法树，产生真实所需字节码文件。 由此可知，在编译后，我们真实所需的代码就会产生，这种工作方式不同与 反射 ， Lombok 不会影响程序性能 。 利用 javap 可以验证 Lombok 的工作原理。使用 jd-GUI 等工具可以查看详细内容。 123456789101112package tk.gushizone.lombok.getter;import lombok.Getter;@Getterpublic class Item &#123; private Integer id; private String name;&#125; 1234567891011121314151617181920Compiled from "Item.java"public class tk.gushizone.lombok.getter.Item &#123; public tk.gushizone.lombok.getter.Item(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public java.lang.Integer getId(); Code: 0: aload_0 1: getfield #2 // Field id:Ljava/lang/Integer; 4: areturn public java.lang.String getName(); Code: 0: aload_0 1: getfield #3 // Field name:Ljava/lang/String; 4: areturn&#125; 常用注解 常用注解 说明 @Getter / @Setter 作用于 类 或 字段 ，在类上，为所有字段生成，在字段上则只单独生成。 @ToString 作用于 类 ，生成 toString 方法。 @EqualsAndHashCode 作用于 类 ，生成 hashCode 和 equals 。 @NoArgsConstructor 作用于 类 ，生成无参的构造方法。 @RequiredArgsConstructor 作用于 类 ，为必需参数生成构造方法，比如 final 和被 @NonNull 注解的字段。 @AllArgsConstructor 作用于 类 ，生成包含类中所有字段的构造方法。 @Data 作用于 类 ，包含 : @Getter , @Setter , @RequiredArgsConstructor , @ToString , @EqualsAndHashCode 。 @Slf4j 作用于 类 ，生成日志常量 log ，基于 logback 。对应的还有 @Log4j 等注解。 使用 Lombok必需条件引用依赖 123456&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt;&lt;/dependency&gt; Lombok插件 由工作原理可知， Lombok 是是编译后才会产生对应的方法，而这些方法会在开发中（编译前）被使用，这不会被 IDE等 直接支持，需要插件支持。 获取插件 : Lombok官网 。 通用示例 123456789101112131415161718package tk.gushizone.lombok.common;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class Item &#123; private Integer id; private String name;&#125; @Getter / @Setter@Getter / @Setter 可以作用于 类 或 字段 ，在类上，为所有字段生成，在字段上则只单独生成。 通过 value() 可以控制访问级别，默认为 public 。 123456789101112@Setter(AccessLevel.PROTECTED)public class Item &#123; @Getter private Integer id; @Getter private String name; private String password;&#125; @ToString@ToString 作用于 类 ，自动生成 toString 方法。 使用 exclude 可以指定排除字段。 使用 of 可以指定包含字段。 12345678910@ToString(exclude = "password")public class Item &#123; private Integer id; private String name; private String password;&#125; @EqualsAndHashCode@EqualsAndHashCode 作用于 类 ，自动生成 hashCode 和 equals 。适用于简单的生成。 使用 exclude 可以指定排除字段。 使用 of 可以指定包含字段。 12345678910@EqualsAndHashCode(of="id")public class Item &#123; private Integer id; private String name; private String password;&#125; ConstructorLombok 提供了构造器相关的注解 : @NoArgsConstructor : 无参构造。 @AllArgsConstructor : 全参构造。 @RequiredArgsConstructor : 必需参数构造。 @RequiredArgsConstructor 会自动为 @NonNull 或 final 相关的特殊字段构造器。 12345678910111213@NoArgsConstructor@AllArgsConstructor@RequiredArgsConstructorpublic class Item &#123; @NonNull private Integer id; private String name; private String password;&#125; @Data@Data 作用于 类 ，包含 : @Getter , @Setter , @RequiredArgsConstructor , @ToString , @EqualsAndHashCode 。 1234567891011121314package tk.gushizone.lombok.data;import lombok.Data;import lombok.NonNull;@Datapublic class Item &#123; @NonNull private Integer id; private String name;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package tk.gushizone.lombok.data;import lombok.NonNull;public class Item &#123; @NonNull private Integer id; private String name; public Item(@NonNull Integer id) &#123; if (id == null) &#123; throw new NullPointerException("id is marked @NonNull but is null"); &#125; else &#123; this.id = id; &#125; &#125; @NonNull public Integer getId() &#123; return this.id; &#125; public String getName() &#123; return this.name; &#125; public void setId(@NonNull Integer id) &#123; if (id == null) &#123; throw new NullPointerException("id is marked @NonNull but is null"); &#125; else &#123; this.id = id; &#125; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean equals(Object o) &#123; if (o == this) &#123; return true; &#125; else if (!(o instanceof Item)) &#123; return false; &#125; else &#123; Item other = (Item)o; if (!other.canEqual(this)) &#123; return false; &#125; else &#123; Object this$id = this.getId(); Object other$id = other.getId(); if (this$id == null) &#123; if (other$id != null) &#123; return false; &#125; &#125; else if (!this$id.equals(other$id)) &#123; return false; &#125; Object this$name = this.getName(); Object other$name = other.getName(); if (this$name == null) &#123; if (other$name != null) &#123; return false; &#125; &#125; else if (!this$name.equals(other$name)) &#123; return false; &#125; return true; &#125; &#125; &#125; protected boolean canEqual(Object other) &#123; return other instanceof Item; &#125; public int hashCode() &#123; int PRIME = true; int result = 1; Object $id = this.getId(); int result = result * 59 + ($id == null ? 43 : $id.hashCode()); Object $name = this.getName(); result = result * 59 + ($name == null ? 43 : $name.hashCode()); return result; &#125; public String toString() &#123; return "Item(id=" + this.getId() + ", name=" + this.getName() + ")"; &#125;&#125; @Slf4j@Slf4j 作用于 类 ，自动生成日志常量 log ，基于 logback 。对应的还有 @Log4j 等注解。 1234567891011package tk.gushizone.lombok.sl4j;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ItemService &#123; public static void main(String[] args) &#123; log.info("需要另外配置logback相关依赖。"); &#125;&#125; 123456789101112131415package tk.gushizone.lombok.sl4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ItemService &#123; private static final Logger log = LoggerFactory.getLogger(ItemService.class); public ItemService() &#123; &#125; public static void main(String[] args) &#123; log.info("需要另外配置sl4j相关依赖。"); &#125;&#125; @Builer@Builder 可以提供构造器模式 API 。 1234567891011package pojo;import lombok.Builder;@Builderpublic class Item &#123; private Integer id; private String name;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package pojo;public class Item &#123; private Integer id; private String name; Item(Integer id, String name) &#123; this.id = id; this.name = name; &#125; public static Item.ItemBuilder builder() &#123; return new Item.ItemBuilder(); &#125; public static class ItemBuilder &#123; private Integer id; private String name; ItemBuilder() &#123; &#125; public Item.ItemBuilder id(Integer id) &#123; this.id = id; return this; &#125; public Item.ItemBuilder name(String name) &#123; this.name = name; return this; &#125; public Item build() &#123; return new Item(this.id, this.name); &#125; public String toString() &#123; return "Item.ItemBuilder(id=" + this.id + ", name=" + this.name + ")"; &#125; &#125;&#125; 当 pojo 继承基类时，@Builder需要作用于全参构造器上，才能构造父类属性。 1234567891011121314package tk.gushizone.lombok.builder;import lombok.Builder;public class DataItem extends BaseItem&#123; private String name; @Builder public DataItem(Integer id, String name) &#123; super(id); this.name = name; &#125;&#125; 123456789101112131415161718192021package tk.gushizone.lombok.builder;public class BaseItem &#123; private Integer id; public BaseItem() &#123; &#125; public BaseItem(Integer id) &#123; this.id = id; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125;&#125;]]></content>
      <categories>
        <category>③ 奇技淫巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lombok</tag>
        <tag>JSR-269</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java眼中的XML]]></title>
    <url>%2F2019%2F07%2F01%2FJava%E7%9C%BC%E4%B8%AD%E7%9A%84XML%2F</url>
    <content type="text"><![CDATA[XML 因为具有良好的数据描述能力和跨平台性，被广泛应用于数据存储和交换等，比如用作配置文件等。 在日常开发中，我们可能也需要处理 XML数据。这里就来介绍几种在 Java 中常见的对 XML 的处理方法。 使用建议: 推荐直接使用 Dom4j ，若追求性能可尝试 SAX 。 DOM 和 SAX 是 Java 提供的基础的处理方法，属于 JAXP ， JDom 和 Dom4j 是建立其上的第三方库。 涉及 说明 优劣 DOM 基于 dom树 的处理方式，与平台无关解析方式，遵循 w3c 标准 。 以树结构处理数据，操作方便。内存一次性加载 DOM树，不利于大数据量的处理。 SAX 基于事件驱动的处理方式。 边读边处理，内存占用小，解析速度快，因为逐行解析不利于随机访问和操作。 JDom 仅使用具体类而不使用接口，API 大量使用 Collection 类。 提供的 API 非常利于编码，但性能较弱，存在内存溢出风险。 Dom4j 起源自 JDom 。使用接口和抽象基础类方法。优秀而强大的 API 。 易用性和性能兼顾的 API ，成为了许多开源框架的标配处理方式。 性能对比 123解析耗时：JDom &gt; DOM &gt; Dom4j &gt;&gt; SAX生成耗时: DOM &gt; JDom &gt; Dom4j &gt;&gt; SAX 认识 XMLXML (可扩展标记语言) ，一种通用的数据交换格式，由众多节点标签组成，总体呈树结构，可以有效的描述复杂的数据结构。 XML 常见节点类型 说明 document 文档对象模型 element 标签元素 attribute 属性 本文会以此 XML 为例，介绍相关功能的简单使用。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;transaction&gt; &lt;object id=&quot;1&quot;&gt; &lt;name&gt;Neo&lt;/name&gt; &lt;year&gt;1999&lt;/year&gt; &lt;/object&gt; &lt;object id=&quot;2&quot;&gt; &lt;name&gt;NEO&lt;/name&gt; &lt;year&gt;2199&lt;/year&gt; &lt;/object&gt;&lt;/transaction&gt; DOMDOM 会一次性加载将整个 XML，并将其视为dom树 ，树由节点构成。 标签、标签之间的间隔内容、属性等都被视为节点 。 节点类型 nodeType nodeName nodeValue Element Node.ELEMENT_NODE 元素名 null Attr Node.ATTRIBUTE_NODE 属性名 属性值 Text Node.TEXT_NODE #text 节点内容 解析1234567891011121314151617181920212223242526272829303132333435363738@Testpublic void domReader() throws ParserConfigurationException, IOException, SAXException &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); // 解析文件 Document document = db.parse(inputStream); // 元素节点：通过节点名获取 NodeList nodeList = document.getElementsByTagName("object"); for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; Node node = nodeList.item(i); // 属性：获取所有属性 NamedNodeMap attrs = node.getAttributes(); for (int j = 0; j &lt; attrs.getLength() ; j++) &#123; // 属性本身也是节点 String attrName = attrs.item(j).getNodeName(); // id String attrValue = attrs.item(j).getNodeValue(); // 1 &#125; // 属性：通过属性名获取（有且仅有一个） Element element = (Element) nodeList.item(i); String attrValue = element.getAttribute("id"); // 1 // 节点：子节点 NodeList childNodes = node.getChildNodes(); // length : 5 for (int j = 0; j &lt; childNodes.getLength(); j++) &#123; String nodeName = childNodes.item(j).getNodeName(); // 过滤出元素节点（标签和标签之间的间隔都被视为节点） if (childNodes.item(j).getNodeType() == Node.ELEMENT_NODE) &#123; String no_nodeValue = childNodes.item(j).getNodeValue(); // null String nodeValue = childNodes.item(j).getFirstChild().getNodeValue(); // Neo // 会包含子节点文本内容 String nodeText = childNodes.item(j).getTextContent(); // Neo &#125; &#125; &#125;&#125; 生成123456789101112131415161718192021222324252627282930313233@Testpublic void domWriter() throws ParserConfigurationException, TransformerException &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document document = db.newDocument(); // FIXME 去除 standalone ，但是会造成不换行 document.setXmlStandalone(true); Element rootNode = document.createElement("transaction"); // 创建节点 Element objectNode = document.createElement("object"); // 设置属性 objectNode.setAttribute("id", "1"); Element nameNode = document.createElement("name"); // 设置节点值 nameNode.setTextContent("Neo"); Element yearNode = document.createElement("year"); yearNode.setTextContent("1999"); // 追加节点 objectNode.appendChild(nameNode); objectNode.appendChild(yearNode); rootNode.appendChild(objectNode); document.appendChild(rootNode); TransformerFactory transformerFactory = TransformerFactory.newInstance(); Transformer transformer = transformerFactory.newTransformer(); // 设置输出属性: 换行 transformer.setOutputProperty(OutputKeys.INDENT, "yes"); // 输出文件 transformer.transform(new DOMSource(document), new StreamResult(new File("domTest.xml")));&#125; domTest.xml 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;transaction&gt;&lt;object id="001"&gt;&lt;name&gt;Neo&lt;/name&gt;&lt;year&gt;1999&lt;/year&gt;&lt;/object&gt;&lt;/transaction&gt; SAXSAX 使用 Hander 边解析边处理，在对应位置会触发执行对应方法。 Handler 常用方法 说明 startDocument() 文档开始时触发。 endDocument() 文档结束时触发。 startElement(String uri, String localName, String qName, Attributes attributes) 元素节点开始时触发。 endElement(String uri, String localName, String qName) 元素节点结束时触发。 characters(char[] ch, int start, int length) 可以接收元素内字符数据的方法。 解析12345678@Testpublic void saxReader() throws ParserConfigurationException, SAXException, IOException &#123; SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser saxParser = factory.newSAXParser(); // 自定义一个 Handler SaxParserHandler handler = new SaxParserHandler(); saxParser.parse(inputStream, handler);&#125; ParserHandler自定义一个 Handler 用于解析处理 ，需要继承 org.xml.sax.helpers.DefaultHandler 。 characters() 可以拿到节点值，但需要注意： 和 DOM 一样 空白也被识别为节点。 因为 SAX 会将 dom 分块解析 （默认2k），所以直接获取的节点值不一定是完整的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class SaxParserHandler extends DefaultHandler &#123; /** * 记录当前节点元素名 */ private String currentNode; private StringBuilder sb = new StringBuilder(); /** * 解析Dom开始 * @throws SAXException */ @Override public void startDocument() throws SAXException &#123; super.startDocument(); &#125; /** * 解析Dom结束 * @throws SAXException */ @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125; /** * 解析标签开始 * @param uri * @param localName * @param qName 便签名 * @param attributes 属性集合 * @throws SAXException */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; super.startElement(uri, localName, qName, attributes); currentNode = qName; if ("object".equals(qName))&#123; // 属性：通过属性名获取 String attrValue = attributes.getValue("id"); // 1 // 属性：遍历，通过索引获取 for (int i = 0; i &lt; attributes.getLength(); i++) &#123; String attrName = attributes.getQName(i); // id String attrVlaue = attributes.getValue(i); // 1 &#125; &#125; &#125; /** * 解析标签结束 * @param uri * @param localName * @param qName * @throws SAXException */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; super.endElement(uri, localName, qName); if (StringUtils.isNotEmpty(currentNode))&#123; System.out.println(currentNode + ":" + sb.toString()); // name:NEO &#125; currentNode = ""; sb.delete( 0, sb.length()); &#125; /** * 获取节点值 （和 DOM 一样 空白也被识别为节点） * @param ch dom块内容 , 默认2k * @param start * @param length * @throws SAXException */ @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; super.characters(ch, start, length); // FIXME 由于 SAX 分块解析，直接获取的可能不完整 String value = new String(ch, start, length); // Neo （理想状态） if (StringUtils.isNotEmpty(currentNode) &amp;&amp; StringUtils.isNotEmpty(value.trim()))&#123; sb.append(value); &#125; &#125;&#125; 生成12345678910111213141516171819202122232425262728293031@Testpublic void saxWriter() throws TransformerConfigurationException, SAXException &#123; SAXTransformerFactory factory = (SAXTransformerFactory) SAXTransformerFactory.newInstance(); TransformerHandler handler = factory.newTransformerHandler(); // 输出设置 （编码，换行） Transformer transformer = handler.getTransformer(); transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8"); transformer.setOutputProperty(OutputKeys.INDENT, "yes"); Result result = new StreamResult(new File("saxTest.xml")); // FIXME 配置需要在此之前 handler.setResult(result); // start 必须在 setResult 之后 handler.startDocument(); AttributesImpl attr = new AttributesImpl(); attr.addAttribute("", "", "id", "", "1"); handler.startElement("", "", "transaction", attr); attr.clear(); handler.startElement("", "", "name", attr); handler.characters("Neo".toCharArray(), 0, "abc".length()); handler.endElement("", "", "name"); handler.startElement("", "", "year", null); handler.characters("1999".toCharArray(), 0, "1999".length()); handler.endElement("", "", "year"); handler.endElement("", "", "transaction"); handler.endDocument();&#125; saxTest.xml 1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;transaction id="1"&gt;&lt;name&gt;Neo&lt;/name&gt;&lt;year&gt;1999&lt;/year&gt;&lt;/transaction&gt; JDomJDom 的 API 使用集合来存储节点信息，操作起来十分便利。 添加 jdom 依赖，如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.jdom&lt;/groupId&gt; &lt;artifactId&gt;jdom2&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt; 解析123456789101112131415161718192021222324252627282930@Testpublic void jDomReader() throws IOException, JDOMException &#123; SAXBuilder saxBuilder = new SAXBuilder(); Document document = saxBuilder.build(new InputStreamReader(inputStream, "UTF-8")); // 根节点 Element rootElement = document.getRootElement(); // 子节点 List&lt;Element&gt; elementList = rootElement.getChildren(); for (Element element : elementList) &#123; // 获取元素索引位 int index = elementList.indexOf(element); // 属性：遍历 List&lt;Attribute&gt; attrs = element.getAttributes(); for (Attribute attr : attrs) &#123; attr.getName(); // id attr.getValue(); // 1 &#125; // 属性：通过属性名获取 String attrValue = element.getAttributeValue("id"); // 1 // 元素 List&lt;Element&gt; childElements = element.getChildren(); for (Element childElement : childElements) &#123; childElement.getName(); // name childElement.getValue(); // Neo &#125; &#125;&#125; 生成1234567891011121314151617181920212223242526@Testpublic void jDomWriter() throws IOException &#123; Element rootNode = new Element("transaction"); Element objectNode = new Element("object"); objectNode.setAttribute("id", "1"); Element nameNode = new Element("name"); nameNode.setText("Neo"); objectNode.addContent(nameNode); Element yearNode = new Element("year"); yearNode.setText("1999"); objectNode.addContent(yearNode); rootNode.addContent(objectNode); Document document = new Document(rootNode); // 设置输出格式（换行缩进，字符） Format format = Format.getCompactFormat(); format.setIndent(" "); format.setEncoding("UTF-8"); XMLOutputter outputter = new XMLOutputter(format); outputter.output(document, new FileOutputStream(new File("jDomTest.xml")));&#125; jDomTest.xml 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;transaction&gt; &lt;object id="1"&gt; &lt;name&gt;Neo&lt;/name&gt; &lt;year&gt;1999&lt;/year&gt; &lt;/object&gt;&lt;/transaction&gt; Dom4jDom4j 中需要通过迭代器来遍历相关信息。 添加 dom4j 依赖，如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 解析1234567891011121314151617181920212223242526272829303132@Testpublic void dom4jReader() throws DocumentException &#123; SAXReader reader = new SAXReader(); Document document = reader.read(inputStream); // 根节点 Element rootElement = document.getRootElement(); // 子节点 (此处效果等同以下) Iterator&lt;Element&gt; iterator = rootElement.elementIterator(); // 元素：通过元素名获取 Iterator&lt;Element&gt; object = rootElement.elementIterator("object"); while (object.hasNext()) &#123; Element element = object.next(); // 属性：遍历 List&lt;Attribute&gt; attrList = element.attributes(); for (Attribute attribute : attrList) &#123; attribute.getName(); // id attribute.getValue(); // 1 &#125; // 属性：通过属性名获取 element.attributeValue("id"); // 1 // 元素：遍历 Iterator&lt;Element&gt; childIter = element.elementIterator(); while (childIter.hasNext()) &#123; Element childElement = childIter.next(); childElement.getName(); // name childElement.getStringValue(); // Neo &#125; &#125;&#125; 生成123456789101112131415161718192021222324252627@Testpublic void dom4jWriter() &#123; Document document = DocumentHelper.createDocument(); Element rootNode = document.addElement("transaction"); Element objectNode = rootNode.addElement("object"); objectNode.addAttribute("id", "1"); Element nameNode = objectNode.addElement("name"); nameNode.setText("Neo"); Element yearNode = objectNode.addElement("year"); yearNode.setText("1999"); // 设置输出格式 （换行缩进，字符） OutputFormat format = OutputFormat.createPrettyPrint(); format.setEncoding("UTF-8"); XMLWriter writer = null; try &#123; writer = new XMLWriter(new FileOutputStream("dom4jTest.xml"), format); // 设置为不转义 （默认转义） // writer.setEscapeText(false); writer.write(document); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; writer.close(); &#125;&#125; dom4jTest.xml 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;transaction&gt; &lt;object id="1"&gt; &lt;name&gt;Neo&lt;/name&gt; &lt;year&gt;1999&lt;/year&gt; &lt;/object&gt;&lt;/transaction&gt;]]></content>
      <categories>
        <category>① Starter</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>DOM</tag>
        <tag>SAX</tag>
        <tag>JDom</tag>
        <tag>Dom4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis三剑客]]></title>
    <url>%2F2019%2F06%2F10%2FMybatis%E4%B8%89%E5%89%91%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[MyBatis 这种半封装的ORM框架相较全封装，最大的优点就是 SQL优化方便， 但也有不少痛点，如 简单的 CRUD 逻辑都需要自行处理，*.xml 不能和 *.java 文件友好契合等。 工欲善其事，必先利其器。这里介绍几个工具，可以有效的解决 Mybatis 的痛点，大大的提高工作效率。 涉及 说明 Mybatis Generator 代码生成器。 Mybatis Plugin IDE插件，解决 *.xml 不能和 *.java 文件完美契合等。 Mybatis PageHelper 分页插件。 Mybatis GeneratorMybatis Generator 是 Mybatis 提供的代码生成器，可以生成DAO层所需的*.java , *.xml 和 实体类 ，包括可以简单的CRUD相关所需。 注意 : 默认情况下，反复运行 *.java 文件会被覆盖，而 *.xml 会合并。 12345678&lt;!-- generator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; generatorConfig.xml 踩坑记 table.schema : 使用oracle时，最好使用 schema 指定用户名，因为当实例下有多个用户拥有相同的表时，若对表进行变更，会无法及时更新。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;!-- todo 字段注释 --&gt;&lt;!-- 注意相关目录一定要存在，且分模块时要加模块目录名 --&gt;&lt;generatorConfiguration&gt; &lt;context id="MysqlContext" targetRuntime="MyBatis3" defaultModelType="flat"&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;!-- optional，旨在创建class时，去除多余警告注释等 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/framework-x" userId="root" password="root"&gt; &lt;/jdbcConnection&gt; &lt;!-- 生成的pojo所在包 --&gt; &lt;javaModelGenerator targetPackage="tk.gushizone.system.common.pojo" targetProject="system-common/src/main/java"/&gt; &lt;!-- 生成的mapper所在目录 --&gt; &lt;sqlMapGenerator targetPackage="tk.gushizone.system.common.dao.sqlmap" targetProject="system-common/src/main/java"/&gt; &lt;!-- &lt;sqlMapGenerator targetPackage="mapper" targetProject="web/src/main/resources"/&gt; --&gt; &lt;!-- 配置mapper对应的java映射 --&gt; &lt;javaClientGenerator targetPackage="tk.gushizone.system.common.dao" targetProject="system-common/src/main/java" type="XMLMAPPER" /&gt; &lt;!-- 作用表 (关闭所有示例) --&gt; &lt;table tableName="sys_user" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 启动方式generator 有很多启动方式，个人认为 main方法 启动，最为友好，以下为示例。 1234567891011121314151617181920212223242526272829303132333435363738package tk.gushizone.system.common.util;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;/** * mybatis generator * @author gushizone@gmail.com * @createTime 2019-05-06 15:33 */public class GeneratorDisplay &#123; private static final String ACTIVE_CONFIG = "generatorConfig.xml"; public static void main(String[] args) throws Exception &#123; ClassLoader classLoader = GeneratorDisplay.class.getClassLoader(); GeneratorDisplay.generator(classLoader.getResource(ACTIVE_CONFIG).getFile()); &#125; public static void generator(String configMode) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;&gt;(); boolean overwrite = true; File configFile = new File(configMode); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; Mybatis Plugin 相关IDE插件有很多，以 IDEA 为例，我使用的是 Free Mybatis Plugin 。类似的 Mybatis Plugin 和 Mybatis Plus 功能更强大，但是收费。 主要功能 关联 *.java 和 *.xml ，并提供相关验证。 自动补全和代码生成等。 Mybatis PageHelperMybatis PageHelper 是一款非常好用的 Mybatis 分页插件。支持各种数据库，使用起来也十分方便。 pagehelper官网 pagehelper源码 123456&lt;!-- pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 12345pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 分页方式这里简单的介绍一下利用 PageHelper 实现分页的方式。 Mybatis PageHelper 提供了很多种实现方式，这里只列举常用的方式。 涉及 说明 PageHelper.startPage 静态方法 推荐开发使用，耦合度和代码侵入性小。 ISelect接口 方式 推荐框架使用，代码侵入性小，且安全性高。 PageHelper.startPage 静态方法这里介绍一种常用的方式： PageHelper.startPage + PageInfo 。 分页时，sql 会被拦截。分页后，实际返回是 Page&lt;E&gt; 类型的对象，Page 是 ArrayList 的子类 , 如果想取出分页信息，需要强制转换为 Page&lt;E&gt; ，或使用 PageInfo。 123456// 获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list); ISelect接口 方式JDK8后，配合 lambda表达式 更适合架构设计。 ISelect接口方式 在 JDK8 以前使用并不友好，这里不加赘述。 可以将此段代码封装到架构底层，再用 lambda 配合 ISelect接口 ，可以做到分页代码在上层业务代码中达到无侵入。 12345// 返回Page对象Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());// 返回PageInfo对象pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy()); 排序123456789// 开始分页PageHelper.startPage(pageNum, pageSize);// 排序if (StringUtils.isNotEmpty(sortField))&#123; PageHelper.orderBy(sortField + " " + sortOrder);&#125;List&lt;SysUser001Dto&gt; list = mapper.selectByList(user); 注意项PageHelper.startPage方法重要提示只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页。 线程安全性 ：只要 PageHelper.startPage 静态方法后跟着一个select 方法就会线程安全，因为分页参数和线程是绑定的 。反之，生产的分页参数会一直存于该线程中，没被消费，当这个该线程被再次调用时，可能会产生了莫名其妙的分页。 请不要配置多个分页插件请不要在系统中配置多个分页插件(使用Spring时,mybatis-config.xml和Spring&lt;bean&gt;配置方式，请选择其中一种，不要同时配置多个分页插件)！ 分页插件不支持带有 for update 语句的分页对于带有for update的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。 分页插件不支持嵌套结果映射由于嵌套结果方式会导致结果集被折叠，因此分页查询的结果在折叠后总数会减少，所以无法保证分页结果数量正确。]]></content>
      <categories>
        <category>③ 奇技淫巧</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Mybatis Generator</tag>
        <tag>Mybatis Plugin</tag>
        <tag>Mybatis PageHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javap: 了解编译器的内部工作]]></title>
    <url>%2F2019%2F06%2F01%2Fjavap-%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[javap : Java class文件分解器，其可以将不可读字节码转换为对应的可读指令。通过对照源码和指令，可以让我们了解编译器的内部工作，对于理解程序执行过程和执行效率等都有很大的帮助。本文就来介绍一下 javap 的简单使用。 认识 javap众所周知， *.java 文件会被 java编译器转变为 *.class 字节码文件，再交由JVM转变为对应平台的机器指令，这就是 Java程序多平台兼容的关键。 1*.java -&gt; *.class -&gt; 机器指令 需要知道的是，编译器并不是简单的去除所不必要的东西 (如注释，换行等)，再转变为 16进制文件，而是做了编译器优化，这些行为是无法直接知道的。虽然字节码也是可以被解读的，但这对人来说并不友好，而使用 JDK 提供的 javap 就可以将不可读字节码转换为对应的可读指令。 JDK 目录结构从 JDK 目录结构可以看出 : JDK = JRE + Tools&amp;Tool APIs 。 javap 正是 JDK 提供的开发工具之一。 12345678910.├── bin # JDK开发工具的可执行文件│ ├── java # Java解释器 : *.class -&gt; 机器指令│ ├── javac # Java编译器 : *.java -&gt; *.class│ ├── javadoc # API 文档生成器│ ├── javap # Java class文件分解器│ └── ...├── include # 包含C语言头文件,支持Java本地接口与Java虚拟机调试程序接口的本地编程技术├── jre # 包含: JVM + 运行时的类包 + Java应用启动器└── lib # 开发工具使用的归档包文件 使用 javap这里只列举常用 javap 的常用指令。正如所见 javap -c 和 javap -v 可以满足绝大部分需求。 javap [options] class 说明 -help / —help / -? 帮助。 -v / -verbose 输出附加信息，包括绝大部分详细信息。 -l 输出行号和本地变量表。 -package 显示程序包/受保护的/公共类。 -p / -private 显示所有类和成员。 -c 对代码进行反汇编。 -sysinfo 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)。 -constants 显示最终常量。 javap -c 这里演示一下 javap -c 的用法和功能。 *.java 12345678public class JavapTest &#123; public static void main(String[] args) &#123; String str1 = "a" + "b" + "c"; String str2 = str1 + "dfg"; &#125;&#125; javap 是作用在 *.class 上的，先使用 javac 获得 *.java 对应的 *.class 。 如果希望直接在 shell 中使用 JDK工具，需要配置环境变量。 12345678910111213141516171819202122232425262728# 在java文件目录执行，会在当前目录获得.class文件$ javac JavapTest.java# 获取对应.class文件的反编译指令$ javap -c JavapTestCompiled from "JavapTest.java"public class JavapTest &#123; public JavapTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String dfg 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: astore_2 23: return&#125; 1) 编译器对字符常量拼接的优化由以下可以看出，当对字符常量的拼接时，编译器直接创建了拼接结果。 10: ldc #2 // String abc 2) 编译器对字符引用对象拼接的优化由以下可以看出，当对字符引用对象的拼接时，编译器会自动创建 StringBuilder 进行拼接。 123456783: new #3 // class java/lang/StringBuilder6: dup7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V10: aload_111: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;14: ldc #6 // String dfg16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;19: invokevirtual #7 // Method java/lang/StringBuilder.toString: IDEA 整合 javap使用命令编译再反编译，在日常使用时还是很麻烦的，所有这里介绍一下使用 IDEA外部工具（External Tools） 添加 javap ，这样使用起来会十分方便 。 推荐使用 javap -v ，因未知原因 javap -c 并不能正常输出完整信息🤣。 添加方法 进入 preferences -&gt; Tools -&gt; External Tools 添加 设置程序位置Program : $JDKPath$/bin/javap 。 设置参数Arguments : -v $FileClass$ 。 设置工作空间为编译输出位置Working directory : $OutputPath$ 。 使用方法 在对应文件右击 External Tools 即可使用所配置的外部工具。]]></content>
      <categories>
        <category>③ 奇技淫巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>javap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot常用技术整合和使用]]></title>
    <url>%2F2019%2F05%2F20%2FSpringBoot%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文环境基于 springboot 2.0.1.RELEASE , springboot 要求JDK8+ 。 认识 SpringBootSpring Boot : 与 Spring4 一起诞生，是一个微框架。 整合了许多子项目，使用很少的配置就可以十分快速的搭建和运行项目。约定优先于配置，减少样板化的配置。 自动装配：springMVC，jdbc，事务等。 使用嵌入式容器：tomcat，netty，jetty等。不需要打成 war 包，就可以放入 tomcat 中运行。 提供可视化的相关功能，方便监测，比如性能，应用的健康程度等。 为微服务 SpringCloud 铺路，SpringBoot 可以整合很多框架来构建微服务，比如 dubbo，thrift 等。 相关比较 说明 spring framework spring 框架。 spring boot 快速构建 spring 应用。 spring cloud springboot 分布式云应用。 快速起步 Building an Application with Spring Boot SpringBoot 提供了一个快速初始化项目的网站 https://start.spring.io 。 当然我们也可以构建一个普通的 Maven 项目并引入相关依赖。 springboot 项目需要继承 spring-boot-starter-parent ，其会提供一些默认参数。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 快速构建 web 项目，只要引入 spring-boot-starter-web 即可，其已包含了 tomcat 插件。正如所见，其会继承父 pom 的版本号。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; springboot 使用 main方法 启动，其会自动扫描子包内的相关配置等。 注意 : 如下的示例，只会扫描 kt.gushizone.framework 子包的内容。 123456789101112package kt.gushizone.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class); &#125;&#125; 仅需以上的配置，即可启动运行一个简单的 Web 项目，就是这么简单！ 例如添加如下 Rest 风格的 Controller，进行测试。 1234567891011121314package kt.gushizone.demo.controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123; @PostMapping("/hello") public User save()&#123; return "Hello SpringBoot!"; &#125;&#125; 目录结构一个简单的 springboot 的目录如下所示。 12345678910111213141516demo├── pom.xml└── src ├── main │ ├── java │ │ └── kt │ │ └── gushizone │ │ └── demo | │ ├── ... # 可扫描的包 │ │ └── DemoApplication.java # 启动类 │ │ │ └── resources │ ├── application.yml # 配置文件 │ ├── static # 静态资源 │ └── templates # 模板 └── test 配置文件springboot 默认支持通过 application.properties 和 application.yml 配置属性。两者可以并存，且会优先参考 .properties ，若相关配置没有，会尝试从 .yml 中获取。 1234567# api 端口号server.port=8080# url 路径server.servlet.context-path=/demo# session 超时时间server.servlet.session.timeout=60mserver.tomcat.uri-encoding=utf-8 yaml 是当前流行的配置方式，较 .properties 展示树状结构更清晰，较 .xml 更加简洁。 下文中为使配置项更清晰，会以 .properties 的方式配置。 12345678server: port: 8080 servlet:# context-path: /demo session: timeout: 60m tomcat: uri-encoding: utf-8 环境隔离一般开发 ，测试，上线等环境是不同的，springboot 支持多环境的文件配置。可以创建 application-{profile}.properties 或 application-{profile}.yml 等配置文件，使用 spring.profiles.active 指定当前生效的配置文件。 1spring.profiles.active: dev 使用 yml 配置时，也可以配置在一个文件中配置。 不推荐 ! 123456789spring: profiles: active: dev---spring: profiles: dev---spring: profiles: prod 读取配置可以在 .yml 中直接使用已定义的值。 12345default: value: 123456 system: username: admin password: $&#123;default.value&#125; 在 Java 中获取值，并设置默认值。 123456789import org.springframework.beans.factory.annotation.Value;...@Value("$&#123;default.system.username:admin&#125;")private String defaultUsername;@Value("$&#123;default.system.password:123&#125;")private Integer defaultPassword; 读取自定义文件一般我们会将配置文件放在 resource 目录，默认编译行为会将其输出到更目录，通过 ClassLoader 可以获取 classpath 根目录路径。 注意 : 文件的读取是依赖当前环境的目录结构，并不是项目目录结构。例如 编译和打包后，目录结构都是不同的。 123String fileName = "mmall.properties";ClassLoader classLoader = Test.class.getClassLoader(); 12345// 方式一，推荐InputStream in = classLoader.class.getResourceAsStream(fileName);// 方式二，不推荐，在打包后可能无法正常获取。File configFile = new File(classLoader.getResource(fileName).getFile();); 123// 属性文件读取Properties props = new Properties();props.load(new InputStreamReader(classLoader.getResourceAsStream(fileName),"UTF-8")); 整合 Logspringboot 整合了一个 sl4j 依赖，可以直接使用 log4j 和 logback 。当然也可以单独引入。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 推荐使用 Logback。 Log4j具体配置参考 : 浅谈LOG之Log4j Logback具体配置参考 : 浅谈LOG之Logback 整合Thymeleaf完成如下配置即可使用 Thymeleaf，详情参考 : 浅谈Thymeleaf 浅谈Thymeleaf之Layout 附录之Thymeleaf表达式实用程序对象 pom.xml Spring Boot 1.x 中包含了thymeleaf-layout-dialect ，但在 Spring Boot 2.x 中被移除。 123456789&lt;!-- thymeleaf 和 布局方言 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;nz.net.ultraq.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-layout-dialect&lt;/artifactId&gt;&lt;/dependency&gt; application.properties12345678910111213spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.servlet.content-type=text/html# 关闭缓存，即时刷新spring.thymeleaf.cache=false# 设置静态文件路径，js，css 等# 请求路径spring.mvc.static-path-pattern=/public/**# 资源路径#spring.resources.static-locations=classpath:/static/ messages*.properties顺便提一下国际化配置，文件默认必须以 messages 开头命名，可以重写 MessageSourceAutoConfiguration 。 /src/main/resources/i18n/messages_zh_CN.properties 1home.welcome=欢迎来到我们的杂货店！ 整合 Mybatispom.xml123456789101112&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 1234567891011&lt;!-- DB --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt;&lt;/dependency&gt; 一般 *Mapper.xml 会放在 resources 下，但是这样开发和管理时不是很方便。这时可以放在 java 目录内，添加以下配置，可以确保被复制到输出目录。 12345678910&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; application.properties 没有扫描的xml并不影响启动，但使用时会出现 org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) 异常 。 1234567891011# mybatis# pojo 的位置 (配置该项后，可以在xml中不使用全路径引用实体类)mybatis.type-aliases-package=tk.gushizone.common.pojo# xml 的位置mybatis.mapper-locations=classpath*:tk/gushizone/**/dao/sqlmap/*.xml,classpath*:mapper/*.xml# pagehelperpagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql 123456789101112# dbspring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driver# druidspring.datasource.druid.initial-size=1spring.datasource.druid.min-idle=1spring.datasource.druid.max-active=20spring.datasource.druid.test-on-borrow=truespring.datasource.druid.stat-view-servlet.allow=true 123# 热部署 - mybatis相关 ( 需要配置devtools )restart.include.mapper=/mapper-[\\w=\\.]+jarrestart.include.pagehelper=/pagehelper-[\\w=\\.]+jar Application.java @MapperScan 用于扫描 DAO层 接口，生成对应的 bean。 12345678@SpringBootApplication@MapperScan(basePackages = &#123;"tk.gushizone.**.dao"&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125;&#125; 热更新热部署 和 热加载 都是指不重启服务，完成更新编译/部署项目，其都是基于Java的类加载器实现。 涉及 部署方式 实现原理 使用场景 热部署 热部署在服务器运行时重新部署项目 热部署直接重新加载整个应用，存在内存释放。 热部署更多在生产环境使用。 热加载 热加载在运行时重新加载class 热加载在运行时重新加载class，监控文件是否改变，直接修改 JVM 内的字节码文件。 热加载更多在开发环境使用。 可以看出我们一般说的热部署其实都是热加载，这里也是介绍一下springboot热加载方式。 热加载方式 说明 - 默认情况下springboot可以完成对 .java 的热更新，至少在 IDE 中是这样 🤣 。 Devtools 使用快速重启的方式，可以完成对 .java 和 .xml 的热更新。 Springloaded 可以完成对 .java 的热更新。 IDE 插件 如 JRebel ，收费插件，这里不会介绍。 -Eclipseeclipse 默认会自动编译，不需要任何设置，即可完成热更新。 IDEAIDEA 默认不会自动编译，需要设置。 Preferences -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Build project automaticaly 。 command + shift + ctrl + / -&gt; Registry -&gt; compiler.automake.allow.when.app.running 。 编辑应用启动配置: Edit Configuration -&gt; Running Application Update Policies -&gt; Update classes and resources 。 如果还是不行，可以点击右上角的小锤子，或 command + F9 。 Devtools Devtools 在项目较大时，启动依然会慢 🤣。 实现对类文件的热部署，文件发生改变时会立即重启应用，因为采用虚拟机机制，重启会很快。 pom.xml1234567&lt;!-- devtools --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;!-- optional=true, 依赖不会传递 --&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; application.properties123456# 热部署 - thymeleafspring.thymeleaf.cache=false# 热部署 - mybatis相关restart.include.mapper=/mapper-[\\w=\\.]+jarrestart.include.pagehelper=/pagehelper-[\\w=\\.]+jar Springloaded在 spring-boot-maven-plugin 插件下添加 springloaded 依赖。 如果不能自动下载，先放到上面的 dependencies 中即可下载。 12345678910111213141516171819&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;tk.gushizone.system.SystemApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;!--mvn spring-boot:run--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; maven方式 IDEA 中直接 Terminal 进行 clean install 再 mvn spring-boot:run 即可。 12345678# 项目根目录cd ../app-demo # 将项目依赖打包并放入本地仓库mvn -Dmaven.test.skip -U clean install # 主模块目录cd web # maven方式 启动 springboot项目mvn spring-boot:run JVM 启动参数需要下载 jar 包，记住路径，并给 JVM 添加启动参数。 1-javaagent:/users/username/developer/lib/springloaded-1.2.6.RELEASE.jar -noverify Junit12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Junit 的测试方法一定要是 public 。 12345678910111213141516171819202122232425package org.demo.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.junit4.SpringRunner;import org.demo.Application;import org.demo.user.UserService;@RunWith(SpringRunner.class)@ActiveProfiles("dev")@SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class JunitTest &#123; @Autowired private UserService userService; @Test public void test1() throws BatchException &#123; userService.queryByPage(); &#125;&#125; 打包 &amp; 运行这里仅介绍 jar 和 war 的打包和运行。 打包种类在应用启动模块 的 pom 规定打包方式 , 其默认为 jar 。 注意 ：当设置为 war 时，需要满足含有 main/webapp/WEB-INF/web.xml ，即使为空文件。 1&lt;packaging&gt;war&lt;/packaging&gt; 一般的打包种类有 : jar , war , ear ，详情如下： 打包方式 说明 jar Java Archive file ，一般把开发时要引用通用(JAVA)类及资源做封装，打成包后便于存放管理。 war Web Archive file ，一个(web)完整的应用，通常是网站或WEB平台，打成包后可以部署到容器中。 ear Enterprise Archive file ，企业级应用，实际上EAR包中包含WAR包和几个企业级项目的配置文件而已，服务器中间件通常选择WebSphere等都会使用EAR包。通常是EJB打成ear包。 编译插件和启动类springboot 提供了编译打包的maven插件，如果希望可以直接运行，还需要指定启动类： mainClass 。 方式一1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;org.demo.DemoApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 方式二123&lt;properties&gt; &lt;start-class&gt;org.demo.DemoApplication&lt;/start-class&gt;&lt;/properties&gt; 打包并运行进入项目根目录，执行以下命令： 12# 跳过测试，更新第三方包，clean，packagemvn -Dmaven.test.skip -U clean package 打包成功后，可以在 主模块 /web/target 下看到压缩包。 1234567# 打包为 jar 时：# web-0.0.1-SNAPSHOT.jar # 包含该所有依赖 和 项目 class# web-0.0.1-SNAPSHOT.jar.original # 项目 class# 打包为 war 时：# web-0.0.1-SNAPSHOT.war # 包含该所有依赖 和 项目 class# web-0.0.1-SNAPSHOT.war.original # 项目 class 和依赖 jar方式，启动项目12345# 打包为 jar 时：java -jar web-0.0.1-SNAPSHOT.jar# 打包为 war 时：java -jar web-0.0.1-SNAPSHOT.war maven 方式运行12345678# 项目根目录cd ../app-demo # 将项目依赖打包并放入本地仓库mvn -Dmaven.test.skip -U clean install # 主模块目录cd web # maven方式 启动 springboot项目mvn spring-boot:run]]></content>
      <categories>
        <category>① Starter</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Thymeleaf</tag>
        <tag>SpringBoot</tag>
        <tag>Log</tag>
        <tag>Devtools</tag>
        <tag>Springloaded</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈LOG之Logback]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%B5%85%E8%B0%88LOG%E4%B9%8BLogback%2F</url>
    <content type="text"><![CDATA[logback 同样是由log4j的作者设计完成的，拥有更好的特性，是用来取代 log4j 的一个日志框架。logback 是 slf4j 的原生实现 。 logback 和 log4j 的大多数概念类似，这里不作赘述。 官方文档 : Logback 浅谈LOG之Log4j 认识 Logback日志架构 涉及 说明 logback-core 其它两个模块的基础模块。包含Appender 和 Layout接口 。 logback-classic 它是 log4j 的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统(如 log4j 或 JDK1.4 Logging) 。包含 Logger 对象 。 logback-access 访问模块与Servlet容器集成提供通过Http来访问日志的功能。 核心对象Logger命名层次结构 和Log4j相同的命名规范和继承关系。 如果记录器的名称后跟一个点是后代记录器名称的前缀，则称该记录器是另一个记录器的祖先。如果记录器本身和后代记录器之间没有祖先，则称记录器是子记录器的父节点。 Appender Appender 和 Logger 具有一样的继承关系。 Appender 控制日志输出目标，例如：控制台，文件，远程套接字服务器，数据库，JMS和远程UNIX Syslog守护程序等。 LayoutLayout 负责定制输出格式，它是通过 Appender 相关联来实现的。 支持对象LoggerContext各个logger 都被关联到一个 LoggerContext，LoggerContext负责制造logger，也负责以树结构排列各logger。 Level 如果给定的记录器没有分配级别，那么它将 从具有指定级别的最近祖先继承 一个级别。 如果Logger请求的级别高于或等于其Logger的有效级别，则为启动，反之禁用。 级别（优先级：desc） 描述 OFF 最高级别，用于关闭日志。 FATAL 指明非常严重的错误事件，可能会导致应用终止执行。 ERROR 指明错误事件，但应用可能还能继续运行。 WARN 指明潜在的有害状况。 INFO 指明描述信息，从粗粒度上描述了应用运行过程。 DEBUG 指明细致的事件信息，对调试应用最有用。 TRACE 比 DEBUG 级别的粒度更细。 ALL 所有级别，包括定制级别。 使用 LogbackLogback的默认配置 尝试在 classpath 下查找文件 logback-test.xml 。 若文件不在，则查找 logback.xml 。 若两个文件都不在，使用 BasicConfigurator 默认配置，日志输出到控制台。 123456&lt;!--logback(自动依赖：logback-core,slf4j-api)--&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; logback.xml appender.encoding 在高版本中不再需要，使用会产生异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 根节点： scan: 配置文件改变时，是否重新加载，默认为true； scanPeriod: 扫描文件间隔时间，在 scan="true" 后生效，默认单位为毫秒； debug: 是否打印logback的内部日志信息，默认为false。 --&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义变量: 在下文中可以使用 $&#123;&#125; 使用该变量 --&gt; &lt;property name="logfolder" value="/users/gushi/developer/log/demo" /&gt; &lt;!-- appender: 控制台输出 --&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!-- 对日志进行格式化 --&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 输出&gt;=DEBUG级别的日志（因为mybatis的sql日志级别为DEBUG） --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- appender: 滚动记录日志，先记录指定文件，再按照滚动策略将日志记录到其他文件 --&gt; &lt;appender name="demo" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;File&gt;$&#123;logfolder&#125;/demo.log&lt;/File&gt; &lt;!-- 是否追加日志，默认为true，置为false会先清空 --&gt; &lt;append&gt;true&lt;/append&gt; &lt;!-- 滚动策略: 根据文件大小和时间来制定 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt; &lt;FileNamePattern&gt;$&#123;logfolder&#125;/daily/daily-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!-- 归档文件最大保留数 --&gt; &lt;MaxHistory&gt;10&lt;/MaxHistory&gt; &lt;!-- 最大文件大小 --&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;!-- 总大小 --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="error" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;File&gt;$&#123;logfolder&#125;/demo.log&lt;/File&gt; &lt;!-- 滚动策略: 根据时间来制定 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;logfolder&#125;/demo.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt; &lt;append&gt;true&lt;/append&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--级别过滤--&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 设置具体包/类的打印级别，以及指定appender name: 约束某个包/类; level: 打印级别，和大小写无关，默认为DEBUG; additivity：是否继承上级的级别，默认为true; --&gt; &lt;logger name="org.demo" additivity="false" level="INFO" &gt; &lt;appender-ref ref="demo" /&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt; &lt;!-- mybatis log 日志 （因为mybatis的sql日志级别为DEBUG）--&gt; &lt;logger name="org.demo.dao" level="DEBUG"/&gt; &lt;!-- 根loger: 所有logger的上级，默认为DEBUG --&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="console"/&gt; &lt;appender-ref ref="error"/&gt; &lt;/root&gt;&lt;/configuration&gt; *.java123456789101112package org.Demo;import org.slf4j.Logger;public class Demo&#123; // 获取与类同名的日志对象 private final static Logger logger = LoggerFactory.getLogger(HelloJob.class); public void log()&#123; logger.info("用户**访问了***"); &#125;&#125; 附录优化logback 已自身优化，不用考虑因为使用日志功能而降低业务执行效率。注意使用占位符即可。 关闭日志时（多参数日志）java中对String的直接拼接的消耗是巨大的。 由于日志级别Level的限制，一些日志可能不会输出，但是构造消息参数依然会消耗巨大成本。 1logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i])); 方式一 即使输出，所需时间也增加不到 1% 。 123if(logger.isDebugEnabled()) &#123; logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));&#125; 方式二 推荐 使用类似 占位符 的方式，在日志被禁用的情况下，至少优化了30倍。 123456logger.debug("The new entry is &#123;&#125;.", entry);logger.debug("The new entry is &#123;&#125;. It replaces &#123;&#125;.", entry, oldEntry); Object[] paramArray = &#123;newVal, below, above&#125;;logger.debug("Value &#123;&#125; was inserted between &#123;&#125; and &#123;&#125;.", paramArray); 开启日志记录时（默认继承）Logger对象在创建时已明确了日志级别，不会动态继承。在基于有效级别接受或拒绝请求之前，记录器可以做出准瞬时决定，而无需咨询其祖先（不需要遍历记录器层次结构。）。 实际记录（格式化和写入输出设备）已优化Layout和Appdender，一些logback组件已被重写几次以提高性能。 记录到本地计算机上的文件时，实际记录的典型成本约为9到12微秒。登录到远程服务器上的数据库时，它会持续几毫秒。]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>LOG</tag>
        <tag>SL4J</tag>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈LOG之Log4j]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%B5%85%E8%B0%88LOG%E4%B9%8BLog4j%2F</url>
    <content type="text"><![CDATA[一个成熟的项目，日志系统是必不可少的。当前流行的框架有 log4j , logback ，它们都是基于 slf4j 日志规范/接口 开发。本文就来介绍一下 Log4j 。 认识 Log4J日志架构Log4j API 采用分层架构，每一层有不同的对象，完成不同的任务。这种分层架构让设计变得灵活，且易于日后扩展。 核心对象★ 涉及一览 说明 Logger 负责获取日志信息，并存储于一个分层的命名空间之中。 Layout 负责格式化日志信息的对象，在发布日志信息之前，它为 appender 对象提供支持。 Appender 负责将日志信息输出到不同目的地，比如数据库、文件、控制台、Unix Syslog 等。 Logger该对象位于分层架构中的最上层，负责获取日志信息，并存储于一个分层的命名空间之中。 对象获取 Logger 类不允许初始化一个新的实例，但提供了三个静态方法用来获取 Logger 对象： 实际上是从 LogManager 的Logger工厂中 获取 / 设置 和参数同名的Logger对象。 123456/** 获得根日志对象*/public static Logger getRootLogger();/** 通过calzz的名字（getName()）获取对应的日志对象，底层和 getLogger(String name)是相同的 */public static Logger getLogger(Class clazz);/** 通过字符串获取对应的日志对象 */public static Logger getLogger(String name); 日志对象继承 &amp; 日志对象名 可以通过Logger对象来触发打印日志。 Logger具有 父子/继承关系 ，且所有日志对象都是RootLogger的子对象。子logger会继承父logger的appender等，触发打印后会从子类向上依次调用appender。 12345# 设置两个日志对象，日志对象名为com.ibatis和com.ibatis.common.jdbc.SimpleDataSource# 其中com.ibatis是com.ibatis.common.jdbc.SimpleDataSource的父logger# 且com.ibatis包下所有类获得的日志对象都是com.ibatis日志对象的子loggerlog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=INFO Logger对象的继承关系是通过 日志对象名 来管理的。 除了以上在获取Logger对象的同时设置日志对象名外，还可以在 log4j.properties 设置并细化配置 1234# 自定义一个日志对象，日志对象名为securityLog# 从上面的解释可能会认为日志对象securityLog是作用于securityLog包下的类# 但一般也可以用Logger.getLogger(&quot;securityLog&quot;)来获取日志对象log4j.logger.securityLog = INFO,log_security,database 日志信息级别 一旦获取一个有名字的 logger 实例，就可以使用如下方法用于打印日志信息。 注意 ：日志信息不一定会被输出，其会被日志对象（及其父logger）的最低日志级别 过滤 并且还需要对应的appender，才能输出到指定位置。 优先级 方法和描述 1 public void fatal(Object message) 使用 Level.FATAL 级别打印日志。 2 public void error(Object message) 使用 Level.ERROR 级别打印日志。 3 public void warn(Object message) 使用 Level.WARN 级别打印日志。 4 public void info(Object message) 使用 Level.INFO 级别打印日志。 5 public void debug(Object message) 使用 Level.DEBUG 级别打印日志。 6 public void trace(Object message) 使用 Level.TRACE 级别打印日志。 最低日志级别 可以设置Logger对象打印日志信息的最低级别，只有大于或等于该级别的信息才会被输出 例如以下配置中：com.ibatis.common.jdbc.SimpleDataSource 日志对象会无法输出日志，而 com.ibatis.Demo 日志对象可以使用根日志对象的appender(CONSOLE)将日志信息输出到控制台。 12345678910# 设置根日志对象最低日志级别为INFO，并设置一个appender(CONSOLE)log4j.rootLogger = INFO,CONSOLElog4j.logger.com.ibatis=INFOlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUG# print the message to console(ENABLE)log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n 12//最低日志级别也可以在java中设置log.setLevel(Level.WARN); Layout负责格式化日志信息的对象，在发布日志信息之前，它为 appender 对象提供支持。 所有 Layout 对象从 Appender 对象那里接收一个 LoggingEvent 对象，然后从 LoggingEvent 对象那里获取信息，并使用恰当的 ObjectRenderer 对象获取该信息的字符串形式。 位于继承关系顶层的是抽象类 org.apache.Log4j.Layout，这是所有 Log4j API 中 Layout 类的基类。 在应用中我们从不直接使用该类，而是使用它的子类，如下所示： 其中最常用的是 PatternLayout , 本wiki主要主要针对其进行讲解。 DateLayout HTMLLayout PatternLayout SimpleLayout XMLLayout Appender该对象位于分层架构中的较低一层，负责将日志信息输出到不同目的地，比如数据库、文件、控制台、Unix Syslog 等。 支持对象☆这些是框架的可选对象，它们支持核心对象做一些额外的任务，同样在框架中发挥着重要作用。 LevelLevel 对象定义了日志信息的粒度和优先级。 org.apache.Log4j.Level 类定义了日志级别，您可通过继承 Level 类定制自己的级别。 级别（优先级：desc） 描述 OFF 最高级别，用于关闭日志。 FATAL 指明非常严重的错误事件，可能会导致应用终止执行。 ERROR 指明错误事件，但应用可能还能继续运行。 WARN 指明潜在的有害状况。 INFO 指明描述信息，从粗粒度上描述了应用运行过程。 DEBUG 指明细致的事件信息，对调试应用最有用。 TRACE 比 DEBUG 级别的粒度更细。 ALL 所有级别，包括定制级别。 FilterFilter 对象用来分析日志信息，进而决定该条日志是否被记录。 一个 Appender 对象可对应多个 Filter 对象，当日志信息传给 Appender 对象时，与其关联的所有 Filter 对象需要判断是否将日志信息发布到目的地。 ObjectRendererObjectRenderer 对象负责为传入日志框架的不同对象提供字符串形式的表示，Layout 对象使用该对象来准备最终的日志信息。 LogManagerLogManager 对象管理日志框架，它负责从系统级的配置文件或类中读取初始配置参数。 使用 Log4j单纯的使用只需要 slf4j-api , log4j ; 一些项目需要 slf4j-log4j12 （如： MyBatis ）。 12345678910111213141516&lt;!-- log (slf4j, log4j, slf4j-log4j整合)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; log4j.properties默认情况下， LogManager 会在 classpath 中寻找 log4j.properties 文件。 以下是较为详细的配置示例，模式转换字符请参考：附录：PatternLayout 12345678910111213141516171819202122232425262728293031323334353637# 设置根日志，最低日志级别为INFO，并添加了2个appender（CONSOLE,log_error）确定输出详情log4j.rootLogger = INFO,CONSOLE,log_error# 自定义securityLog日志对象，最低日志级别为INFO，并添加了2个appender（log_security,database）确定输出详情log4j.logger.securityLog = INFO,log_security,databaselog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=INFOlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=INFOlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUGlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=INFOlog4j.logger.java.sql.PreparedStatement=DEBUG,stdout# 使用控制台输出日志log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n# 使用文件输出日志log4j.appender.log_security = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.log_security.file = D:/PHIMP/logs/log_securitylog4j.appender.log_security.DatePattern = &apos;_&apos;yyyyMMdd&apos;.log&apos;log4j.appender.log_security.layout = org.apache.log4j.PatternLayoutlog4j.appender.log_security.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n# 使用文件输出日志，最低级别为errorlog4j.appender.log_error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.log_error.Threshold = errorlog4j.appender.log_error.file = D:/PHIMP/logs/log_errorlog4j.appender.log_error.DatePattern = &apos;_&apos;yyyyMMdd&apos;.log&apos;log4j.appender.log_error.layout = org.apache.log4j.PatternLayoutlog4j.appender.log_error.layout.ConversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] - %m%n# 使用数据库输出日志，最低级别为info# 推荐继承org.apache.Log4j.jdbc.JDBCAppender（org.log.LogJdbcAppender）直接获得数据库相关信息log4j.appender.database = org.log.LogJdbcAppenderlog4j.appender.database.Threshold = infolog4j.appender.database.layout = org.apache.log4j.PatternLayoutlog4j.appender.database.sql = INSERT INTO %X&#123;tableName&#125; (%X&#123;fields&#125;) VALUES (%X&#123;values&#125;) *.java获取日志对象，设置日志信息。 控制台 / 文件 输出日志 控制台输出: [INFO] 2017-01-17 17:01:17 [org.Demo] - 用户**访问了*** 12345678910package org.Demo;import org.apache.log4j.Logger;public class Demo&#123; // 获取与类同名的日志对象 private Logger logger = Logger.getLogger(this.getClass()); public void log()&#123; logger.info("用户**访问了***"); &#125;&#125; 数据库 输出日志JDBCAppender.java 继承org.apache.Log4j.jdbc.JDBCAppender直接获得数据库相关信息，不需要单独配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LogJdbcAppender extends JDBCAppender &#123; protected final Logger logger = Logger.getLogger(getClass()); public LogJdbcAppender() &#123; super(); &#125; @Override protected Connection getConnection() &#123; try &#123; connection =((SqlMapClient)ServiceLocator.getBean("sqlMapClient")).getDataSource().getConnection(); return connection; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void closeConnection(Connection con) &#123; try &#123; if (con != null &amp;&amp; !con.isClosed()) &#123; con.close(); con = null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void flushBuffer() &#123; removes.ensureCapacity(buffer.size()); for (Iterator i = buffer.iterator(); i.hasNext();) &#123; try &#123; LoggingEvent logEvent = (LoggingEvent)i.next(); String sql = getLogStatement(logEvent); removes.add(logEvent); execute(sql); &#125; catch (SQLException e) &#123; errorHandler.error("Failed to excute sql", e, ErrorCode.FLUSH_FAILURE); &#125; &#125; buffer.removeAll(removes) removes.clear(); &#125;&#125; 调用 控制台/文件输出: [INFO] 2017-01-17 17:01:17 [org.Demo] - 用户**访问了*** 数据库表 VISIT_LOG 插入了 values 记录。 1234567891011121314151617package org.Demo;public class Demo&#123; // 获取securityLog日志对象 private Logger logger = Logger.getLogger("securityLog"); public void log()&#123; // 字段 String fields = "ID, USER_ID, USER_NAME, RESOURCES_ID, VISIT_TIME"; StringBuffer values = new StringBuffer(); //...设置values值 MDC.put("tableName", "VISIT_LOG"); MDC.put("fields", fields); MDC.put("values", values.toString()); logger.info("用户**访问了***"); &#125;&#125; 附录PatternLayoutPatternLayout 是一个简单的 Layout 对象，提供了如下属性，该属性可通过配置文件更改： 序号 属性 &amp; 描述 1 conversionPattern设置转换模式，默认为 %r [%t] %p %c %x - %m%n。 模式转换字符下面的表格解释了上面模式中用到的字符，以及所有定制模式时能用到的字符： 转换字符 含义 c 输出日志对象名，一般为发起记录日志请求类的全名/自设置的日志对象名。比如对于类 org.apache.xyz.SomeClass ，模式 %C{1} 会输出 SomeClass 。也有可能是自定义日志对象名，比如 log4j.logger.securityLog = INFO 为 securityLog 。 d 输出记录日志的日期，比如 %d{HH:mm:ss,SSS} 或 %d{dd MMM yyyy HH:mm:ss,SSS} 。 F 在记录日志时，使用它输出文件名。 l 输出生成日志的调用者的地域信息。 L 输出发起日志请求的行号。 m 输出和日志事件关联的，由应用提供的信息。 M 输出发起日志请求的方法名。 n 输出平台相关的换行符。 p 输出日志事件的优先级。 r 输出从构建布局到生成日志事件所花费的时间，以毫秒为单位。 t 输出生成日志事件的线程名。 x 输出和生成日志事件线程相关的 NDC (嵌套诊断上下文)。 X 该字符后跟 MDC 键，比如 X{clientIP} 会输出保存在 MDC 中键 clientIP 对应的值。 % 百分号， %% 会输出一个 % 。 格式修饰符缺省情况下，信息保持原样输出。但是借助格式修饰符的帮助，就可调整最小列宽、最大列宽以及对齐。 下面的表格涵盖了各种修饰符： 格式修饰符 左对齐 最小宽度 最大宽度 注释 %20c 否 20 无 如果列名少于 20 个字符，左边使用空格补齐。 %-20c 是 20 无 如果列名少于 20 个字符，右边使用空格补齐。 %.30c 不适用 无 30 如果列名长于 30 个字符，从开头剪除。 %20.30c 否 20 30 如果列名少于 20 个字符，左边使用空格补齐，如果列名长于 30 个字符，从开头剪除。 %-20.30c 是 20 30 如果列名少于 20 个字符，右边使用空格补齐，如果列名长于 30 个字符，从开头剪除。]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>LOG</tag>
        <tag>SL4J</tag>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java之枚举]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B5%85%E8%B0%88Java%E4%B9%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[使用关键字 enum 可以定义枚举类型，枚举类型可以包含一组序列集，可以作为常规的程序组件使用。当我们需要从固定的序列中获取值时，使用枚举类型是一个很好的方式。 基本特性尽管 enum 看起来像是一个新的数据类型，但是这个关键字只是为 enum 生成对应的类时，产生某些编译器行为。 可以将 enum 当做其他任何类来处理。 创建 enum 时，编译器会自动生成一个对应的类，这个类会继承 java.lang.Enum 。 由此可知，枚举类型具有以下 特性 ： enum 不能再继承。 enum 可以使用 Enum类 的方法。 enum 除了不能继承以外，基本可以看做一个常规的类。 除此之外，枚举类型还具有以下 特性 ： enum 也不能被继承。 enum 内可以定义一些序列，这些值实际上enum实例，默认是 public static final 。 enum 需要提供和实例声明对应的构造函数，enum构造函数默认是 private 。 123public enum SimpleEnum &#123; SUCCESS, WARNING, ERROR;&#125; 继承于 Enum的方法 说明 ordinal() 返回 enum实例 在声明时的次序。 name() 返回 enum实例 在声明时的名字。 toString() 默认与 name() 相同。 getDeclaringClass() 获取 enum实例 所属的类类型。 1234567System.out.println(SimpleEnum.SUCCESS.ordinal());System.out.println(SimpleEnum.SUCCESS == SimpleEnum.SUCCESS);System.out.println(SimpleEnum.WARNING.name());System.out.println(SimpleEnum.WARNING.toString());System.out.println(SimpleEnum.ERROR.getDeclaringClass()); 123450trueWARNINGWARNINGclass org.demo.enumdemo.SimpleEnum 与 name() 方法对应，也可以通过枚举的名字获取枚举类型。 方法 说明 valueOf(Class&lt;T&gt; enumType, String name) 通过枚举的名字获取枚举类型，可被继承的 static 方法。 valueOf(String name) 通过枚举的名字获取枚举类型，由编译器添加。 1234System.out.println(Enum.valueOf(SimpleEnum.class, "ERROR") == SimpleEnum.ERROR);System.out.println(SimpleEnum.valueOf(SimpleEnum.class, "ERROR") == SimpleEnum.ERROR);System.out.println(SimpleEnum.valueOf("ERROR") == SimpleEnum.ERROR); 123truetruetrue 添加属性和方法一般枚举会用来定义数据字典，为了增加可用性，我们可以向枚举类型中添加属性和方法。 12345678910111213141516171819public enum DictCode &#123; SUCCESS("0", "成功"), WARNING("1", "警告"), ERROR("2", "错误"); private String code; private String codeName; DictCode(String code, String codeName) &#123; this.code = code; this.codeName = codeName; &#125; // getter and setter ...&#125; 需要注意的是： 向枚举中添加属性和方法后，实例声明一定要使用 ; 结尾。 虽然当enum中只有实例时可以省略 ; 的 ，但不推荐。 实例声明实际上会调用构造方法，故需要提供对应的构造方法。 解析 values()enum 提供了一个遍历的方法 values() 。 123for (DictCode item : DictCode.values()) &#123; System.out.println(item.name() + ": " + item.getCodeName() + "-" + item.getCode());&#125; 123SUCCESS: 成功-0WARNING: 警告-1ERROR: 错误-2 实际上， values() 是编译器添加的静态方法，而不是继承自Enum。 如果我们想遍历Enum可以使用 Class类 的 getEnumConstants() 方法。 因为该方法来自 Class类，故也可用在没枚举类型上，但会报空指针异常。 12345678Enum e = DictCode.SUCCESS;// Enum.values(); // Cannot resolve method 'values()'// e.values(); // Cannot resolve method 'values()'for (Enum enumConstant : e.getClass().getEnumConstants()) &#123; DictCode item = (DictCode) enumConstant; System.out.println(item.name() + ": " + item.getCodeName() + "-" + item.getCode());&#125; 123SUCCESS: 成功-0WARNING: 警告-1ERROR: 错误-2]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java之注解]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B5%85%E8%B0%88Java%E4%B9%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解 (又被称为 元数据 ) ，是 Java 提供的一种让我们可以为代码添加信息的一种方式。 元数据 : 中介数据，为描述数据的数据，主要是描述数据属性的信息。 通过注解可以有效的减少样板式代码 ，所以注解式开发是现在框架的主流趋势。除此之外，注解还可以进行类型检查 和 注释说明 等作用。 认识注解从 Class类 可以看出，对于 JVM 而言，注解是一种特殊的接口，并且所有的注解类型都继承了 Annotation接口 。 我们知道一些框架需要一些额外信息才能与源代码协同工作。以前一般是配置文件，现在更喜欢使用注解。因为源代码已经提供了一些有用的信息，例如类名，包名等，所以使用注解会有效的减少配置。 元注解元注解 : Java 中内置了一些元注解，元注解专职负责注释其他注解。 涉及 说明 @Target 目标，指注解的作用位置。 @Retention 保留期，指注解的生命周期。 @Inherited 继承，允许子类继承父类的该注解。只会继承作用在 ElementType.TYPE 的注解。 @Documented 文档，生成 javadoc 时会包含注解信息。 @Repeatable 可重复，表示可多次使用，JDK8新增。 @Target@Target : 表示注解的作用位置，需要设置元素类型集 ElementType[] 。 ElementType枚举值 说明 ElementType.TYPE 类，接口（包括注释类型）或枚举声明。 ElementType.FIELD 字段声明（包括枚举常量）。 ElementType.METHOD 方法声明。 ElementType.PARAMETER 正式参数声明。 ElementType.CONSTRUCTOR 构造函数声明。 ElementType.LOCAL_VARIABLE 局部变量声明。 ElementType.ANNOTATION_TYPE 注释类型声明。 ElementType.PACKAGE 包声明。 ElementType.TYPE_PARAMETER 输入参数声明， JDK8新增。 ElementType.TYPE_USE 使用一种类型， JDK8新增。 @Retention@Retention : 表示注解的生命周期，需要设置存活策略 RetentionPolicy 。 RetentionPolicy枚举值 说明 RetentionPolicy.SOURCE 只存在于源码，编译器将丢弃注释。 RetentionPolicy.CLASS 注释将由编译器*记录在类文件中，但在运行时不需要由VM保留。 这是默认的行为 。 RetentionPolicy.RUNTIME 注释将由编译器记录在类文件中，并且在运行时由VM保留，因此 可以反射性地读取它们 。 @Inherited@Inherited : 表示被修饰的注解作用于超类后，超类的子类会继承该注解。但只会继承作用在 ElementType.TYPE 的注解。 这种继承是隐蔽的，光从子类无法看出，但可以通过反射获取所继承注解。 @Documented@Documented : 表示在生成 javadoc 时，被修饰的注解会被包含在文档中。 @Repeatable@Repeatable : 表示被修饰的注解可多次使用，是 JDK8 新增的注解，例如 Spring 的 @Scheduled 可以设置多种定时策略。 注解分类按注解的生命周期分类： 按生命周期分类 说明 应用 源码注解 注解只在源码中存在，编译成 *.class 文件就不存在了。 编译时注解 注解在源码和 *.class 文件中都存在。 TODO一般用于编译期检查。 运行时注解 注解在运行阶段还会起作用，甚至会影响运行逻辑。 第三方技术喜欢用其实现功能逻辑。 按注解来源分类： 按来源分类 示例 JDK自带 @Override , @Deprecated , @SuppressWarnings 等 来自第三方的注解 @Service , @Autowired 等Spring常用注解。 自定义的注解 可以使用 @interface 等来创建自定义注解。 JDK注解这里介绍一下，日常开发时常会使用到的 JDK注解 。 注解是 JDK1.5 时添加的特性，JDK5只提供了这3个注解。 涉及 说明 @Override 覆盖，覆盖来自超类型（父类或接口）的方法。 @Deprecated 标识元素过时，使用处编译器会显示警告信息。 @SuppressWarnings 抑制编译器警告，可以制定警告集。例如 @SuppressWarnings(&quot;unchecked&quot;) 抑制未检查的警告。 @Override@Override : 可以使用它来表示覆盖超类型（父类或接口）的方法，它是一个源码注解。 实际上， @Override 是可选的，不写编译器不会报错，但使用在非继承来的方法上会报错。 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Deprecated@Deprecated : 标识元素过时，使用处编译器会显示警告信息，它是一个运行时注解。 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; @SuppressWarnings@SuppressWarnings : 抑制编译器警告，可以制定警告集，它是一个源码注解。 123456789101112/** * @jls 4.8 Raw Types * @jls 4.12.2 Variables of Reference Type * @jls 5.1.9 Unchecked Conversion * @jls 5.5.2 Checked Casts and Unchecked Casts * @jls 9.6.3.5 @SuppressWarnings */@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 这里仅列出几个常用的警告关键字，详情可以查看 JLS 。 抑制警告的关键字 用途 all 压制所有警告。 unchecked 禁止相对于未经检查的操作的警告。 cast 禁止相对于强制转换操作的警告。 rawtypes 在类params上使用泛型时，禁止相对于非特定类型的警告。 deprecation 禁止相对于弃用的警告。 使用注解除去 JDK 和 框架技术外，大多数时候需要 自定义注解 并 编写处理器来解析它们。 自定义注解基础语法 定义注解需要使用关键字 @interface ，其语法类似接口 ，但不允许继承。 注解中可以添加 元素 ，看起来十分像接口的方法。 注解类可以没有元素，没有元素的注解称为 标识注解 。 元素 的类型受限，只能使用 : 基本类型 , String , Class , enum , Annotation 和 以上类型的数组 。 不能使用基本类型的包装类型，但支持自动装箱。 虽然看上去像抽象方法，但 元素 是不允许有 入参 和 异常声明的。 元素 不能有不确定的值，即要么使用 default 设置默认值，要么使用时提供元素值。 默认值不允许使用 null ，为绕开这个约束，可以使用 空字符串 或 负数，来表示不存在。 约定俗成的规范 : 如果只有一个注解元素，则取名为 value() ，这样在使用时可以忽略成员名和赋值号 = 。 1234567891011@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String value(); // 可以用default指定默认值 int id() default 100;&#125; 自定义注解 @Description 注解可以作用于 类型 和 方法 上。 注解的元素赋值一般采用 元素名=元素值 的方式设置，符合约定俗称的规范除外。 1234567891011121314151617181920212223@Description(value="It's Person class annotation.", id=10 )public class Person &#123; private String name; private int age; @Description("It's Person method annotation.") public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; @Description 注解可以被继承，可以看出注解的继承是比较隐蔽的，无法直接看出。 1234567891011121314151617181920212223public class User extends Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Description("It's User method annotation.") public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 编写注解处理器如果没有用来读取注解的工具，那注解也不会比注释更有用。 使用 反射 可以获取 注解 提供的 元数据 。 从没有打印 getName:It&#39;s User method annotation. ，可以看出 @Inherited 只会继承作用在 ElementType.TYPE 的注解。 12345678910111213141516171819202122@Testpublic void test()&#123; Class clazz = User.class; boolean isExist = clazz.isAnnotationPresent(Description.class); if (isExist)&#123; Description d1 = (Description) clazz.getAnnotation(Description.class); System.out.println(d1.value()); // It's Person class annotation. &#125; Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; boolean isMExist = method.isAnnotationPresent(Description.class); if (isMExist)&#123; Description d2 = method.getAnnotation(Description.class); System.out.println(method.getName() + ":" + d2.value()); // getAge:It's User method annotation. &#125; &#125;&#125; 常见应用ORM这里用注解简单实现一个ORM框架的查询功能，类似于 Hibernate。 定义注解先定义两个注解，用于表示 数据表 和 字段 。 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 123456@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String value();&#125; 定义注解解析器定义一个工具类用于解析注解，并完成简单查询的 SQL 拼接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ORM &#123; private static final String SELECT = "SELECT"; private static final String FROM = "FROM"; private static final String WHERE = "WHERE"; private static final String SPLIT_BLANK = " "; private static final String EQUALS = "="; private static final String AND = "AND"; public static &lt;T&gt; String query(T obj) throws Exception &#123; StringBuilder sql = new StringBuilder(); Class clazz = obj.getClass(); Field[] fields = clazz.getDeclaredFields(); String BASE_COLUMN_LIST = Arrays.stream(fields) .filter(item -&gt; item.isAnnotationPresent(Column.class)) .map(item -&gt; item.getAnnotation(Column.class).value()) .collect(Collectors.joining(",")); String TABLE_NAME = ((Table) clazz.getAnnotation(Table.class)).value(); sql.append(SELECT).append(SPLIT_BLANK) .append(BASE_COLUMN_LIST).append(SPLIT_BLANK) .append(FROM).append(SPLIT_BLANK) .append(TABLE_NAME); StringBuilder condition = new StringBuilder(); for (Field field : fields) &#123; String fieldName = field.getAnnotation(Column.class).value(); PropertyDescriptor descriptor = new PropertyDescriptor(field.getName(), clazz); Method getter = descriptor.getReadMethod(); Object fieldValue = getter.invoke(obj); if (fieldValue == null || (fieldValue instanceof Integer &amp;&amp; fieldValue.equals(0))) &#123; continue; &#125; condition.append(AND).append(SPLIT_BLANK).append(fieldName).append(EQUALS); if (fieldValue instanceof String) &#123; condition.append("'").append((String) fieldValue).append("'"); &#125; else if (fieldValue instanceof Integer) &#123; condition.append((Integer) fieldValue); &#125; &#125; if (condition.length() &gt; 0) &#123; sql.append(SPLIT_BLANK).append(WHERE).append(SPLIT_BLANK).append(condition.substring(4)); &#125; return sql.toString(); &#125;&#125; 注解的使用将两个注解用于实体类上，形成对象和数据表的映射关系。 12345678910111213141516171819202122232425@Table("USER")public class Filter &#123; @Column("USER_NAME") private String userName; @Column("USER_AGE") private int userAge; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getUserAge() &#123; return userAge; &#125; public void setUserAge(int userAge) &#123; this.userAge = userAge; &#125;&#125; 如此这般，一个简单的动态的条件查询就完成了。 123456789@Testpublic void test() throws Exception &#123; Filter filter = new Filter(); filter.setUserName("张三"); filter.setUserAge(18); System.out.println(ORM.query(filter)); // SELECT USER_NAME,USER_AGE FROM USER WHERE USER_NAME='张三'AND USER_AGE=18&#125;]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java之RTTI与反射]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%B5%85%E8%B0%88Java%E4%B9%8BRTTI%E4%B8%8E%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射机制 是 Java 提供的一种让我们在运行时识别对象类型的方式。 通过反射可以进行更加动态的编程，这也正是框架技术十分喜欢使用的方式，了解反射后，也会对 Java 有更加深刻的认识。 RTTIRTTI（Run-Time Type Identification） : 运行时识别对象类型。 Java 提供了三种方式， 让我们可以在运行时识别一个对象的类型。 RTTI方式 说明 表现形式 传统的RTTI 假定在编译时已知道了所有的类型。 主要是类型转换，例如 主动强制类型转换 和 泛型的自动转换 等。 反射 在运行时发现和使用类的信息。 通过 Class类 和 reflect包 发现和使用类信息。 instanceof / isInstance java 关键字和Class 方法，可以判断对象是不是某个特定类型的实例。 比直接进行 Class 的 == 和 equal() 判断更好，保持了类型的概念，是考虑继承的。 传统RTTI 和 反射 的 真正区别 传统的 RTTI 是在编译时打开和检查 *.class 文件的； 反射机制中，编译时无法获得 *.class 文件，所以在运行时才打开和检查的。 认识反射JDK 提供了 Class类 和 java.lang.reflect包 来支持反射功能。 Class简单理解 Java 中万物皆对象，类本身也是 Class类 的对象。通过 Class类 可以获取类的相关信息，但有不仅限于类。 java 中只有两种不是面向对象的 基本数据类型：会有对应的封装类。 静态的成员：属于类，不面向对象。 深入了解 Class类 的实例表示 Java 应用运行时的类和接口。 enum 是一种类，注解 是一种接口。所有 数组 属于类。 基本类型 和 void 也有 类Class 的实例对象。 一般称 Class对象 为对应类的 类类型（class type） 或 字节码对象 。 *.java 文件编译后会生成字节码 *.class 文件，其在应用运行时，被第一次使用时才会被 JVM 动态加载。 获取方式任何类都可以获取 Class实例对象。Class的构造方法式私有的，但提供了 三种获取方式 ： 12345678910Foo foo1 = new Foo();// 1. 通过类获取。 类字面常量：可以看做，任何一个类都有一个隐含的静态成员变量class。Class c1 = Foo.class;// 2. 通过对象获取。已知该类的对象，通过getClass()方法。Class c2 = foo1.getClass();// 3. 通过类的全称获取。也称之为动态加载类 (throws ClassNotFoundException)。Class c3 = Class.forName("org.demo.reflect.Foo"); 任何类的类类型只有一个。 12System.out.println(c1 == c2 &amp;&amp; c2 == c3);// true 通过该对象也可以对应类的实例对象。 12// 需要有无参数的构造方法Foo foo2 = (Foo) c1.newInstance(); 获取类信息 类Class 的实例表示 Java 应用运行时的类和接口。 enum 是一种类，注解 是一种接口。所有 数组 属于类。 基本类型 和 void 也有 类Class 的实例对象。 12345678910111213Class c1 = Integer.class; Class c2 = Collection.class;Class c3 = ElementType.class;Class c4 = Override.class;Class c5 = int[].class;Class c6 = int.class;Class c7 = void.class;// 基本类型和对应包装类的类类型不相同，但和包装类型的标准字段相同。System.out.println(c1 == c6);// falseSystem.out.println(c6 == Integer.TYPE);// true 通过 类类型 可以获得对应类的相关信息。例如类名： 1234567System.out.println(c1.getSimpleName());// IntegerSystem.out.println(c2.getName());//java.util.CollectionSystem.out.println(c3.getName());// java.lang.annotation.ElementTypeSystem.out.println(c4.getName());// java.lang.OverrideSystem.out.println(c5.getName());// [ISystem.out.println(c6.getName());// intSystem.out.println(c7.getName());// void 这里列举一些常用的获取类信息的方法， Field 、 Method 和 Constructor 等会在之后着重说明。 Class 常用方法 说明 String getName() 获取完整类名，包括包名。 String getSimpleName() 获取简单类名，不包括报名。 Field[] getDeclaredFields() 获取所有该类自己声明的成员变量，不论访问权限。 Method[] getDeclaredMethods() 获取所有该类自己声明的方法，不论访问权限。 Constructor[] getDeclaredConstructors 获取所有该类自己声明的构造函数，不论访问权限。 Field : 字段Field类 : 通过 Field 可以获取和操作字段。 1234567891011121314public static void printFieldMessage(Object obj) &#123; Class clazz = obj.getClass(); // Field类: 成员变量也是对象 // getFields(): 所有public成员变量，包括由父类继承来的 // getDeclaredFields: 所有该类自己声明的成员变量，不论访问权限 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; Class fieldType = field.getType(); String fieldName = field.getName(); System.out.println(fieldType + " " + fieldName + ";"); &#125;&#125; 123456// 获取成员变量信息ClassUtil.printFieldMessage(1);// int MIN_VALUE;// int MAX_VALUE;// class java.lang.Class TYPE;// ... Method : 方法Method类 : 通过 Method 可以获取和操作方法。 12345678910111213141516171819202122232425public static void printClassMethodMessage(Object obj)&#123; // 获取类类型: JNI本地方法获取，通过c语言实现。 Class clazz = obj.getClass(); System.out.println("类的名称: " + clazz.getName()); // Method类：方法也是对象，一个方法对应一个Method对象 // getMethods(): 所有public方法，包括由父类继承来的 // getDeclaredMethods(): 所有该类自己声明的方法，不论访问权限 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; Class returnType = method.getReturnType(); String methodName = method.getName(); Class[] paramTypes = method.getParameterTypes(); String methodInfo = returnType.getName() + " " + methodName; methodInfo += "("; for (Class item : paramTypes) &#123; methodInfo += item.getName() + ","; &#125; methodInfo += ")"; System.out.println(methodInfo); &#125;&#125; 12345// 获取方法信息ClassUtil.printClassMethodMessage(Class.class);//类的名称: java.lang.Class//void checkPackageAccess(java.lang.ClassLoader,boolean,)//java.lang.Class forName(java.lang.String,) Constructor : 构造器Constructor类 : 通过 Constructor 可以获取和操作构造方法。 12345678910111213141516171819public static void printConstructMessage(Object obj)&#123; Class clazz = obj.getClass(); // Constructor 构造方法也是函数 // getFields(): 所有public成员变量，包括由父类继承来的 // getDeclaredFields: 所有该类自己声明的构造函数 Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor cs : constructors) &#123; String csName = cs.getName(); Class[] paramTypes = cs.getParameterTypes(); String csInfo = csName + "("; for (Class item : paramTypes) &#123; csInfo += item.getName() + ","; &#125; csInfo += ")"; System.out.println(csInfo); &#125;&#125; 12345// 构造方法信息ClassUtil.printConstructMessage("hello");// java.lang.String([B,int,int,)// java.lang.String([B,java.nio.charset.Charset,)// java.lang.String([B,java.lang.String,) 使用反射方法反射1234567891011121314public class Foo &#123; public void print()&#123; System.out.println("I'm Foo!"); &#125; public void print(String s1, String s2)&#123; System.out.println(s1 + " " + s2); &#125; public void print(Integer n1, Integer n2)&#123; System.out.println(n1 + " " + n2); &#125;&#125; 1234567891011Foo foo = new Foo();Class clazz = Foo.class;Method method1 = clazz.getMethod("print", String.class, String.class);method1.invoke(foo, "abc", "def");// abc defMethod method2 = clazz.getMethod("print", new Class[]&#123;Integer.class, Integer.class&#125;);method2.invoke(foo, 12, 21);// 12 21Method method3 = clazz.getDeclaredMethod("print");method3.invoke(foo);// I'm Foo! 字段反射反射字段可以让我们直接访问和操作字段，下面通过两个示例来看一下。 提供模拟数据： 常见的数据源 : xml , json 等文件。 12345Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("username", "张三");map.put("age", 10);map.put("birthdate", new Date());map.put("salary", new BigDecimal("123.321")); 直接反射反射会进行访问域检查，一般只能访问到 public 域，可以使用 setAccessible(true) 来跳过检查。 虽然不会有什么影响，但 一般还是不推荐使用这种方式 。 1234567891011121314151617Class clazz = User.class;Object obj = clazz.newInstance();Field[] fields = clazz.getDeclaredFields();for (Field field : fields) &#123; int mod = field.getModifiers(); if (Modifier.isStatic(mod) || Modifier.isFinal(mod)) &#123; continue; &#125; // 操作私有域：不进行访问域检查 field.setAccessible(true); field.set(obj, map.get(field.getName()));&#125;System.out.println(obj);// User&#123;username='张三', age=10, birthdate=Mon Mar 04 15:50:19 CST 2019, salary=123.321&#125; 反射Getter和Setter这里推荐使用 PropertyDescriptor ，通过它可以友好的使用 Getter 和 Setter 。 123456789101112Class clazz = User.class;Object obj = clazz.newInstance();Field[] fields = clazz.getDeclaredFields();for (Field field : fields) &#123; PropertyDescriptor pd = new PropertyDescriptor(field.getName(), clazz); Method wm = pd.getWriteMethod(); // 写方法 wm.invoke(obj, map.get(field.getName()));&#125;System.out.println(obj);// User&#123;username='张三', age=10, birthdate=Mon Mar 04 16:13:26 CST 2019, salary=123.321&#125; 构造反射反射无参构造器： 1234Class c1 = Foo.class;// 需要有无参数的构造方法Foo foo = (Foo) c1.newInstance(); 反射有参构造器： 123456Class clazz = User.class;Constructor constructor = clazz.getConstructor(new Class[]&#123;String.class, int.class&#125;);Object object = constructor.newInstance("Hello", 123);System.out.println(object);// User&#123;username='Hello', age=123, birthdate=null, salary=null&#125; 常见应用动态代理代理 是一种基础的设计模式，通过它可以有效的扩展对象的功能或做一些额外的操作。 JDK 提供了 java.lang.reflect.Proxy 类，其利用反射可以简单的完成动态代理。 通过 Proxy.newProxyInstance() 可以获得一个代理对象实例。通过参数列表等，可以轻松的看出， JDK 代理只能代理接口方法。 1234567891011121314151617181920@Test@SuppressWarnings("unchecked")public void test() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Class clazz = list.getClass(); List&lt;String&gt; proxyInstance = (List&lt;String&gt;) Proxy.newProxyInstance( clazz.getClassLoader(), clazz.getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(list, args); // 需要被代理的对象。 &#125; &#125;); proxyInstance.add("abc"); System.out.println(list); // [abc]&#125; Proxy.newProxyInstance() 12345678/** * 获取代理对象实例 * @param loader 类加载器 * @param interfaces 接口列表 * @param h 调用处理器 * @return 代理对象实例 */public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h); InvocationHandler 注意 : 因为要反射调用方法，所以 InvocationHandler 一定需要被代理的对象。 12345678910111213141516package java.lang.reflect;/** * 调用处理器(代理对象调用方法时，会由它处理) */public interface InvocationHandler &#123; /** * 代理对象调用方法时，实际会调用此方法。 * @param proxy 当前代理实例。 * @param method 代理的方法，其只会来自于被代理对象所实现的接口(或超接口)。 * @param args 方法入参。 * @return 方法返回值，其类型为被代理的方法决定不能改变。 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 动态加载 Class.forName(...) 方法又称之为 动态加载 。 静态加载 作用于编译期，而 动态加载 作用于运行期。 JVM在运行时才会去加载 *.class 文件，若找不到会 throw ClassNotFoundException 。 我们常会看到使用它来加载数据库驱动。 JDBCDriver 都要求自我注册 DriverManager.registerDriver(...) ，所以只要加载即可，不需要初始化。 1Class.forName("com.mysql.jdbc.Driver"); 绕过编译: 认识泛型反射方法作用于运行期，通过反射可以绕过泛型检查，说明编译后是去泛型化的。 实际上，编译会擦除泛型，这些容器持有对象时会将其都视为 Object 对象，取出时会进行类型转换。 123456789101112131415161718192021222324252627@Testpublic void test() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; List list1 = new ArrayList(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); list1.add(1d); list2.add("abc"); list3.add(1000); Class c1 = list1.getClass(); Class c2 = list2.getClass(); Class c3 = list3.getClass(); // 泛型不会影响类类型 System.out.println(c1 == c2 &amp;&amp; c2 == c3);//true Method method = c2.getMethod("add", Object.class); // 反射方法作用于运行期，通过反射可以绕过泛型检查，说明编译后是去泛型化的。 method.invoke(list2, 100); method.invoke(list3, "def"); System.out.println(list1);// [1.0] System.out.println(list2);// [abc, 100] System.out.println(list3);// [1000, def]&#125;]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RTTI</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈JDK8新特性]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%B5%85%E8%B0%88JDK8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java8（又称为 JDK8）是 Java 语言开发的一个重要版本，于2014年发布。 JDK8 可以说是里程碑式的版本，提供了很多的新功能，支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。 本文仅涉及编程开发中常用的特性 。 官网：JDK8新功能 函数式编程JDK8 提供了函数式编程支持，不再是单纯的面对对象。 函数编程语言 最重要的基础是λ演算（lambda calculus）。而λ演算的函数可以接受函数当作输入和输出。 JDK8 提供了一些特性来支持函数式编程：Lambda表达式 , 函数式接口 , 方法引用 等。 这三者具有紧密联系，需要结合理解。 默认方法 和 stream API 及 增强API 等则另行说明。 函数式接口 就是只有一个抽象方法的接口。 Lambda表达式 只能作用于 函数式接口 。 若 Lambda 表达式 表示的逻辑已经被抽取为方法， 方法引用 可以替换 Lambda表达式 ，简化代码。 Lambda 表达式Lambda Expressions : 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 Lambda表达式 主要用来定义行内执行的 函数式接口（只有一个抽象方法的接口）。 lambda表达式 又名：闭包 、 匿名方法 。 语法格式1234// 格式一(parameters) -&gt; expression // 格式二(parameters) -&gt;&#123; statements; &#125; 语法特征: 可选的参数类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但没有参数或多个参数需要定义圆括号。 可选的参数大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 基本语法特征示例： 12345678910111213141516171819202122232425262728293031323334package tk.gushizone.jdk8.lambda;import org.junit.Test;public class LambdaTest &#123; /** * 带返回值的lambda表达式：四则运算 */ @Test public void test()&#123; // 类型声明 MathOperation addition = (int a, int b) -&gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; // 大括号中的返回语句 MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;; // 没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; System.out.println("10 + 5 = " + LambdaTest.operate(10, 5, addition)); System.out.println("10 - 5 = " + LambdaTest.operate(10, 5, subtraction)); System.out.println("10 x 5 = " + LambdaTest.operate(10, 5, multiplication)); System.out.println("10 / 5 = " + LambdaTest.operate(10, 5, division)); &#125; interface MathOperation &#123; int operation(int a, int b); &#125; private static int operate(int a, int b, MathOperation mathOperation)&#123; return mathOperation.operation(a, b); &#125;&#125; 变量作用域123public interface Converter&lt;T1, T2&gt; &#123; void convert(int i);&#125; Lambda表达式 的局部变量具有隐性的 final 的语义。 可以不用声明为 final，但是必须不可被后面的代码修改。 123456int num = 1;Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));s.convert(2);// ERROR : Local variable num defined in an enclosing scope must be final or effectively finalnum = 5; 在 Lambda表达式 当中不允许声明一个与局部变量同名的参数或者局部变量。 1234String first = "";// ERROR : Variable 'first' is already defined in the scopeComparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); 方法引用Method references : 通过方法的名字来指向一个方法。可以理解为Lambda表达式的缩写。 用途 : 使用方法引用，替代 lambda 表达式 ，这样代码会更加简洁清晰。 要求 引用的方法需要与函数式接口具有一样的出参和入参； 类的普通无参方法才能被引用。 语法格式 数组也可以使用构造器方法引用，例如 : int[3]::new 。 引用类型 语法格式 构造器方法引用（调用默认构造器） Class::new 类静态方法引用 Class::method 类的普通无参方法才能被引用 Class::method 实例方法引用 instance::method 方法引用的语法格式示例： 12345678910111213141516171819202122class Car &#123; /** 创造 **/ public static Car create(Supplier&lt;Car&gt; supplier) &#123; return supplier.get(); &#125; /** 碰撞 **/ public static void collide(Car car) &#123; System.out.println("Collided " + car.toString()); &#125; /** 跟随 **/ public void follow( Car another) &#123; System.out.println(this.toString() + " Following the " + another.toString()); &#125; /** 修理 **/ public void repair() &#123; System.out.println("Repaired " + this.toString()); &#125;&#125; 1234567891011121314151617181920@Testpublic void test()&#123; // 1. 构造器方法引用(调用默认构造器) : Class::new，或 Class&lt;T&gt;::new Car car1 = Car.create( Car::new ); Car car2 = Car.create( Car::new ); Car car3 = Car.create( Car::new ); List&lt; Car &gt; cars = Arrays.asList( car1, car2, car3 ); // 2. 类静态方法引用 : Class::method cars.forEach( Car::collide ); // 3. 类的普通无参方法才能被引用 : Class::method cars.forEach( Car::repair ); // 4. 实例方法引用 : instance::method Car police = Car.create( Car::new ); cars.forEach( police::follow );&#125; 函数式接口functional interfaces : 仅有一个抽象方法的接口，可以有多个非抽象方法。 函数式接口可以包含Object的public方法（即使它们是抽象方法），因为任何一个函数式接口的实现，默认都继承了 Object 类，包含了来自 java.lang.Object 里对这些抽象方法的实现。 JDK8 引入了新注解 @FunctionalInterface ，用于函数式接口的编译级错误检查（非必须）。 用途 : 函数式接口可以被隐式转换为 lambda表达式 ，与 lambda 配合使用。 常用函数式接口使用 lambda表达式 就需要函数式接口，除了现有的函数式接口，JDK8还提供了 java.util.function包 ，其包含一些常用的函数式接口。 常用接口 说明 Function&lt;T,R&gt; 接受一个输入参数 T ，返回一个结果 R 。 Supplier&lt;T&gt; 无参数，返回一个结果 T 。 Consumer&lt;T&gt; 接受一个输入参数 T ，无返回结果。 自定义一个函数式接口与使用示例： 1234567891011121314/** * 函数式接口示例 * 该接口类似：Function * @FunctionalInterface jdk8 新增，用于函数式接口的编译级错误检查（非必须）。 */@FunctionalInterfacepublic interface FunctionInterfaceDemo&lt;T, R&gt; &#123; R get(T t); /** 函数式接口，仅有一个抽象方法，Object的public方法除外。 **/ boolean equals(Object obj);&#125; 1234567891011121314151617/** * 自定义类Function函数式接口 * 数组构造引用 */@Testpublic void test()&#123; FunctionInterfaceDemo&lt;Integer, int[]&gt; fid1 = (i) -&gt; new int[i]; int[] arr1 = fid1.get(5); System.out.println(arr1 + ":" + arr1.length); // 数组构造引用 FunctionInterfaceDemo&lt;Integer, int[]&gt; fid2 = int[]::new; int[] arr2 = fid2.get(5); System.out.println(arr2 + ":" + arr2.length); &#125; 默认方法Default methods : 允许将新功能添加到库的接口，并确保与为这些接口的旧版本编写的代码的二进制兼容性。 简单的说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。(🤣接口和抽象类都可以有实现方法了) 用途 : 解决接口的修改与现有的实现不兼容的问题。 JDK8 以前，接口是个双刃剑， 好处是面向抽象而不是面向具体编程， 缺陷是当需要修改接口时候，需要修改全部实现该接口的类。 1234567891011121314151617public interface Vehicle &#123; /** * 在接口中使用 default 就可以添加实现方法了 */ default void print()&#123; System.out.println("Vehicle：默认方法调用！"); &#125; /** * jdk8后，可以在接口中添加静态的实现方法（静态默认方法，🤣不能用default修饰） */ static void blowHorn()&#123; System.out.println("Vehicle：静态方法调用！"); &#125;&#125; 1234567public interface FourWheeler &#123; default void print()&#123; System.out.println("FourWheeler : 默认方法调用！"); &#125;&#125; 123456789101112public class Car implements Vehicle, FourWheeler &#123; @Override public void print()&#123; // 使用 super 来调用指定接口的默认方法： Vehicle.super.print(); FourWheeler.super.print(); Vehicle.blowHorn(); &#125;&#125; 123Vehicle：默认方法调用！FourWheeler : 默认方法调用！Vehicle：静态方法调用！ forEach 解析forEach 是经典的默认方法，是 jdk8 集合框架可使用的遍历方法（实现于Iterable接口）。 12345678910@Testpublic void test() &#123; List names = new ArrayList(); names.add("Google"); names.add("Runoob"); names.forEach(System.out::println); // names.forEach(item -&gt; System.out.println(item)); // 等同于以上的函数引用&#125; JDK8 在 Iterable接口 中新增了默认方法 forEach 。 其会遍历集合，并调用 Consumer接口 的 accept方法 。 123456default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; Consumer接口 是 jdk8新增的 函数式接口 。 其提供的接口方法是：一个入参，没有出参。 123456package java.util.function;@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; 这里 System.out::println 和 Consumer接口 有相同的出入参。 故，这里集合会遍历执行 相应逻辑，即遍历打印。 1names.forEach(System.out::println); Stream APIStream(流) : 一个来自数据源的元素队列并支持聚合操作。 元素 : 特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源 : 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。 聚合操作 : 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。和以前的Collection操作不同， Stream操作还有两个基础的特征： Pipelining : 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代 ： 以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。 得益于 默认方法 ， Stream方法 被整合到了 Collection接口 中。现在可以使用类似 SQL 方式操作元素集合，十分高效简洁。 Stream操作 的一般流程 : 转换为Stream -&gt; 中间操作 -&gt; 最终操作 。 经过 Stream 处理获取到的对象，都是经过深拷贝获取的新对象。 123456789List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abc", "", "jkl");List&lt;String&gt; filtered = strings.stream() .filter(string -&gt; !string.isEmpty()) .distinct() .collect(Collectors.toList());System.out.println(filtered);// [abc, bc, efg, jkl] Stream种类JDK8 中，集合接口提供了两种方法生成流。 涉及方法 说明 stream() 为集合创建串行流。 parallelStream() 为集合创建并行流，相当于多线程操作。 中间操作 涉及 说明 示例 filter(..) 筛选出元素。 .filter(String::isEmpty) 为筛选出所有空字符串。 map(..) 映射每个元素到对应的结果。 .map(i -&gt; i * i) 为获取获取对应的平方数。 sorted() / sorted(..) 排序（升序），通过 Comparable接口 判断。 .sorted(Comparator.reverseOrder()) 为降序，可传入 lambda表达式。 distinct() 通过 equals方法 判断。 - count() 统计个数。 - collect(..) 收集归约。一般为最终操作，配合 Collectors 使用。 .collect(Collectors.toList()) 为收集列表 reduce(..) 聚合归约。一般为最终操作，可以实现常见的计算。 .reduce(BigDecimal.ZERO, BigDecimal::add) 为累加求和。 最终操作常见的 最终操作 是 归约操作 ，即转换类型。 涉及 说明 示例 toArray() / toArray(..) 转换为数组。 .toArray(String[]::new) 12345678910111213141516@Testpublic void test()&#123; // 求最大值 3 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); Integer maxValue = list.stream().collect(Collectors.collectingAndThen(Collectors.maxBy((a, b) -&gt; a - b), Optional::get)); // 求最小值 1 Integer minValue = list.stream().collect(Collectors.collectingAndThen(Collectors.minBy((a, b) -&gt; a - b), Optional::get)); // 求和 6 Integer sumValue = list.stream().collect(Collectors.summingInt(item -&gt; item)); // 求平均值 2.0 Double avg = list.stream().collect(Collectors.averagingDouble(x -&gt; x));&#125; CollectorsCollectors 类实现了很多收集归约操作，例如将流转换成集合和聚合元素。 涉及 说明 示例 toList() / toSet() / toMap() / toCollection(..) 转换成集合。 Collectors.toCollection(HashSet::new) joining(..) 转换成字符串。 Collectors.joining(&quot;, &quot;) / Collectors.joining(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;) groupingBy(..) 分组，根据函数式接口的返回值分组。 Collectors.groupingBy(item -&gt; item.getAge() &gt;= 18) 类SQL操作利于 Stream 可以在 Java 中完成一些类似的 SQL 操作。 计算 1234567891011121314151617181920212223242526272829303132333435@Testpublic void test() &#123; List&lt;BigDecimal&gt; list = Arrays.asList(null, new BigDecimal("2.13"), new BigDecimal("1.1"), new BigDecimal("3.141")); // 去 null list = list.stream().filter(Objects::nonNull).collect(Collectors.toList()); // 求最大值 // BigDecimal maxValue = list.stream().collect(Collectors.collectingAndThen(Collectors.maxBy((a, b) -&gt; a.compareTo(b)), Optional::get)); BigDecimal maxValue = list.stream().reduce(BigDecimal.ZERO, BigDecimal::max); System.out.println("最大值: " + maxValue); // 求最小值 // BigDecimal minValue = list.stream().collect(Collectors.collectingAndThen(Collectors.minBy(BigDecimal::compareTo), Optional::get)); BigDecimal minValue = list.stream().reduce(BigDecimal.ZERO, BigDecimal::min); System.out.println("最小值: " + minValue); // 求和（其他运算类似） BigDecimal sumValue = list.stream().reduce(BigDecimal.ZERO, BigDecimal::add); System.out.println("和: " + sumValue); // 求平均值 （四舍五入，保留小数位） BigDecimal avg = list.stream().reduce(BigDecimal.ZERO, BigDecimal::add) .divide(BigDecimal.valueOf(list.size()), 6, RoundingMode.HALF_UP); System.out.println("平均值: " + avg); // 升序 List&lt;BigDecimal&gt; sortList = list.stream().sorted().collect(Collectors.toList()); System.out.println("ASC: " + sortList); // 降序 List&lt;BigDecimal&gt; revList = list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()); System.out.println("DESC: " + revList);&#125; 分组 1234567891011121314151617181920212223242526272829@Testpublic void test() &#123; List&lt;User&gt; userList = Arrays.asList(new User("张三", 18), new User("李四", 32), new User("王二", 16), new User("李五", 26), new User("王三", 17)); // 分组 : 根据姓氏 Map&lt;String, List&lt;User&gt;&gt; map1 = userList.stream() .collect(Collectors.groupingBy(item -&gt; item.getUsername().substring(0, 1))); System.out.println(map1); // 分组 : 根据是否成年 Map&lt;Boolean, List&lt;User&gt;&gt; map2 = userList.stream() .collect(Collectors.groupingBy(item -&gt; item.getAge() &gt; 18)); System.out.println(map2); // 分组 : 计数，根据是否成年 Map&lt;Boolean, Long&gt; map3 = userList.stream() .collect(Collectors.groupingBy(item -&gt; item.getAge() &gt; 18, Collectors.counting())); System.out.println(map3); // 分组 : 取出同姓中最年轻的人 Map&lt;String, User&gt; map4 = userList.stream() .collect(Collectors.groupingBy(item -&gt; item.getUsername().substring(0, 1), Collectors.collectingAndThen(Collectors.toList(), list -&gt; list.stream() .sorted(Comparator.comparingInt(User::getAge)) .collect(Collectors.toList()).get(0)))); System.out.println(map4);&#125; 1234567&#123;张=[User(username=张三, age=18, birthday=null, salary=null)], 王=[User(username=王二, age=16, birthday=null, salary=null), User(username=王三, age=17, birthday=null, salary=null)], 李=[User(username=李四, age=32, birthday=null, salary=null), User(username=李五, age=26, birthday=null, salary=null)]&#125;&#123;false=[User(username=张三, age=18, birthday=null, salary=null), User(username=王二, age=16, birthday=null, salary=null), User(username=王三, age=17, birthday=null, salary=null)], true=[User(username=李四, age=32, birthday=null, salary=null), User(username=李五, age=26, birthday=null, salary=null)]&#125;&#123;false=3, true=2&#125;&#123;张=User(username=张三, age=18, birthday=null, salary=null), 王=User(username=王二, age=16, birthday=null, salary=null), 李=User(username=李五, age=26, birthday=null, salary=null)&#125; 统计分析 : SummaryStatistics123456789101112131415161718/** * 统计 * 它们主要用于int、double、long等基本类型上， * 它们可以用来产生类似如下的统计结果。 * 另外，一些产生统计结果的收集器也非常有用。*/@Testpublic void test() &#123; List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println("列表中最大的数 : " + stats.getMax()); System.out.println("列表中最小的数 : " + stats.getMin()); System.out.println("所有数之和 : " + stats.getSum()); System.out.println("平均数 : " + stats.getAverage());&#125; 1234列表中最大的数 : 7列表中最小的数 : 2所有数之和 : 25平均数 : 3.5714285714285716 Date-Time APIJDK8 提供了 java.time包 来完善对日期和时间的处理，遵循 JSR310 规范， 其是建立在 Joda-Time 基础上的。 JDK8 之前，对于处理日期时间 API 相对糟糕，项目开发往往重度依赖第三方类库，如 Joda-Time 。 新的 API可以减轻工具类对第三方库的依赖，但不能替换旧的 API 。 JDK8之前的日期和时间处理 : java.util.Date : 承载日期和时间信息。 java.util.Calendar : 对日期和时间进行操作。 java.text.DateFormat : 格式化和分析日期和时间字符串。 下文皆以最常见的 SimpleDateFormat 为例说明。 槽点最多的 Java API : Date , Calendar , SimpleDateFormat 所有属性都是可变的。 1) 线程不安全 , 2) 重复计算时不能复用，只能新建对象。 Date , Calendar 操作不人性化，而且 Calendar API 是 IBM 捐的，所以设计不一致。 1) 月份都是从 0 开始。2) Date 年是从 1900 开始的。 123456LocalDate nowDate = LocalDate.now();System.out.println(nowDate); // 2019-05-14System.out.println(nowDate.getYear() + "-" + nowDate.getMonthValue() + "-" + nowDate.getDayOfMonth()); // 2019-5-14LocalDate customDate = LocalDate.of(9102, Month.JANUARY, 1);System.out.println(customDate); // 9102-01-01 新增 API这里这只列举部分常用的 API，其他会在功能性中补充。 涉及 说明 LocalDate LocalDate 是一个不可变的类，它表示日期，默认格式是 yyyy-MM-dd 。 LocalTime LocalTime 是一个不可变的类，它的实例代表可读格式的时间，默认格式是 hh:mm:ss.zzz 。 LocalDateTime LocalDateTime 是一个不可变的类，它表示一组日期-时间，默认格式是 yyyy-MM-ddTHH-mm-ss.zzz 。 LocalDate12345678910111213/** * LocalDate 是一个不可变的类，它表示日期，默认格式是 yyyy-MM-dd */@Testpublic void LocalDate() &#123; LocalDate nowDate = LocalDate.now(); System.out.println(nowDate); // 2019-05-14 System.out.println(nowDate.getYear() + "-" + nowDate.getMonthValue() + "-" + nowDate.getDayOfMonth()); // 2019-5-14 LocalDate customDate = LocalDate.of(9102, Month.JANUARY, 1); System.out.println(customDate); // 9102-01-01&#125; LocalTime12345678910111213/** * LocalTime 是一个不可变的类，它的实例代表可读格式的时间，默认格式是 hh:mm:ss.zzz */@Testpublic void LocalTime() &#123; LocalTime nowTime = LocalTime.now(); System.out.println(nowTime); // 11:14:47.718 System.out.println(nowTime.getHour() + ":" + nowTime.getMinute() + ":" + nowTime.getSecond()); // 11:18:32 LocalTime customTime = LocalTime.of(11, 2, 33); System.out.println(customTime);&#125; LocalDateTime12345678910111213141516/** * LocalDateTime 是一个不可变的类，它表示一组日期-时间，默认格式是 yyyy-MM-ddTHH-mm-ss.zzz */@Testpublic void LocalDateTime() &#123; LocalDateTime nowDateTime = LocalDateTime.now(); System.out.println(nowDateTime); // 2019-05-14T11:21:27.766 System.out.println(nowDateTime.getYear() + "-" + nowDateTime.getMonthValue() + "-" + nowDateTime.getDayOfMonth()); //2019-5-14 LocalDate customDate = LocalDate.of(9102, Month.JANUARY, 1); LocalTime customTime = LocalTime.of(11, 2, 33); LocalDateTime customDateTime = LocalDateTime.of(customDate, customTime); System.out.println(customDateTime); // 9102-01-01T11:02:33&#125; 格式化和解析JDK8 新增了 java.time.format.DateTimeFormatter 类，负责提供格式化信息。 1234567891011121314151617@Testpublic void formatAndParse() &#123; // format LocalDate date = LocalDate.now(); System.out.println(date.format(DateTimeFormatter.BASIC_ISO_DATE));// 20190514 System.out.println(date.format(DateTimeFormatter.ofPattern("yyyy-MM-dd")));// 2019-05-14 LocalTime time = LocalTime.now(); System.out.println(time.format(DateTimeFormatter.ofPattern("HH:mm:ss")));// 13:54:31 LocalDateTime dateTime = LocalDateTime.of(date, time); System.out.println(dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))); // 2019-05-14 13:54:31 // parse LocalDateTime dt = LocalDateTime.parse("2019-05-14 13:54:31", DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")); System.out.println(dt); // 2019-05-14T13:54:31&#125; 处理和分析新的 API 中内置了许多工具方法，可以分析和处理日期和时间。 注意 ：这些类都是不可变动的，处理后是返回一个新的对象。 12345678910111213141516171819202122232425262728@Testpublic void dealAndAnalyse()&#123; LocalDate today = LocalDate.now(); // 2019-05-14 System.out.println("当前是否是闰年: " + today.isLeapYear()); // 当前是否是闰年: false System.out.println(today.isAfter(LocalDate.of(9102,1,1))); // false // plus and minus : Day, Week, Month, Year System.out.println("一天后: " + today.plusDays(1)); // 一天后: 2019-05-15 System.out.println(today); // 2019-05-15 System.out.println("一天前: " + today.minusDays(1)); // 一天前: 2019-05-13 LocalDate dt = LocalDate.parse("2020-03-31", DateTimeFormatter.ofPattern("yyyy-MM-dd")); System.out.println(dt.minusMonths(1));// 2020-02-29 System.out.println(dt.minusYears(1).minusMonths(1));// 2019-02-28 // lastDayOfMonth, lastDayOfYear LocalDate lastDayOfYear = today.with(TemporalAdjusters.lastDayOfYear()); System.out.println(lastDayOfYear); // 2019-12-31 // 时间间隔 Period period = today.until(lastDayOfYear); System.out.println(period.getDays()); // 17 System.out.println(period.getMonths()); // 7 System.out.println(period.getYears()); // 0&#125; 支持旧 APIJDK8 新增了一个 java.time.Instant 类，借助它可以完成 旧API 和 新API 的相互转换。 12345678910@Testpublic void old2new()&#123; // Date,Calendar -&gt; Instant -&gt; LocalDateTime Instant timestamp1 = new Date().toInstant(); Instant ts1 = Calendar.getInstance().toInstant(); LocalDateTime dateTime1 = LocalDateTime.ofInstant(timestamp1, ZoneId.systemDefault()); LocalDate date1 = dateTime1.toLocalDate(); LocalTime time1 = dateTime1.toLocalTime();&#125; 123456789@Testpublic void new2old()&#123; // LocalDateTime,LocalDate -&gt; Instant -&gt; Date Instant timestamp2 = LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant(); Instant ts2 = LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant(); Date date2 = Date.from(timestamp2); Date d2 = Date.from(ts2); &#125;]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Thymeleaf之Layout]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%B5%85%E8%B0%88Thymeleaf%E4%B9%8BLayout%2F</url>
    <content type="text"><![CDATA[一般来说，网站会有一些共享的常见的页面组件，如页眉，页脚，菜单等，我们可以使用布局来共享它们， Thymeleaf 很好的支持了这种功能，不需要依赖其他布局引擎，例如： Apache Tiles 。 本文内容基于 Thymeleaf3.0 。 Thymeleaf : Template-Layout Thymeleaf Layout Thymeleaf Layout Dialect Thymeleaf 有两种主要的布局方式，各有优势，配合使用更佳。 布局方式 说明 优劣性 包含式布局(include style) Thymeleaf标准布局。通过在每个视图中直接嵌入公共页面组件代码来生成页面。 使用简单，但不利于维护。 分层式布局(hierarchical style) 由布局方言提供支持。模板通常使用父子关系创建，从一般的部分（布局）到具体的部分（子视图;例如页面内容） 模块化维护简单，但配置更复杂。 标准布局系统包含式布局★包含式布局 ，也称之为 标准布局 ，十分简单，先定义模板片段，再引用片段即可。 定义片段 定义片段需要使用 th:fragment ，片段只是 th:fragment 所在标签及子标签内容。所有片段都可以在一个文件中定义或在单独的文件中定义。 当前片段位于 classpath:templates/fragments/footer.html 。 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt; &lt;body&gt; &lt;p th:fragment="copyright"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 引用片段 引用片段语法： th:引用方式=&quot;~{templatename :: selector}&quot; 。 片段表达式（ ~{} ）是在 Thymeleaf 3.0 引入的，为向上兼容，引用片段时可以不使用 ~{} 包含。 语法 说明 引用方式 Thymeleaf 提供了三种 引用方式 。 片段模板名称（ templatename ） 可以是文件, this 或 没有关键字。 片段选择器（ selector ） 片段名称 或 标记选择器 。 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;body&gt; ... &lt;div th:insert="fragments/footer :: copyright"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 作用效果 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt; &lt;body&gt; ... &lt;div&gt; &lt;p&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 片段表达式片段表达式 可以将片段做对象使用，其有三种格式。 ~{templatename::selector} templatename : 模板名称，包含了相对模板根路径的位置。 selector : 标记选择器，可以只是片段名称，也可以使用完善的 标记选择器语法 。 由于标记选择器的强大，甚至可以使用 id选择器（ #id ）直接选择片段，而不需要 th:fragment 。 ~{templatename} 在 th:insert / th:replace 标签中使用必须由模板解析器解析。 ~{::selector} / ~{this::selector} 优先从当前模板查找片段，若没找到，会从模板根路径开始遍历查找匹配。 引用方式Thymeleaf 提供了三种片段引用方式。 片段引用方式 说明 th:insert 插入指定的片段到引用标签中。 th:replace 使用指定的片段替换引用的标签。 th:include 只插入片段内容（不包括标签）到引用标签中， v3.0后不推荐使用。 下面通过示例，感受一下三种方式的区别 定义片段，当前片段位于 classpath:templates/fragments/footer.html 。 123&lt;p th:fragment="copyright"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/p&gt; 使用三种方式引用片段。 1234567891011&lt;body&gt; ... &lt;div th:insert="fragments/footer :: copyright"&gt;&lt;/div&gt; &lt;div th:replace="fragments/footer :: copyright"&gt;&lt;/div&gt; &lt;div th:include="fragments/footer :: copyright"&gt;&lt;/div&gt;&lt;/body&gt; 三种引用方式的作用效果。 12345678910111213141516171819&lt;body&gt; ... &lt;div&gt; &lt;p&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;/div&gt; &lt;p&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/p&gt; &lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/div&gt;&lt;/body&gt; 更多特性Thymeleaf 模板布局还拥有很多特性和高级应用，这里列举了一些以供参考。 参数化片段 : 模板片段可以向函数一样传递参数。 灵活布局 : 参数化片段 + 片段表达式 = 灵活布局 。 布局继承 : 灵活布局的利用方案，理论上可以直接实现第三方的 布局方言 的分层布局功能。 布局方言布局方言 实际上是一个基于 Thymeleaf方言 的第三方扩展包，可以轻松的完成分层式布局。 Spring Boot 1.x 中包含了布局方言，但在 Spring Boot 2.x 中被移除。 123456&lt;!-- https://github.com/ultraq/thymeleaf-layout-dialect --&gt;&lt;dependency&gt; &lt;groupId&gt;nz.net.ultraq.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-layout-dialect&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt;&lt;/dependency&gt; 可以在页面中引入命名空间，使 IDE 更好的支持。 1&lt;html xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"&gt; 分层式布局★分层式布局需要使用 布局方言 （Layout Dialect）。 定义布局装饰器 可以定义一个通用的布局样式（父页面），使用 layout:fragment 定义布局片段（子页面占位符）。 当前片段位于 classpath:templates/layout/default.html 。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;!--/* 标准布局 可以和 布局方言 混合使用 */--&gt; &lt;div th:replace="fragments/header :: header"&gt;&lt;/div&gt; &lt;div class="container"&gt; &lt;!--/* 当前标签会被替换，类似th:replace */--&gt; &lt;div layout:fragment="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div th:replace="fragments/footer :: footer"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 引用装饰器 在需要被装饰的页面（子页面），使用 layout:decorate 引用装饰器，并使用 layout:fragment 设置布局片段的具体内容。 子页面并不是被简单的 th:replace ， &lt;head&gt;&lt;/head&gt; 的内容也会一并被合理带入。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~&#123;layout/default&#125;"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Springboot - thymeleaf&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div layout:fragment="content" title="布局成功"&gt; &lt;div&gt; ... 真实的内容 ... &lt;/div&gt; &lt;!--/* 在子页面依然可以使用布局 */--&gt; &lt;div data-th-insert="thymeleaf/common :: #commonT"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方言扩展布局方言 不仅提供了分层式布局方法，还扩展了标准布局的语法，可以直接替代标准布局方言。例如： layout:fragment , layout:include 等。具体参考 官方文档。]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
        <tag>Thymeleaf Layout</tag>
        <tag>Thymeleaf Layout Dialect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jackson: 全面的JSON处理工具]]></title>
    <url>%2F2019%2F01%2F28%2FJackson-%E5%85%A8%E9%9D%A2%E7%9A%84JSON%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[日常开发中常需要 Json 、 Java 、 Xml之间的互相转换，相关 数据处理工具（data-processing tools） 有很多，鉴于 Jackson 更加全面且操作简单，这里就介绍一下 Jaxckson 的简单用法。 注意 : jackson-dataformat-xml 是 Jackson 扩展组件，只提供了一些简单的方式操作 xml ，不适合作为操作 xml 的主力工具使用。 json相关： jackson-databind xml 相关：jackson-dataformat-xml 下面是一些主流的转换工具： 转换工具 说明 json-lib 老牌的转换工具，功能全面， 但第三方依赖多，效率低等，基本停止更新，不推荐使用 。 jackson 当前流行的工具，全面且操作简单。 fastjson alibaba 的产品，以快而闻名，操作简单，但 不支持 xml 。 JSONJackson 支持 对 JSON 的读写操作，以下是需要的 maven 依赖： 123456&lt;!-- https://github.com/FasterXML/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Jackson 提供了三种方式处理 JSON 三种方式并不是相互孤立的，可以相互配合使用。 处理方式 说明 适用场景 数据绑定 需要有对应的 Java类 来 支持 JSON 和 POJO 的互转，包括 JDK对象 和 自定义对象。 适用于数据绑定映射 树模型 以树模型来操作 JSON ，针对树节点操作，更加灵活。 适用于复杂的数据结构 流式API 最佳效率来处理 JSON ，和 树模型 一样良好，操作相对复杂。 适用于追求效率的工作 数据绑定数据绑定 处理方式极其简单，只需要的提供与 Json 相互对应的 Java类 就可以快速完成 java 与 Json 的相互转换。 但局限也是在此，需要场景明确数据结构。 POJO.java 12345678910111213141516public class User &#123; private String username; private int age; // getter and setter ... @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 数据绑定 需要 ObjectMapper 对象，该对象可以重用。该方式同样适用于 Map 和 List 。 123456789101112131415161718192021222324@Testpublic void test() &#123; User user = new User(); user.setUsername("Jack"); user.setAge(18); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // object to json String strJson = objectMapper.writeValueAsString(user); System.out.println(strJson); // &#123;"username":"Jack","age":18&#125; // json to object User obj = objectMapper.readValue(strJson, User.class); System.out.println(obj); // User&#123;username='Jack', age=18&#125; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 树模型树模型 引入了 JsonNode 对象，允许使用操作树节点的方式对 json 进行读写，并且利于遍历。 12345678910111213141516171819202122232425262728293031323334@Testpublic void test() &#123; ObjectMapper objectMapper = new ObjectMapper(); try &#123; // json wirte JsonNode rootNode1 = objectMapper.createObjectNode(); ((ObjectNode) rootNode1).put("username", "Jack"); ((ObjectNode) rootNode1).put("age", 18); String strJson = objectMapper.writeValueAsString(rootNode1); System.out.println(strJson); // &#123;"username":"Jack","age":18&#125; // json read JsonNode rootNode2 = objectMapper.readTree(strJson); System.out.println(rootNode2); // &#123;"username":"Jack","age":18&#125; // iter Iterator&lt;String&gt; fields = rootNode2.fieldNames(); while (fields.hasNext())&#123; String field = fields.next(); System.out.println(field + ":" + rootNode2.get(field)); &#125; // username:"Jack" // age:18 &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 当然此时如果不想使用 JsonNode 对象，可以使用如下方式转换为对应的 Java对象 。 1234// JsonNode to POJOUser obj = objectMapper.treeToValue(rootNode2, User.class);System.out.println(obj);// User&#123;username='Jack', age=18&#125; 流式API流式API 引入了 JsonParser 和 JsonGenerator 两个对象，JsonGenerator 负责写操作， JsonParser 负责读操作。 1234567891011121314151617181920212223242526272829303132/** * 流式写入：JsonGenerator */@Testpublic void test()&#123; StringWriter sw = new StringWriter(); JsonGenerator jsonGen = null; try &#123; jsonGen = new JsonFactory().createGenerator(sw); jsonGen.writeStartObject(); jsonGen.writeStringField("username", "Jack"); jsonGen.writeNumberField("age", 18); jsonGen.writeEndObject(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (jsonGen != null) &#123; try &#123; jsonGen.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // jsonGenerator close 后内容才会被写入 System.out.println(sw.toString()); // &#123;"username":"Jack","age":18,&#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * 流式读取：JsonParser */@Testpublic void test() &#123; String strJson = "&#123;\"age\":28,\"username\":\"Jack\"&#125;"; JsonParser jsonParser = null; try &#123; jsonParser = new JsonFactory().createParser(strJson); if (jsonParser.nextToken() != JsonToken.START_OBJECT) &#123; throw new IOException("解析失败：非JSON格式"); &#125; while (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123; String fieldname = jsonParser.getCurrentName(); if ("username".equals(fieldname))&#123; jsonParser.nextToken(); System.out.println(fieldname + ":" + jsonParser.getText()); // username:Jack &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (jsonParser != null) &#123; try &#123; jsonParser.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 由以上的代码，可以看出单纯的 流操作 比较繁杂，操作起来有些得不偿失。 正如之前所说，这三种方式并不是相互孤立的，可以相互配合使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 流式操作配合数据绑定 */@Testpublic void test() throws ParseException &#123; User user = new User(); user.setUsername("Jack"); user.setAge(19); // object to json JsonFactory jsonFactory = new JsonFactory(); JsonGenerator jsonGen = null; StringWriter sw = new StringWriter(); try &#123; jsonGen = jsonFactory.createGenerator(sw); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.writeValue(jsonGen, user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (jsonGen != null) &#123; try &#123; jsonGen.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println(sw.toString()); // &#123;"username":"Jack","age":19&#125; JsonParser jsonParser = null; // json to object try &#123; jsonParser = jsonFactory.createParser(sw.toString()); ObjectMapper objectMapper = new ObjectMapper(); User obj = objectMapper.readValue(sw.toString(), User.class); System.out.println(obj); // User&#123;username='Jack', age=19&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (jsonParser != null) &#123; try &#123; jsonParser.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JSON 与 XMLJackson 支持 对 XML 的简单读写操作，以下是需要的 maven 依赖： 123456&lt;!-- https://github.com/FasterXML/jackson-dataformat-xml --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 对 XML 的操作类似于 JSON，这里仅展示 JSON 与 XML 的互转。 12345678910111213141516171819202122232425262728293031323334@Testpublic void test() &#123; String userJson1 = "&#123;\"age\":28,\"username\":\"Jack\"&#125;"; ObjectMapper objectMapper = new ObjectMapper(); XmlMapper xmlMapper = new XmlMapper(); StringWriter sw = new StringWriter(); try &#123; // json to xml JsonNode root = objectMapper.readTree(userJson1); xmlMapper.enable(SerializationFeature.INDENT_OUTPUT); String xml = xmlMapper.writeValueAsString(root); System.out.println(xml); // &lt;ObjectNode&gt; // &lt;age&gt;28&lt;/age&gt; // &lt;username&gt;Jack&lt;/username&gt; // &lt;/ObjectNode&gt; // xml to json JsonParser jsonParser = xmlMapper.getFactory().createParser(xml); JsonGenerator jsonGenerator = objectMapper.getFactory().createGenerator(sw); while (jsonParser.nextToken() != null) &#123; jsonGenerator.copyCurrentEvent(jsonParser); &#125; jsonParser.close(); jsonGenerator.close(); System.out.println(sw.toString()); // &#123;"age":"28","username":"Jack"&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Jackson配置: FeatureJackson 预定义了一些配置，可以通过 configure方法 启用和禁用相关特性（ Feature ），在 Jackson2.5 又进行了细化，新添加了 enable方法 和 disable方法 ，两种方式都可以使用，但推荐后者。 1234567// 启用与禁用：缩进特性mapper.configure(SerializationFeature.INDENT_OUTPUT, true);mapper.configure(SerializationFeature.INDENT_OUTPUT, false);// Jackson2.5 后的等效方法mapper.enable(SerializationFeature.INDENT_OUTPUT);mapper.disable(SerializationFeature.INDENT_OUTPUT); 常用的配置这里列举了一些常用的配置，基本可以满足日常开发。 Jackson 的 Json解析 默认是严格按照 JSON标准 的，而 JavaScript 中的 json 并不严格按照这个标准的。 1234567891011121314// 支持单引号（兼容 js ）mapper.enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES);// 支持字段名不带引号（兼容 js ）mapper.enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);// 接收 "" 等同 nullmapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);// 时间类型正常输出（默认Date , Calendar会输出为数字，这里禁用）mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);// 遇到未知属性时不抛出异常mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);// null 属性不进行序列化mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); Jackson特性（ JacksonFeatures ）主要包含以下两种，并含有默认值。 数据绑定特性 : MapperFeature , SerializationFeature , DeserializationFeature 。 流式API特性：JsonFactory.Feature , JsonParser.Feature , JsonGenerator.Feature 。 类型格式化Jackson 对于不同的数据类型，实现不同的格式化，这里以 日期类型 为例说明。 默认行为默认序列化 日期类型默认序列化为时间戳（数值型），即 Java 中的日期类型 会默认转换为 JSON中的数值类型 : 距离 1970-01-01 08:00:00 的毫秒差。 默认反序列化 对于日期类型，Jackson 有默认的反序列化格式 StdDateFormat ，即 以下格式字符串 可以转换为 Java 中的日期类型。 JSON数值型 也可以被转换为 java日期类型 。 1234DATE_FORMAT_STR_ISO8601, // "yyyy-MM-dd'T'HH:mm:ss.SSSZ""yyyy-MM-dd'T'HH:mm:ss.SSS", // ISO-8601 but no timezoneDATE_FORMAT_STR_RFC1123, // "EEE, dd MMM yyyy HH:mm:ss zzz"DATE_FORMAT_STR_PLAIN //"yyyy-MM-dd" 自定义格式化： ModuleJackson 提供了功能扩展接口 Module（模块） ， 一般使用 SimpleModule 就可以了， 向其添加 序列化器 和 反序列化器 ，再 注册模块 。 这种方式会覆盖 StdDateFormat ，但是数值型还是可以被正常解析的。 123456// 定义扩展模块SimpleModule module = new SimpleModule();// 添加自定义序列化器module.addSerializer(Date.class, new DateSerializer(false, new SimpleDateFormat("yyyy-MM-dd")));// 注册扩展模块mapper.registerModule(module); 实际上，对于日期类型可以直接使用以下方式简单实现： 两种方式可以并存， module 的优先级更高，推荐使用 module 统一管理扩展。 12// 自定义 序列化格式 与 反序列化格式mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));]]></content>
      <categories>
        <category>① Starter</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>JSON</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Maven]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%B5%85%E8%B0%88Maven%2F</url>
    <content type="text"><![CDATA[Maven基于 项目对象模型（POM） ，是纯 Java 开发的开源项目，可以用于 构建和管理各种项目 。类似工具还有： Ant 、 gradle 。 官网： Apache Maven 公共仓库 https://search.maven.org/ https://mvnrepository.com/ https://maven.aliyun.com 构件 &amp; 仓库maven构件 : 在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。 maven仓库 : 存放项目构件的地方。 构件在 Maven 中，任何依赖（jar包，tomcat等），或项目（自己打包的jar,war等）输出都可成为构件。每个构件都有自己的唯一标识（唯一坐标），由 groupId ， artifactId ，和 version 三要素 构成。 构件要素 说明 groupId 必需，当前Maven构件隶属的项目名，一般为 反写的公司公司网址(+项目) 。 artifactId 必需，隶属项目中的模块名，一般为 项目名-模块名 。 version 必需，当前版本。 packaging 默认为 jar，打包方式：jar, war, ear, pom。 versionverison 一般命名格式为 大版本号.分支版本号.小版本号-版本类型 。 版本类型 说明 snapshot 快照版本 alpha 内部版本 beta 公测版本 release 稳定版本 GA 正式版本 packagingpackaging 表示打包种类如 : jar , war , ear 。 pom 表示当前 pom 为引用，一般用于父模块，详情如下： 打包方式 说明 jar Java Archive file，把开发时要引用通用(JAVA)类及资源做封装，打成包后便于存放管理。 war Web Archive file，一个(web)完整的应用，通常是网站或WEB平台，打成包部署到容器中。 ear Enterprise Archive file，企业级应用，实际上EAR包中包含WAR包和几个企业级项目的配置文件而已，服务器中间件通常选择WebSphere等都会使用EAR包。通常是EJB打成ear包。 仓库maven的仓库可以分为 本地仓库 和 远程仓库 两种。 运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。 本地仓库Maven在本地存储构件的地方。其在第一次执行maven命令的时才会被创建。 本地仓库的默认位置为用户的目录下 .m2/repository/。 修改 apache-maven-*\conf\settings.xml 可以更改默认的本地仓库位置。 123&lt;settings&gt; &lt;localRepository&gt;/developer/Repo/MavenRepo&lt;/localRepository&gt; &lt;/settings&gt; 远程仓库远程仓库中可以三种：中央仓库 , 私服 , 其它公共库 。 中央仓库 中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。 最核心的中央仓库是默认的远程仓库，maven在安装的时候，所有的maven项目都会继承超级pom，包含了中央仓库的配置，如下： 1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 私服 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。 当前主流的maven私服： Apache 的 Archiva JFrog 的 Artifactory Sonatype 的 Nexus 其他公共仓库 国外仓库速度较慢，可以国内的镜像仓库，在 settings.xml 的&lt;mirrors&gt;&lt;/mirrors&gt;中如下添加即可。 12345678&lt;!-- 使用阿里云的maven镜像仓库（保证速度稳定） --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;!-- 设置为中央仓库配置镜像 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 依赖管理依赖传递构件具有 依赖传递性 。例如：项目依赖构件A，而构件A又依赖B，Maven会将A和B都视为项目的依赖。 以下依赖范围的构件，不参与传递： provided , test , import 。 解析加载顺序 先 短路优先 ，后 声明优先 。 也可以在 pom.xml 中，使用 &lt;exclusions&gt;&lt;/exclusions&gt; 显式排除某个版本的依赖，以确保项目能够运行。 短路优先：项目声明依赖构件A和B，构件A → C → D(version:1.0.0)，构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.1.0)。 声明优先：项目声明依赖构件A和B，构件A → D(version:1.0.0)， 构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.0.0)。 依赖范围（scope）依赖范围（scope） : 编译期，运行期，测试期，分别对应Maven在项目构建过程中编译的三套 classpath 。而依赖范围，就是为构件指定它可以作用于哪套classpath。其可在 &lt;scope&gt;&lt;/scope&gt; 设置。 依赖范围 编译期 测试期 运行期 说明 compile ✓ ✓ ✓ 默认范围 provided ✓ ✓ 希望运行期由web容器提供依赖， 依赖不可传递 。如servlet-api.jar。 runtime ✓ ✓ 编译期无需直接引用，如jdbc驱动的实现。 test ✓ 只在测试目录下才可使用，主目录下回报错， 依赖不可传递 。如设置junit依赖范围。 system ✓ ✓ 必须通过 &lt;systemPath&gt;&lt;/systemPath&gt;元素，显示指定依赖文件的路径，与本地系统相关联，可移植性差。 import 导入依赖，它只使用在 dependencyManagement ，表示导入 此依赖pom 中的依赖，作用类似于 parent ， 依赖不可传递。 聚合 &amp; 继承聚合分层架构、分模块开发，可以提高代码的清晰和重用，在父模块使用&lt;modules&gt;&lt;/modules&gt; 即可聚合多个子模块。 构建父模块时，会自动构建所聚合的子模块。 12345&lt;modules&gt; &lt;module&gt;web&lt;/module&gt; &lt;module&gt;persistence&lt;/module&gt; &lt;module&gt;model&lt;/module&gt;&lt;/modules&gt; 同时需要 packaging 设置为 pom 。 1&lt;packaging&gt;pom&lt;/packaging&gt; 继承继承就是为了避免重复，maven的继承也是这样，它还有一个好处就是让项目更加安全。 在子模块中使用 &lt;parent&gt;&lt;/parent&gt; 即可继承父模块属性。 12345&lt;parent&gt; &lt;artifactId&gt;app-demo&lt;/artifactId&gt; &lt;groupId&gt;org.demo&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 模块化在模块化开发时，需要同时使用 聚合 和 继承。 父模块 123456789&lt;!-- 将packaging 改为 pom --&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;!-- 模块化 --&gt;&lt;modules&gt; &lt;module&gt;web&lt;/module&gt; &lt;module&gt;persistence&lt;/module&gt; &lt;module&gt;model&lt;/module&gt;&lt;/modules&gt; 子模块pom 12345&lt;parent&gt; &lt;artifactId&gt;first-app-demo&lt;/artifactId&gt; &lt;groupId&gt;org.demo&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 生命周期Maven有三个相互独立的标准的生命周期，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行。 涉及一览 说明 clean 项目清理的处理。 default（build） 项目部署的处理。 site 项目站点文档创建的处理。 Clean当执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段，并有相关命令对应。 mvn clean 就是下面的 clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于mvn pre-clean clean 。 clean生命周期 说明 pre-clean 执行实际项目清理之前所需的流程。 clean 删除之前构建生成的所有文件， target目录 等。 post-clean 执行完成项目清理所需的流程。 Default (Build)Default 是 Maven 的主要生命周期，被用于构建应用，包括的 23 个阶段，下面为简化的 7 个阶段： Default简化生命周期 说明 validate 检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。 compile 编译工程源码，生成 target目录 等。 test 自动运行测试用例并分析（如JUnit）。 package 获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。 verify 运行检查操作来验证工程包是有效的，并满足质量要求。 install 安装工程包到本地仓库中。 deploy 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。 Default 完整生命周期，包括了的 23 个阶段： Default完整生命周期 说明 validate 检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。 initialize 初始化构建状态，例如设置属性。 generate-sources 生成编译阶段需要包含的任何源码文件。 process-sources 处理源代码，例如，过滤任何值（filter any value）。 generate-resources 生成工程包中需要包含的资源文件。 process-resources 拷贝和处理资源文件到target目录中，为打包阶段做准备。 compile 编译工程源码。 process-classes 处理编译生成的文件，例如 Java Class 字节码的加强和优化。 generate-test-sources 生成编译阶段需要包含的任何测试源代码。 process-test-sources 处理测试源代码，例如，过滤任何值（filter any values)。 test-compile 编译测试源代码到测试target目录。 process-test-classes 处理测试代码文件编译后生成的文件。 test 使用适当的单元测试框架（例如JUnit）运行测试。 prepare-package 在真正打包之前，为准备打包执行任何必要的操作。 package 获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。 pre-integration-test 在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。 integration-test 处理和部署必须的工程包到集成测试能够运行的环境中。 post-integration-test 在集成测试被执行后执行必要的操作。例如，清理环境。 verify 运行检查操作来验证工程包是有效的，并满足质量要求。 install 安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。 deploy 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。 SiteMaven Site 插件一般用来创建新的报告文档、部署站点等。 site 生命周期 说明 pre-site 执行一些需要在生成站点文档之前完成的工作。 site 生成项目的站点文档。 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备。 site-deploy 将生成的站点文档部署到特定的服务器上。 POM元素解析pom.xml 是 maven 项目的配置文件。 因为 pom.xml 内的元素众多，为便于记忆，这里梳理了一些长常见的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- pom版本（模型版本）--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 构件坐标三要素 --&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;demo-maven&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!--打包类型，默认是jar，还有war/ear/pom--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 项目描述名 --&gt; &lt;name&gt;A Maven Project Demo&lt;/name&gt; &lt;!-- 项目地址 --&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 项目描述 --&gt; &lt;description&gt;A Maven Project Demo&lt;/description&gt; &lt;!-- 开发人员列表 --&gt; &lt;!--&lt;developers&gt;&lt;/developers&gt;--&gt; &lt;!-- 许可证 --&gt; &lt;!--&lt;licenses&gt;&lt;/licenses&gt;--&gt; &lt;!-- 组织信息 --&gt; &lt;!--&lt;organization&gt;&lt;/organization&gt;--&gt; &lt;!-- 属性列表: 提供公共变量值 --&gt; &lt;properties&gt; &lt;!-- 使用方式: $&#123;java.version&#125; --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!--依赖管理: 相当于提供了一些依赖的默认配置。 只有在依赖列表中引入了相关依赖，且没有提供相关配置时才会生效。 作用如：不显示提供版本号，用于依赖版本的统一管理。 --&gt; &lt;!--&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;--&gt; &lt;!--依赖列表--&gt; &lt;dependencies&gt;&lt;/dependencies&gt; &lt;!-- 项目构建相关 --&gt; &lt;build&gt; &lt;!-- 生成构件的命名，默认为$&#123;artifactId&#125;-$&#123;version&#125; --&gt; &lt;!--&lt;finalName&gt;MavenTest&lt;/finalName&gt;--&gt; &lt;!--插件列表--&gt; &lt;plugins&gt;&lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 变量除了可以在.&lt;properties /&gt; 自定义变量，Maven 也提供了一些内置变量。 内置变量 说明 ${project.xxx} 当前pom文件的任意节点的内容。 ${basedir} 项目根目录(即 pom.xml 文件所在目录)。 ${project.build.directory} 构建目录，缺省为 target 目录。 ${project.build.outputDirectory} 构建过程输出目录，缺省为 target/classes 。 ${project.build.finalName} 产出物名称，缺省为 ${project.artifactId}-${project.version} 。 ${project.packaging} 打包类型，缺省为jar。 ${env.xxx} 获取系统环境变量。例如, env.PATH 指代了 $path 环境变量（在Windows上是 %PATH% ）。 ${settings.xxx} 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt; 通过 ${settings.offline} 获得offline的值。 Java System Properties 所有可通过 java.lang.System.getProperties() 访问的属性都能在POM中使用，例如 ${JAVA_HOME} 。 dependenciesproject.dependencies 用于配置项目依赖。 详情参考 依赖管理 。 1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!-- 只在测试依赖范围内有用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--依赖是否可选，默认为false。设置为true表示依赖不会传递--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!--排除依赖传递列表--&gt; &lt;!--&lt;exclusions&gt;&lt;/exclusions&gt;--&gt;&lt;/dependency&gt; resourcesproject.build.resources 可以自定义项目资源文件的输出位置。 默认行为 &amp; 目录结构 12345678910111213.├── pom.xml├── src│ ├── main│ │ ├── java # compile结果会加入到classes (默认只处理 *.java)│ │ └── resources # compile后会被复制到classes│ └── test│ │ ├── java # test-compile结果会加入到test-classes (默认只处理 *.java)│ │ └── resources # test-compile后会被复制到classes└── target # 打包插件默认会将该目录的内容的加入包内 ├── classes ├── test-classes └── ... 自定义资源文件输出 如下示例，将 src/main/java 下的 *.xml 也有效输出。可以使用 targetPath 指定输出位置，如果只是希望是源目录位置，则不需要。 注意 : 经测试 ，一旦 resource 有效配置 ，原 maven 对 resources目录 的默认行为就会失效，所以又添加了如下的配置。 123456789101112&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;targetPath&gt;$&#123;project.build.outputDirectory&#125;&lt;/targetPath&gt; &lt;/resource&gt;&lt;/resources&gt; 环境隔离这里是以目录来区分环境， 将通用文件放入 resources ，环境文件放入对应目录，如： resources.dev 和 resources.prod 。 123456789101112131415161718192021222324252627282930&lt;!-- 配置 profiles ，指定默认为 dev --&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;deploy.type&gt;dev&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;deploy.type&gt;prod&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;build&gt; &lt;!-- 将资源文件输出到源目录位置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources.$&#123;deploy.type&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 动态指定 active在打包时也可以指定 profile ，命令优先级高于 xml 配置。 1$ mvn clean package -Dmaven.test.skip=true -Pprod 插件Maven插件 : maven 的所有工作都是由各种插件完成的，而 maven命令 会控制对应 maven插件 完成相应任务。 maven 自带了一些插件，在 pom.xml 中也可以配置自己需要的插件。 插件类型 配置位置 构建插件 &lt;build&gt;&lt;/build&gt; 报告插件 &lt;reporting&gt;&lt;/reporting&gt; archetypeArchetype插件 是一个 Maven 项目模板工具包，可以使用其来构建项目。输入以下命令后，会出现原型列表，一般选择 maven-archetype-webapp 即可。 -D 为定义所需参数，也可以直接使用 mvn archetype:generate 来构建，maven 会交互式询问所需参数。 123456# 回车键需要替换为空格mvn archetype:generate -DgroupId=组织名，反写网址名+项目名 -DartifactId=项目名/项目名-模块名 -Dversion=版本号 -Dpackage=包名（默认DgroupId） 默认目录骨架 以下是 maven 的默认目录结构精简版，部分需要自行完善。 手动创建以下目录结构也是可行的。 12345678910111213.├── src│ ├── main│ │ ├── java│ │ ├── resources│ │ │ └── application.properties│ │ └── webapp│ │ └── WEB-INF│ │ └── web.xml│ └── test│ └── java├── pom.xml└── target compilerCompiler插件 ： maven 具有自带的编译插件，即 mvn compiler 所用插件，它有默认值。因为多个项目所需的编译环境可能不同，所以推荐在 pom 中单独配置。 有时可能不会配置这个插件，而是通过修改 本地 maven 配置 或 IDE的 maven 配置 来避免错误，但这是不推荐的方式，不利于项目管理。 1234567891011&lt;!-- compiler：编译插件设置 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 如果直接在项目中加入了第三方包，一般会置于 src/main/webapp/WEB-INF/lib ，可以在 &lt;configuration /&gt; 中添加如下配置，确保编译正常。 123&lt;compilerArguments&gt; &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt;&lt;/compilerArguments&gt; sourceSource插件 可以将源代码进行打包，其中会包含 代码注释 等。 123456789101112131415161718&lt;!-- source：打包源代码插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;attach&gt;true&lt;/attach&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在对应生命周期（阶段）触发 --&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;!-- 目标为jar: http://maven.apache.org/plugins/maven-source-plugin/ --&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 相关常见问题snapshot 下载maven 默认不会下载 snapshot ，可以在 setting.xml 配置如下profile。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings&gt; &lt;!-- 私服 --&gt; &lt;localRepository&gt;/users/username/.m2/maven_repository&lt;/localRepository&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;xinheyun nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.1:8761/repository/maven-public/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.1:8761/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.1:8761/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- 配置生效 profile --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; 安装本地 jar这里以 Oracle驱动 为例，介绍一下如何将 jar 包到本地仓库。 因为版权问题，一般开源仓库不会拥有 Oracle 的驱动。 首先获取驱动 app\gushi\product\11.2.0\dbhome_1\jdbc\lib\ojdbc6.jar 。命令规则如下： 123456安装指定文件到本地仓库命令：mvn install:install-file-DgroupId=&lt;groupId&gt; : 设置项目代码的包名(一般用组织名)-DartifactId=&lt;artifactId&gt; : 设置项目名或模块名 -Dversion=1.0.0 : 版本号-Dpackaging=jar : 什么类型的文件(jar包)-Dfile=&lt;myfile.jar&gt; : 指定jar文件路径与文件名(同目录只需文件名) 解压 jar 包 可以确驱动版本，如 11.2.0.1.0 。 1$ mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.1.0 -Dpackaging=jar -Dfile=ojdbc6.jar BUILD SUCCESS 后，即可使用依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.1.0&lt;/version&gt;&lt;/dependency&gt; 打包跳过测试从 build 生命周期可以看出，默认 package 前，一定会执行 test 。可以使用以下命令跳过 ： 12# 推荐 - 不执行测试用例，也不编译测试用例类$ mvn package -Dmaven.test.skip=true 12# 不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下$ mvn package -DskipTests]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Git]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%B5%85%E8%B0%88Git%2F</url>
    <content type="text"><![CDATA[Git 是一个开源的分布式版本控制系统（VCS），也是个内容管理系统(CMS)，可以高效地处理各种项目。 官网： Git Pro Git 以下是 Git 的基本命令和对应操作内容的示意图： 域新建的一个 git项目，会在项目根目录下创建一个隐藏的 .git 目录，用于存放 git 所需信息。当我们变更项目文件时是不会直接作用于 git 的，需要相关命令才能触发相应操作。一般也将 .git 目录 称之为 版本库。 域 说明 Remote 远程仓库。 Repository 仓库区（或本地仓库），存于 .git 目录 。 Index / Stage 暂存区，即缓存，存于 .git/index 文件。 Workspace 工作区，可视的，直接操作的目录。 常用操作12# 查看帮助$ git help 操作命令 说明 git clone 克隆远程仓库到本地，包括了工作区和版本库 。 git pull 拉取远程仓库到本地，并合并。相当于 git fetch + git merge 。 git add 添加变动到暂存区。 git commit 提交变动到本地仓库。 git push 发布(publish)到远程仓库。 git checkout 切换分支。git checkout 前，确保已 git commit 。 git merge 合并分支。 git 的部分命令可能会调用 vim 文本编辑器，这里列举一些常用操作： vim 涉及 说明 / 输入字符即可查询。输入n 查看下一个匹配项。 i 切换光标为输入/替换模式，光标将变成竖线/下划线。 Esc 退出当前模式。 shift + : 进入底线命令模式。此时 q 为退出， w 为保存，! 为强制，可以叠加。 获取和初始化项目git init1234# 在当前目录新建一个Git代码库$ mkdir hellow-world$ cd hellow-world$ git init 12# 新建一个目录，将其初始化为Git代码库$ git init &lt;project-name&gt; git clone12# 下载项目和默认分支的代码历史$ git clone git@github.com:username/hello-world.git 基本快照Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。这里将对操作项目快照的命令作介绍。 git add1234567# 新建文件$ touch README.md# 添加指定目录到暂存区，包括子目录：$ git add &lt;dir&gt;# 添加指定文件到暂存区：$ git add &lt;file1&gt; [file2] ...# 添加当前目录的所有文件到暂存区$ git add . git status12# 显示有变更的文件状态（未commit的文件）$ git status git diff12# 显示暂存区与工作区的差异(只针对暂存区已存在的文件)$ git diff git commit12# 提交暂存区到仓库区$ git commit -m &lt;message&gt; 12# 使用一次新的commit，替代上一次提交$ git commit --amend -m &lt;message&gt; git reset123# 重置暂存区与工作区，与上一次commit保持一致# (工作区新增文件，且没有加入暂存区则不会变动)$ git reset --hard 12345# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset &lt;commit-hash&gt;# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard &lt;commit-hash&gt; git rm / git mv12# 删除工作区文件，并且将这次删除放入暂存区$ git rm &lt;file1&gt; [file2] ... 12# 重命名文件，并且将这个改名放入暂存区$ git mv &lt;source&gt; &lt;dest&gt; 共享和更新项目git remote 如果项目是 git clone 下来的会自带连接的远程仓库。 12# 为本地仓库设置远程仓库origin$ git remote add origin &lt;url&gt; git fetch12# 下载远程仓库的所有变动$ git fetch &lt;url&gt; git pull git pull 相当于 git fetch + git merge 。 12# 拉取远程仓库的变化，并与本地当前分支合并$ git pull git push HEAD 是一个游标，一般表示当前分支。 123456# 推送当前本地分支到远程仓库$ git push# 推送本地分支到远程仓库origin : $ git push -u origin &lt;branch-name&gt;# 推送当前本地分支到远程仓库origin$ git push -u origin HEAD 12345# 推送所有分支到远程仓库$ git push --all# 强行推送当前分支到远程仓库，即使有冲突$ git push --force 分支和合并使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 git branch12345678910# 列出所有远程分支：$ git branch -r# 列出所有本地分支和远程分支：$ git branch -a# 列出所有本地分支$ git branch# 新建一个分支，以当前分支和最新 commit 为基础$ git branch &lt;branch-name&gt;# 删除分支$ git branch -d &lt;branch-name&gt; 12# 新建一个分支，指向指定commit$ git branch &lt;branch-name&gt; [commit-hash] git checkoutgit checkout 是个很危险的命令，不管是切换分支或文件，请确保已 commit ，否则可能会丢失文件记录等。 当两个分支的最新 commit 的散列码不相同时，若存在未 commit 文件，cheout 时会失败并提示； 当两个分支的最新 commit 的散列码相同时，cheout 时，未 commit 的文件会带入当另一个分支中。 12345# 切换到指定分支，并更新工作区$ git checkout &lt;branch-name&gt;# 切换到上一个分支$ git checkout - 12# 新建一个分支，并切换到该分支$ git checkout -b &lt;branch-name&gt; git merge12# 合并指定分支到当前分支$ git merge &lt;branch-name&gt; git log12345678# 显示当前分支的commit历史$ git log# 历史记录的简洁的版本$ git log --oneline# 显示commit历史，以及变更的内容$ git log --stat 1234567# 展示当前版本树git log --graph# 展示所有版本树git log --graph --all# 显示指定文件相关的每一次diff$ git log -p &lt;file&gt; git tag如果你达到一个重要的阶段，并希望永远记住这个特别的提交快照，你可以使用 git tag 给它打上标签。 1234567# 仅添加标签：$ git tag &lt;tag-name&gt;# 添加标签，并要求注释$ git tag -a &lt;tag-name&gt;# 带tag的commit记录$ git log --decorate 常用开发方案 .gitignore在 .gitignore 文件中配置的文件不会被 Git 管理。 12345678910111213141516171819202122232425262728293031323334*.class# package file*.war*.ear# kdiff3 ignore*.orig# maven ignoretarget/# idea.idea//idea/*.ipr*.iml*.iws# eclipse ignore.settings/.project.classpatch# temp file*.log*.cache*.diff*.patch*.tmp# system ignore.DS_StoreThumbs.db 常见问题多账号配置一般个人和工作需要使用不同的 git 账号。这里使用不同的 ssh-key 来对应不同的 HostName 。 12345678$ ssh-keygen -t rsa -C "personal@mail.com"# 修改秘钥的文件名id_rsa_personalid_rsa_personal.pub$ ssh-keygen -t rsa -C "work@mail.com"id_rsa_workid_rsa_work.pub 因为修改了默认名称，所有需要手动添加秘钥。 避免每次重启后都需要手动添加（Mac） 自动操作(应用程序) -&gt; Shell脚本 -&gt; 添加以下命令 用户与群组 -&gt; 登录项添加 12345$ ssh-add ~/.ssh/id_rsa_personal$ ssh-add ~/.ssh/id_rsa_work# 验证$ ssh-add -l 在 ~/.ssh 下配置 config 文件 1234567891011Host githubHostName github.comPreferredAuthentications publickeyUser personalIdentityFile ~/.ssh/id_rsa_personalHost gitlabHostName gitlab.comPreferredAuthentications publickeyUser workIdentityFile ~/.ssh/id_rsa_work 测试配置是否成功 12$ ssh -T git@github.com$ ssh -T git@gitlab.com 12345678910# 取消全局用户名和邮箱$ git config --global --unset user.name$ git config --global --unset user.email# git仓库中分别设置$ git config user.name "personal"$ git config user.email "personal@mail.com"$ git config user.name "work"$ git config user.email "work@mail.com"]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[附录:Thymeleaf表达式实用程序对象]]></title>
    <url>%2F2018%2F12%2F26%2F%E9%99%84%E5%BD%95%E4%B9%8BThymeleaf%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[本文用于记录 Thymeleaf中的表达式实用程序对象，原文地址：附录B：表达式实用程序对象 。 执行信息 #execInfo：表达式对象，提供有关在Thymeleaf标准表达式中处理的模板的有用信息。 123456789101112131415161718192021222324252627282930313233343536373839404142/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.ExecutionInfo * ====================================================================== *//* * Return the name and mode of the 'leaf' template. This means the template * from where the events being processed were parsed. So if this piece of * code is not in the root template "A" but on a fragment being inserted * into "A" from another template called "B", this will return "B" as a * name, and B's mode as template mode. */$&#123;#execInfo.templateName&#125;$&#123;#execInfo.templateMode&#125;/* * Return the name and mode of the 'root' template. This means the template * that the template engine was originally asked to process. So if this * piece of code is not in the root template "A" but on a fragment being * inserted into "A" from another template called "B", this will still * return "A" and A's template mode. */$&#123;#execInfo.processedTemplateName&#125;$&#123;#execInfo.processedTemplateMode&#125;/* * Return the stacks (actually, List&lt;String&gt; or List&lt;TemplateMode&gt;) of * templates being processed. The first element will be the * 'processedTemplate' (the root one), the last one will be the 'leaf' * template, and in the middle all the fragments inserted in nested * manner to reach the leaf from the root will appear. */$&#123;#execInfo.templateNames&#125;$&#123;#execInfo.templateModes&#125;/* * Return the stack of templates being processed similarly (and in the * same order) to 'templateNames' and 'templateModes', but returning * a List&lt;TemplateData&gt; with the full template metadata. */$&#123;#execInfo.templateStack&#125; 消息 #messages：用于在变量表达式中获取外部化消息的实用程序方法，与使用#{...}语法获取它们的方式相同。 123456789101112131415161718192021222324252627282930313233/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Messages * ====================================================================== *//* * Obtain externalized messages. Can receive a single key, a key plus arguments, * or an array/list/set of keys (in which case it will return an array/list/set of * externalized messages). * If a message is not found, a default message (like '??msgKey??') is returned. */$&#123;#messages.msg('msgKey')&#125;$&#123;#messages.msg('msgKey', param1)&#125;$&#123;#messages.msg('msgKey', param1, param2)&#125;$&#123;#messages.msg('msgKey', param1, param2, param3)&#125;$&#123;#messages.msgWithParams('msgKey', new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsg(messageKeyArray)&#125;$&#123;#messages.listMsg(messageKeyList)&#125;$&#123;#messages.setMsg(messageKeySet)&#125;/* * Obtain externalized messages or null. Null is returned instead of a default * message if a message for the specified key is not found. */$&#123;#messages.msgOrNull('msgKey')&#125;$&#123;#messages.msgOrNull('msgKey', param1)&#125;$&#123;#messages.msgOrNull('msgKey', param1, param2)&#125;$&#123;#messages.msgOrNull('msgKey', param1, param2, param3)&#125;$&#123;#messages.msgOrNullWithParams('msgKey', new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsgOrNull(messageKeyArray)&#125;$&#123;#messages.listMsgOrNull(messageKeyList)&#125;$&#123;#messages.setMsgOrNull(messageKeySet)&#125; URI #uris：用于在Thymeleaf标准表达式中执行URI / URL操作（尤其是转义/转义）的实用程序对象。 12345678910111213141516171819202122232425262728293031323334353637/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Uris * ====================================================================== *//* * Escape/Unescape as a URI/URL path */$&#123;#uris.escapePath(uri)&#125;$&#123;#uris.escapePath(uri, encoding)&#125;$&#123;#uris.unescapePath(uri)&#125;$&#123;#uris.unescapePath(uri, encoding)&#125;/* * Escape/Unescape as a URI/URL path segment (between '/' symbols) */$&#123;#uris.escapePathSegment(uri)&#125;$&#123;#uris.escapePathSegment(uri, encoding)&#125;$&#123;#uris.unescapePathSegment(uri)&#125;$&#123;#uris.unescapePathSegment(uri, encoding)&#125;/* * Escape/Unescape as a Fragment Identifier (#frag) */$&#123;#uris.escapeFragmentId(uri)&#125;$&#123;#uris.escapeFragmentId(uri, encoding)&#125;$&#123;#uris.unescapeFragmentId(uri)&#125;$&#123;#uris.unescapeFragmentId(uri, encoding)&#125;/* * Escape/Unescape as a Query Parameter (?var=value) */$&#123;#uris.escapeQueryParam(uri)&#125;$&#123;#uris.escapeQueryParam(uri, encoding)&#125;$&#123;#uris.unescapeQueryParam(uri)&#125;$&#123;#uris.unescapeQueryParam(uri, encoding)&#125; 转换 #conversions：允许在模板的任何位置执行转换服务的实用程序对象： 123456789101112/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Conversions * ====================================================================== *//* * Execute the desired conversion of the 'object' value into the * specified class. */$&#123;#conversions.convert(object, 'java.util.TimeZone')&#125;$&#123;#conversions.convert(object, targetClass)&#125; 常用类型日期 #dates：java.util.Date对象的实用方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Dates * ====================================================================== *//* * Format date with the standard locale format * Also works with arrays, lists or sets */$&#123;#dates.format(date)&#125;$&#123;#dates.arrayFormat(datesArray)&#125;$&#123;#dates.listFormat(datesList)&#125;$&#123;#dates.setFormat(datesSet)&#125;/* * Format date with the ISO8601 format * Also works with arrays, lists or sets */$&#123;#dates.formatISO(date)&#125;$&#123;#dates.arrayFormatISO(datesArray)&#125;$&#123;#dates.listFormatISO(datesList)&#125;$&#123;#dates.setFormatISO(datesSet)&#125;/* * Format date with the specified pattern * Also works with arrays, lists or sets */$&#123;#dates.format(date, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')&#125;/* * Obtain date properties * Also works with arrays, lists or sets */$&#123;#dates.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#dates.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#dates.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#dates.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#dates.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#dates.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#dates.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#dates.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#dates.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#dates.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#dates.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#dates.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./* * Create date (java.util.Date) objects from its components */$&#123;#dates.create(year,month,day)&#125;$&#123;#dates.create(year,month,day,hour,minute)&#125;$&#123;#dates.create(year,month,day,hour,minute,second)&#125;$&#123;#dates.create(year,month,day,hour,minute,second,millisecond)&#125;/* * Create a date (java.util.Date) object for the current date and time */$&#123;#dates.createNow()&#125;$&#123;#dates.createNowForTimeZone()&#125;/* * Create a date (java.util.Date) object for the current date (time set to 00:00) */$&#123;#dates.createToday()&#125;$&#123;#dates.createTodayForTimeZone()&#125; 日历 #calendars：类似于#dates，但对于java.util.Calendar对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Calendars * ====================================================================== *//* * Format calendar with the standard locale format * Also works with arrays, lists or sets */$&#123;#calendars.format(cal)&#125;$&#123;#calendars.arrayFormat(calArray)&#125;$&#123;#calendars.listFormat(calList)&#125;$&#123;#calendars.setFormat(calSet)&#125;/* * Format calendar with the ISO8601 format * Also works with arrays, lists or sets */$&#123;#calendars.formatISO(cal)&#125;$&#123;#calendars.arrayFormatISO(calArray)&#125;$&#123;#calendars.listFormatISO(calList)&#125;$&#123;#calendars.setFormatISO(calSet)&#125;/* * Format calendar with the specified pattern * Also works with arrays, lists or sets */$&#123;#calendars.format(cal, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.arrayFormat(calArray, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.listFormat(calList, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.setFormat(calSet, 'dd/MMM/yyyy HH:mm')&#125;/* * Obtain calendar properties * Also works with arrays, lists or sets */$&#123;#calendars.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#calendars.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#calendars.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#calendars.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#calendars.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#calendars.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#calendars.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#calendars.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#calendars.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#calendars.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#calendars.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#calendars.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./* * Create calendar (java.util.Calendar) objects from its components */$&#123;#calendars.create(year,month,day)&#125;$&#123;#calendars.create(year,month,day,hour,minute)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second,millisecond)&#125;$&#123;#calendars.createForTimeZone(year,month,day,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,millisecond,timeZone)&#125;/* * Create a calendar (java.util.Calendar) object for the current date and time */$&#123;#calendars.createNow()&#125;$&#123;#calendars.createNowForTimeZone()&#125;/* * Create a calendar (java.util.Calendar) object for the current date (time set to 00:00) */$&#123;#calendars.createToday()&#125;$&#123;#calendars.createTodayForTimeZone()&#125; 数字 #numbers：数字对象的实用方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Numbers * ====================================================================== *//* * ========================== * Formatting integer numbers * ========================== *//* * Set minimum integer digits. * Also works with arrays, lists or sets */$&#123;#numbers.formatInteger(num,3)&#125;$&#123;#numbers.arrayFormatInteger(numArray,3)&#125;$&#123;#numbers.listFormatInteger(numList,3)&#125;$&#123;#numbers.setFormatInteger(numSet,3)&#125;/* * Set minimum integer digits and thousands separator: * 'POINT', 'COMMA', 'WHITESPACE', 'NONE' or 'DEFAULT' (by locale). * Also works with arrays, lists or sets */$&#123;#numbers.formatInteger(num,3,'POINT')&#125;$&#123;#numbers.arrayFormatInteger(numArray,3,'POINT')&#125;$&#123;#numbers.listFormatInteger(numList,3,'POINT')&#125;$&#123;#numbers.setFormatInteger(numSet,3,'POINT')&#125;/* * ========================== * Formatting decimal numbers * ========================== *//* * Set minimum integer digits and (exact) decimal digits. * Also works with arrays, lists or sets */$&#123;#numbers.formatDecimal(num,3,2)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2)&#125;$&#123;#numbers.listFormatDecimal(numList,3,2)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2)&#125;/* * Set minimum integer digits and (exact) decimal digits, and also decimal separator. * Also works with arrays, lists or sets */$&#123;#numbers.formatDecimal(num,3,2,'COMMA')&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2,'COMMA')&#125;$&#123;#numbers.listFormatDecimal(numList,3,2,'COMMA')&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2,'COMMA')&#125;/* * Set minimum integer digits and (exact) decimal digits, and also thousands and * decimal separator. * Also works with arrays, lists or sets */$&#123;#numbers.formatDecimal(num,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.listFormatDecimal(numList,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.setFormatDecimal(numSet,3,'POINT',2,'COMMA')&#125;/* * ===================== * Formatting currencies * ===================== */$&#123;#numbers.formatCurrency(num)&#125;$&#123;#numbers.arrayFormatCurrency(numArray)&#125;$&#123;#numbers.listFormatCurrency(numList)&#125;$&#123;#numbers.setFormatCurrency(numSet)&#125;/* * ====================== * Formatting percentages * ====================== */$&#123;#numbers.formatPercent(num)&#125;$&#123;#numbers.arrayFormatPercent(numArray)&#125;$&#123;#numbers.listFormatPercent(numList)&#125;$&#123;#numbers.setFormatPercent(numSet)&#125;/* * Set minimum integer digits and (exact) decimal digits. */$&#123;#numbers.formatPercent(num, 3, 2)&#125;$&#123;#numbers.arrayFormatPercent(numArray, 3, 2)&#125;$&#123;#numbers.listFormatPercent(numList, 3, 2)&#125;$&#123;#numbers.setFormatPercent(numSet, 3, 2)&#125;/* * =============== * Utility methods * =============== *//* * Create a sequence (array) of integer numbers going * from x to y */$&#123;#numbers.sequence(from,to)&#125;$&#123;#numbers.sequence(from,to,step)&#125; 字符串 #strings：String对象的实用方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Strings * ====================================================================== *//* * Null-safe toString() */$&#123;#strings.toString(obj)&#125; // also array*, list* and set*/* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets */$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;/* * Perform an 'isEmpty()' check on a string and return it if false, defaulting to * another specified string if true. * Also works with arrays, lists or sets */$&#123;#strings.defaultString(text,default)&#125;$&#123;#strings.arrayDefaultString(textArr,default)&#125;$&#123;#strings.listDefaultString(textList,default)&#125;$&#123;#strings.setDefaultString(textSet,default)&#125;/* * Check whether a fragment is contained in a String * Also works with arrays, lists or sets */$&#123;#strings.contains(name,'ez')&#125; // also array*, list* and set*$&#123;#strings.containsIgnoreCase(name,'ez')&#125; // also array*, list* and set*/* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */$&#123;#strings.startsWith(name,'Don')&#125; // also array*, list* and set*$&#123;#strings.endsWith(name,endingFragment)&#125; // also array*, list* and set*/* * Substring-related operations * Also works with arrays, lists or sets */$&#123;#strings.indexOf(name,frag)&#125; // also array*, list* and set*$&#123;#strings.substring(name,3,5)&#125; // also array*, list* and set*$&#123;#strings.substringAfter(name,prefix)&#125; // also array*, list* and set*$&#123;#strings.substringBefore(name,suffix)&#125; // also array*, list* and set*$&#123;#strings.replace(name,'las','ler')&#125; // also array*, list* and set*/* * Append and prepend * Also works with arrays, lists or sets */$&#123;#strings.prepend(str,prefix)&#125; // also array*, list* and set*$&#123;#strings.append(str,suffix)&#125; // also array*, list* and set*/* * Change case * Also works with arrays, lists or sets */$&#123;#strings.toUpperCase(name)&#125; // also array*, list* and set*$&#123;#strings.toLowerCase(name)&#125; // also array*, list* and set*/* * Split and join */$&#123;#strings.arrayJoin(namesArray,',')&#125;$&#123;#strings.listJoin(namesList,',')&#125;$&#123;#strings.setJoin(namesSet,',')&#125;$&#123;#strings.arraySplit(namesStr,',')&#125; // returns String[]$&#123;#strings.listSplit(namesStr,',')&#125; // returns List&lt;String&gt;$&#123;#strings.setSplit(namesStr,',')&#125; // returns Set&lt;String&gt;/* * Trim * Also works with arrays, lists or sets */$&#123;#strings.trim(str)&#125; // also array*, list* and set*/* * Compute length * Also works with arrays, lists or sets */$&#123;#strings.length(str)&#125; // also array*, list* and set*/* * Abbreviate text making it have a maximum size of n. If text is bigger, it * will be clipped and finished in "..." * Also works with arrays, lists or sets */$&#123;#strings.abbreviate(str,10)&#125; // also array*, list* and set*/* * Convert the first character to upper-case (and vice-versa) */$&#123;#strings.capitalize(str)&#125; // also array*, list* and set*$&#123;#strings.unCapitalize(str)&#125; // also array*, list* and set*/* * Convert the first character of every word to upper-case */$&#123;#strings.capitalizeWords(str)&#125; // also array*, list* and set*$&#123;#strings.capitalizeWords(str,delimiters)&#125; // also array*, list* and set*/* * Escape the string */$&#123;#strings.escapeXml(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJavaScript(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJavaScript(str)&#125; // also array*, list* and set*/* * Null-safe comparison and concatenation */$&#123;#strings.equals(first, second)&#125;$&#123;#strings.equalsIgnoreCase(first, second)&#125;$&#123;#strings.concat(values...)&#125;$&#123;#strings.concatReplaceNulls(nullValue, values...)&#125;/* * Random */$&#123;#strings.randomAlphanumeric(count)&#125; 对象 #objects：一般对象的实用程序方法 1234567891011121314/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Objects * ====================================================================== *//* * Return obj if it is not null, and default otherwise * Also works with arrays, lists or sets */$&#123;#objects.nullSafe(obj,default)&#125;$&#123;#objects.arrayNullSafe(objArray,default)&#125;$&#123;#objects.listNullSafe(objList,default)&#125;$&#123;#objects.setNullSafe(objSet,default)&#125; 布尔 #bools：布尔评估的实用程序方法 12345678910111213141516171819202122232425262728293031323334353637383940/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Bools * ====================================================================== *//* * Evaluate a condition in the same way that it would be evaluated in a th:if tag * (see conditional evaluation chapter afterwards). * Also works with arrays, lists or sets */$&#123;#bools.isTrue(obj)&#125;$&#123;#bools.arrayIsTrue(objArray)&#125;$&#123;#bools.listIsTrue(objList)&#125;$&#123;#bools.setIsTrue(objSet)&#125;/* * Evaluate with negation * Also works with arrays, lists or sets */$&#123;#bools.isFalse(cond)&#125;$&#123;#bools.arrayIsFalse(condArray)&#125;$&#123;#bools.listIsFalse(condList)&#125;$&#123;#bools.setIsFalse(condSet)&#125;/* * Evaluate and apply AND operator * Receive an array, a list or a set as parameter */$&#123;#bools.arrayAnd(condArray)&#125;$&#123;#bools.listAnd(condList)&#125;$&#123;#bools.setAnd(condSet)&#125;/* * Evaluate and apply OR operator * Receive an array, a list or a set as parameter */$&#123;#bools.arrayOr(condArray)&#125;$&#123;#bools.listOr(condList)&#125;$&#123;#bools.setOr(condSet)&#125; 集合类型数组 #arrays：数组的实用程序方法 123456789101112131415161718192021222324252627282930313233343536373839/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Arrays * ====================================================================== *//* * Converts to array, trying to infer array component class. * Note that if resulting array is empty, or if the elements * of the target object are not all of the same class, * this method will return Object[]. */$&#123;#arrays.toArray(object)&#125;/* * Convert to arrays of the specified component class. */$&#123;#arrays.toStringArray(object)&#125;$&#123;#arrays.toIntegerArray(object)&#125;$&#123;#arrays.toLongArray(object)&#125;$&#123;#arrays.toDoubleArray(object)&#125;$&#123;#arrays.toFloatArray(object)&#125;$&#123;#arrays.toBooleanArray(object)&#125;/* * Compute length */$&#123;#arrays.length(array)&#125;/* * Check whether array is empty */$&#123;#arrays.isEmpty(array)&#125;/* * Check if element or elements are contained in array */$&#123;#arrays.contains(array, element)&#125;$&#123;#arrays.containsAll(array, elements)&#125; List #lists：列表的实用程序方法 123456789101112131415161718192021222324252627282930313233/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Lists * ====================================================================== *//* * Converts to list */$&#123;#lists.toList(object)&#125;/* * Compute size */$&#123;#lists.size(list)&#125;/* * Check whether list is empty */$&#123;#lists.isEmpty(list)&#125;/* * Check if element or elements are contained in list */$&#123;#lists.contains(list, element)&#125;$&#123;#lists.containsAll(list, elements)&#125;/* * Sort a copy of the given list. The members of the list must implement * comparable or you must define a comparator. */$&#123;#lists.sort(list)&#125;$&#123;#lists.sort(list, comparator)&#125; Set #sets：集合的实用程序方法 1234567891011121314151617181920212223242526/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Sets * ====================================================================== *//* * Converts to set */$&#123;#sets.toSet(object)&#125;/* * Compute size */$&#123;#sets.size(set)&#125;/* * Check whether set is empty */$&#123;#sets.isEmpty(set)&#125;/* * Check if element or elements are contained in set */$&#123;#sets.contains(set, element)&#125;$&#123;#sets.containsAll(set, elements)&#125; Map #maps：地图的实用程序方法 1234567891011121314151617181920212223/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Maps * ====================================================================== *//* * Compute size */$&#123;#maps.size(map)&#125;/* * Check whether map is empty */$&#123;#maps.isEmpty(map)&#125;/* * Check if key/s or value/s are contained in maps */$&#123;#maps.containsKey(map, key)&#125;$&#123;#maps.containsAllKeys(map, keys)&#125;$&#123;#maps.containsValue(map, value)&#125;$&#123;#maps.containsAllValues(map, value)&#125; 集合操作 #aggregates：用于在数组或集合上创建聚合的实用程序方法 1234567891011121314151617/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Aggregates * ====================================================================== *//* * Compute sum. Returns null if array or collection is empty */$&#123;#aggregates.sum(array)&#125;$&#123;#aggregates.sum(collection)&#125;/* * Compute average. Returns null if array or collection is empty */$&#123;#aggregates.avg(array)&#125;$&#123;#aggregates.avg(collection)&#125; 标识 #ids：用于处理id可能重复的属性的实用程序方法（例如，作为迭代的结果）。 12345678910111213141516171819202122/* * ====================================================================== * See javadoc API for class org.thymeleaf.expression.Ids * ====================================================================== *//* * Normally used in th:id attributes, for appending a counter to the id attribute value * so that it remains unique even when involved in an iteration process. */$&#123;#ids.seq('someId')&#125;/* * Normally used in th:for attributes in &lt;label&gt; tags, so that these labels can refer to Ids * generated by means if the #ids.seq(...) function. * * Depending on whether the &lt;label&gt; goes before or after the element with the #ids.seq(...) * function, the "next" (label goes before "seq") or the "prev" function (label goes after * "seq") function should be called. */$&#123;#ids.next('someId')&#125;$&#123;#ids.prev('someId')&#125;]]></content>
      <categories>
        <category>⑤ 附录</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Thymeleaf]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%B5%85%E8%B0%88Thymeleaf%2F</url>
    <content type="text"><![CDATA[Thymeleaf 是一个跟 FreeMarker、Velocity 类似的模板引擎，是 Spring 所推荐的模板技术 。 Thymeleaf 引以为傲的特性是 自然模板（natural templating） ，即由于主要语法基于标签属性等，使得模板可以直接在静态环境显示正常。 本文内容基于 Thymeleaf3.0 。 Thymeleaf文档 使用Thymeleaf Thymeleaf+Spring 本文内容只基于 html模板 ，虽然Thymeleaf 提供了文本模板模式（Textual template modes），使其可以作用于 .js 和 .css ，但是这里不会涉及。 方言和属性修改器方言 Thymeleaf 集成包定义了一种 标准方言 （ SpringStandard Dialect ），其兼容了 Spring EL ，而 Spring EL 基本和 OGNL 相同，所以使用起来十分友好。 属性修改器 标准方言的多数处理器都是属性处理器，Thymeleaf 可以使用两种属性修改器语法 ： 属性修改器语法 说明 示例 th:* 命名空间语法。 &lt;input th:value=&quot;${username}&quot;&gt; data-{prefix}-{name} html5自定义属性语法。 &lt;input data-th-value=&quot;${username}&quot;&gt; 一般来说，使用这种语法是可以直接在浏览器打开的（浏览器会忽略不可识别的属性），所以 Thymeleaf 是 自然模板 。但实际上 th:* 并不符合 HTML5 规范，IDE还是会提示错误。可以使用引入以下 xmlns 命名空间定义： 1&lt;html xmlns:th="http://www.thymeleaf.org"&gt; 可以看出 data-th-* 相较 th:* 对 HTML5 更加友好，两种方式都适用HTML5的各种属性。 但实际上 data-th-* 只是对 th:* 的补充，官方示例推崇 th:* 语法。 其实还有另一种语法：{prefix}:{name} 或 {prefix}-{name} ，其可以指定自定义标签。 例如： 可以使用 th:block 或 th-block 元素，来表示自定义标签。 标准表达式语法在属性修改器中可以使用一些标准表达式是语法。 在大括号外面的数据由Thymeleaf来处理。而在大括号内写的，将由OGNL / SpringEL引擎负责。 涉及一览 说明 ${...} 变量表达式 *{...} 选择变量表达式 #{...} 消息表达式 @{...} URL 链接表达式 变量表达式通过 ${...} 可以从 context 中获取变量。 使用 . 或者 [] 访问属性，相当于调用 getter 。 123$&#123;person.father.name&#125;$&#123;person['father']['name']&#125; 对于 Map对象，如下使用，相当于 get(...) 。 123$&#123;countriesByCode.ES&#125;$&#123;personsByName['Stephen Zucchini'].age&#125; 对于 数组 或 集合 对象，可以使用索引访问。 1$&#123;personsArray[0].name&#125; 甚至可以直接调用方法。 123$&#123;person.createCompleteName()&#125;$&#123;person.createCompleteNameWithSeparator('-')&#125; 实用对象（Expression Utility）Thymeleaf内置了许多实用对象，这里使用内置工具类格式化日期类型。 附录B：表达式实用程序对象 123&lt;p&gt; Today is: &lt;span th:text="$&#123;#calendars.format(today,'yyyy-MM-dd')&#125;"&gt;13 May 2018&lt;/span&gt;&lt;/p&gt; 选择表达式*{...} 一般配合 th:object 使用，优先从其选定的对象中取值，当没有th:object 时，其作用等同${...}。 当多次从一个对象中获取属性时，可以如下使用： 1234&lt;div th:object="$&#123;session.user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 其等同于以下写法： 1234&lt;div&gt; &lt;p&gt;Name: &lt;span th:text="$&#123;session.user.firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="$&#123;session.user.lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 消息表达式使用 #{...} 可以直接使用消息（message），其一般用于国际化。 配置国际化文件 classpath:i18n/messages_zh_CN.properties 。 1home.welcome=欢迎来到我们的杂货店！ 在模板中使用消息。 1&lt;p th:utext="#&#123;home.welcome&#125;"&gt;Welcome to our grocery store!&lt;/p&gt; URL链接表达式使用 @{...} 可以用于处理 URL链接。 12// 服务器中的上下文名称将自动添加@&#123;/itemdetails&#125; 片段表达式使用 ~{...} 可以将模板片段作为变量使用，这个会在谈Thymeleaf 布局（ Layout ）时再介绍 。 标准表达式支持的语法字面（Literals） 其实这里是介绍支持的各种数据类型。 1234567891011121314151617181920&lt;!-- 文字 --&gt;&lt;p&gt; Now you are looking at a &lt;span th:text="'working web application'"&gt;template file&lt;/span&gt;.&lt;/p&gt;&lt;!-- 数字 --&gt;&lt;p&gt;The year is &lt;span th:text="2013"&gt;1492&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;In two years, it will be &lt;span th:text="2013 + 2"&gt;1494&lt;/span&gt;.&lt;/p&gt;&lt;!-- 布尔 --&gt;&lt;!-- Thymeleaf处理 --&gt;&lt;div th:if="$&#123;user.isAdmin()&#125; == false"&gt;&lt;!-- OGNL / SpringEL引擎处理 --&gt;&lt;div th:if="$&#123;user.isAdmin() == false&#125;"&gt;&lt;!-- null --&gt;&lt;div th:if="$&#123;variable.something&#125; == null"&gt;&lt;!-- Token --&gt;// TODO 文本操作（Text operations）转义文本 与 非转义文本th:text 会转义其中的内容，而 th:utext 则不会转义，这更使用于包含标签 的文本。 1home.welcome=Welcome to our &lt;b&gt;fantastic&lt;/b&gt; grocery store! 123&lt;p th:text="#&#123;home.welcome&#125;"&gt;Welcome to our grocery store!&lt;/p&gt;&lt;!-- 解析结果如下 --&gt;&lt;p&gt;Welcome to our &amp;lt;b&amp;gt;fantastic&amp;lt;/b&amp;gt; grocery store!&lt;/p&gt; 123&lt;p th:utext="#&#123;home.welcome&#125;"&gt;Welcome to our grocery store!&lt;/p&gt;&lt;!-- 解析结果如下 --&gt;&lt;p&gt;Welcome to our &lt;b&gt;fantastic&lt;/b&gt; grocery store!&lt;/p&gt; 附加文本（Appending texts）无论是 文字 还是 评估变量 或 消息表达式的结果 ，都可以使用 + 运算符轻松附加： 1&lt;span th:text="'The name of the user is ' + $&#123;user.name&#125;"&gt; 字面替换（Literal substitutions）当需要将变量值包含到字符串中，可以使用字面替换，而不是用 + 附加文本。 1&lt;span th:text="|Welcome to our application, $&#123;user.name&#125;!|"&gt; 运算算术运算一些算术运算也可用： + ， - ， * ， / ， % 。 1&lt;div th:with="isEven=($&#123;prodStat.count&#125; % 2 == 0)"&gt; 比较运算在标签语言中需要对 &lt; 和 &gt; 进行转义，而 Thymeleaf 还支持别名。 比较运算符 别名 &gt; gt &lt; lt &gt;= ge &lt;= le ! not == eq != neq / ne 1234&lt;div th:if="$&#123;prodStat.count&#125; gt 1"&gt;&lt;!-- 等同于 --&gt;&lt;div th:if="$&#123;prodStat.count&#125; &amp;gt; 1"&gt; 条件运算属性修改器中也可以使用三目运算符： condition ? then : else 。 else 可以省略，即 condition ? then ，若条件为 false ，则返回 null值。 123&lt;tr th:class="$&#123;row.first&#125;? 'first' : 'even'"&gt; ...&lt;/tr&gt; 默认值（Elvis运算符） Elvis运算符 类似 条件运算 的变种，可以在取值为 null 时，提供默认值。 1234&lt;p&gt;Age: &lt;span th:text="&#123;age&#125;?:'(no age specified)'"&gt;27&lt;/span&gt;.&lt;/p&gt;&lt;!-- 相当于 --&gt;&lt;p&gt;Age: &lt;span th:text="&#123;age != null&#125;? &#123;age&#125; : '(no age specified)'"&gt;27&lt;/span&gt;.&lt;/p&gt; 无操作令牌 希望原文本为默认值，可以使用 _ 代替。 1234&lt;span th:text="$&#123;user.name&#125; ?: _"&gt;no user authenticated&lt;/span&gt;&lt;!-- 相当于 --&gt;&lt;span th:text="$&#123;user.name&#125; ?: 'no user authenticated'"&gt;no user authenticated&lt;/span&gt; 迭代当需要对集合进行循环遍历是可以使用 th:each 。 不显示设置迭代状态变量，则默认为 迭代变量 + Stat ，即 prodStat 。 12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 可以显示设置迭代状态变量 iterStat ，如下可以控制奇数行样式。 12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="item, iterStat : $&#123;list&#125;" th:class="$&#123;iterStat.odd&#125;? 'odd'"&gt; &lt;td th:text="$&#123;item.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;item.price&#125;"&gt;2.41&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 迭代状态变量 状态变量在 th:each 属性中定义，包含以下数据。 迭代变量属性 说明 index 当前迭代索引，从0开始。 count 当前迭代索引，从1开始。 size 迭代变量中元素的总量。 current 每次迭代的iter变量。 even / odd 当前迭代是否是偶数、奇数，布尔属性。 first 当前迭代是否是第一个迭代。 last 当前迭代是否是最后一次。 条件 注意： 条件不仅判断 布尔值，还有如下扩展。 如果value不为null，且为以下值则视为 true ，反之视为 false。 如果value是布尔值，且为true。 如果value是数字且不为零。 如果value是一个字符且不为零。 如果value是String并且不是“false”，“off”或“no”。 如果value不是布尔值，数字，字符或字符串。 如果value为null，则th：if将计算为 false 。 th:if 12&lt;a href="comments.html" th:if="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt; th:unless th:unless 意为除非，与 if 相反， 比使用 not 更加友好。 123456&lt;a href="comments.html" th:unless="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;&lt;!-- 等同于 --&gt;&lt;a href="comments.html" th:if="$&#123;not #lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt; 注释可以看出在注释方面，Thymeleaf 也具有很小的侵入性，完美融入HTML。 涉及一览 说明 &lt;!-- -- &gt; hmtl注释 &lt;!--/* */-- &gt; 解析器级注释 &lt;!--/*/ /*/-- &gt; 原型注释 标准HTML / XML注释Thymeleaf 兼容 html注释，其内容不会被解析。 1234&lt;!-- User info follows --&gt;&lt;div th:text="$&#123;...&#125;"&gt; ...&lt;/div&gt; 解析器级注释在解析的，直接删除 &lt;!--/* */-- &gt; 及其中内容。 1&lt;!--/* This code will be removed at Thymeleaf parsing time! */--&gt; 原型注释在解析完成后，删除 &lt;!--/*/ /*/-- &gt; ，释放其中内容。 12345&lt;!--/*/ &lt;div th:text="$&#123;...&#125;"&gt; ... &lt;/div&gt;/*/--&gt; 元素处理器Thymeleaf标准方言中包含了唯一的元素处理器（不是属性），即th:block。 th:block是一个纯粹的属性容器，允许模板开发人员指定他们想要的任何属性。Thymeleaf将执行这些属性，然后简单地使块，而不使它的内容消失。 因此，在创建 &lt;tr&gt; 每个元素需要多个迭代表时，它可能很有用，且当与仅原型注释块结合使用时尤其有用： 1234567891011&lt;table&gt; &lt;!--/*/ &lt;th:block th:each="user : $&#123;users&#125;"&gt; /*/--&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;!--/*/ &lt;/th:block&gt; /*/--&gt;&lt;/table&gt; 内联在 html模板中，不直接基于标签，而将 Thymeleaf 融入到到 html ，javaScript ， css 中。 涉及一览 说明 [[]] 转义表达式 [()] 非转义表达式 /*[[]]*/ 自然模板 HTML 内联表达内联 但在某些情况下我们可能更喜欢将表达式直接写入HTML文本，这是可以使用内联表达式 [[]] 或 [()] 。 注意 ：虽然看上去会更简洁，但 Thymeleaf表达式 会直接展示在静态环境中，不利于原型设计。 1234&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;&lt;!-- 等同于 --&gt;&lt;p&gt;Hello, &lt;span th:text="$&#123;session.user.name&#125;"&gt;Sebastian&lt;/span&gt;!&lt;/p&gt; 1234&lt;p&gt;Hello, [($&#123;session.user.name&#125;)]!&lt;/p&gt;&lt;!-- 等同于 --&gt;&lt;p&gt;Hello, &lt;span th:utext="$&#123;session.user.name&#125;"&gt;Sebastian&lt;/span&gt;!&lt;/p&gt; 禁用内联 可以看出 [[]] 标记会被 Thymeleaf 解析，在某些情况下并不好，这时可以使用 th:inline=&quot;none&quot; 禁用此机制。 1&lt;p th:inline="none"&gt;A double array looks like this: [[1, 2, 3], [4, 5]]!&lt;/p&gt; JavaScript 内联JavaScript内联中也支持 [[]] 和 [()] ，但都不能确保取值一定是合适的合法的 js变量 ，所以推荐使用 自然模板 ，即 /*[[]]*/ 。自然模板也支持默认值，所以对静态环境更加友好。 必须使用 th:inline=&quot;javascript&quot; 以下方式明确启用JavaScript 内联模式： 123456&lt;script th:inline="javascript"&gt; ... var username1 = /*[[$&#123;session.user.name&#125;]]*/ ; var username2 = /*[[$&#123;session.user.name&#125;]]*/ "Gertrud Kiwifruit"; ...&lt;/script&gt; CSS 内联CSS内联中同样支持 [[]] 和 [()] ，但更推荐自然模板 /*[[]]*/ 。 必须使用 th:inline=&quot;css&quot; 以下方式明确启用css内联模式： 12345&lt;style th:inline="css"&gt; .main\ elems &#123; text-align: /*[[$&#123;align&#125;]]*/ left; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Oracle之SQL中的函数与表达式]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%B5%85%E8%B0%88Oracle%E4%B9%8BSQL%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[针对 Oracle，本文会谈一谈，在 sql 中常会使用到的函数和表达式，适当的使用它们，可以提高开发效率和质量。 本文示例均使用 oracle 自带的示例表。 涉及一览 说明 CASE... WHEN... 类似于 IF/ELSE 。 WITH... AS 相当于创建临时表，适用于需要重复处理一类数据 NVL() / NVL2() NULL 处理，此时类似 IF/ELSE 。 DECODE() 值处理，此时类似 IF/ELSE 。 TRUNC() 时间截取函数。 TO_CHAR() / TO_DATE() 日期类型和字符串类型转换。 ROW_NUMBER() OVER 组内排序，并给出排序的编号。 LISTAGG(...) WITHIN GROUP(...) 列值拼接，一般配合分组使用。 START WITH...CONNECT BY PRIOR... 对树结构递归查询。 常用函数和表达式CASE... WHEN...类似于 IF/ELSE 12345678910111213141516171819-- 方式一select empno as 工号, (CASE ename WHEN 'SMITH' THEN '史密斯' WHEN 'ALLEN' THEN '艾伦' ELSE ename END) as 姓名from emp;-- 方式二select empno as 工号, (CASE WHEN ename='SMITH' THEN '史密斯' WHEN ename='ALLEN' THEN '艾伦' ELSE ename END) as 姓名from emp; WITH... AS相当于创建临时表，当需要重复处理一类数据时，可以起到优化作用。 12345678with a as (select * from emp where hiredate &gt; date'1981-01-01' and job = 'MANAGER'), b as (select * from emp where hiredate &lt; date'1981-06-01' and job = 'SALESMAN')select * from a where ename like '%A%' and ename not like '%B%'union allselect * from a where ename like '%B%' and ename not like '%A%'union allselect * from b DECODE()值处理，可以达到 IF/ELSE 的作用。 DECODE(value, if1, then1, if2,then2, . . . else ) 1234select empno as 工号, DECODE(ename, 'SMITH', '史密斯', 'ALLEN', '艾伦', ename) as 姓名from emp; NVL()NULL 处理，可以达到 IF/ELSE 的作用。 示例 说明 NVL(v1, v2) 若v1为null时，取v2, 否则取本身v1 NVL2(v1, v2, v3) 若v1为null时，取v3, 否则取v2 TRUNC()类似截取函数，按照指定的格式截取输入的数据。 12-- date 时间格式，fmt 日期格式。语法格式：trunc(date [, 'fmt']) SYSDATE ：系统时间。 示例 2018/3/19 14:31:13 结果 说明 select trunc(sysdate, &#39;dd&#39;) from dual 2018/03/20 返回当前时间：天 select trunc(sysdate, &#39;hh24&#39;) from dual 2018/3/20 14:00:00 返回当前时间：小时 select trunc(sysdate) from dual 2018/03/20 返回当前时间 select trunc(sysdate, &#39;yy&#39;) from dual 2018/01/01 返回当年第一天 select trunc(sysdate, &#39;mm&#39;) from dual 2018/03/01 返回当月的第一天 select trunc(sysdate, &#39;d&#39;) from dual 2018/03/19 返回当前信息的第一天 select trunc(sysdate, &#39;mi&#39;) from dual 2018/3/19 14:31:00 返回当前时间：分钟 TO_CHAR() / TO_DATE()这里仅说明 日期类型 和 字符串类型 的相互转换。 示例 2018/3/19 14:31:13 结果 select to_char( sysdate, &#39;YYYY-MM-DD&#39;) from dual 2018/3/19 select to_date(&#39;2018/3/19&#39;, &#39;YYYY-MM-DD&#39;) from dual 2018/3/19 12-- sql 调试时，可以直接使用以下方式。select date'2018-03-19' from dual; ROW_NUMBER() OVER12-- 将表按照a字段进行分组，之后按照b字段进行组内排序，并给出排序的编号。ROW_NUMBER() OVER (PARTITION BY a ORDER BY b) 根据工作进行分组，并按薪资进行降序排名。 123select empno,ename,job,sal, ROW_NUMBER() OVER(PARTITION BY job order by sal desc) as job_rankfrom emp 12345678910111213141516 EMPNO ENAME JOB SAL JOB_RANK---------- ---------- --------- ---------- ---------- 7902 FORD ANALYST 3000 1 7788 SCOTT ANALYST 3000 2 7934 MILLER CLERK 1300 1 7876 ADAMS CLERK 1100 2 7900 JAMES CLERK 950 3 7369 SMITH CLERK 800 4 7566 JONES MANAGER 2975 1 7698 BLAKE MANAGER 2850 2 7782 CLARK MANAGER 2450 3 7839 KING PRESIDENT 5000 1 7499 ALLEN SALESMAN 1600 1 7844 TURNER SALESMAN 1500 2 7654 MARTIN SALESMAN 1250 3 7521 WARD SALESMAN 1250 4 LISTAGG(...) WITHIN GROUP(...)列值拼接，根据 sal 排序。 123select listagg(ename, ',') within group(order by sal) as namefrom emp; 123NAME--------------------------------------------------------------------------------SMITH,JAMES,ADAMS,MARTIN,WARD,MILLER,TURNER,ALLEN,CLARK,BLAKE,JONES,FORD,SCOTT,KING 一般配合分组使用。 列举各部门的员工，并按工资排序。 12345select deptno, listagg(ename, ',') within group(order by sal) as namefrom empgroup by deptno; 12345DEPTNO NAME------- ---------------------------------------10 MILLER,CLARK,KING20 SMITH,ADAMS,JONES,FORD,SCOTT30 JAMES,MARTIN,WARD,TURNER,ALLEN,BLAKE START WITH...CONNECT BY PRIOR...对树结构的递归查询。 123456SELECT * FROM T-- 开始条件（父节点为空）START WITH p_id is null-- 连接条件：向prior跟随的节点类型方向遍历（向子节点方向递归遍历）CONNECT BY PRIOR id = p_id-- 等同 CONNECT BY p_id = PRIOR id 相关常见问题NULL问题字段处理当字段为 null 时，希望特殊处理可以使用函数： NVL() , DECODE() , CASE...WHEN... 。 排序处理当字段为 null 时，默认的排序可能不是我们希望的，此时可以特殊处理。 oracle 中默认排序时，当字段值为 null ，desc 时，null 会在最前面，asc 会在最后面。 字段处理，排除干扰 NVL() , DECODE() , CASE...WHEN... 。 nulls last / nulls first 1select * from emp order by sal desc nulls last; 日期问题时间重叠 不重叠的条件: t.endTime &lt; &#39;参数开始时间&#39; : 当前开始时间 大于 历史结束时间。 t.betginTime &gt; &#39;参数结束时间&#39; : 当前结束时间 小于 历史开始时间。 12-- 获得时间重叠的数据(验证时间是否重叠)select ... from table t where ... and not ( t.betginTime &gt; '参数结束时间' or t.endTime &lt; '参数开始时间' ) sequenceOracle 中没有自增主键，此时可以使用 sequence 代替。 123DROP SEQUENCE TAX_SEQUENCE;CREATE SEQUENCE TAX_SEQUENCE INCREMENT BY 1 START WITH 100000 MAXVALUE 100000000 MINVALUE 1 NOCYCLECACHE 20 NOORDER; 使用方式 1234-- 直接使用，可以直接在 SQL 中使用。TAX_SEQUENCE.NEXTVAL-- 间接使用，例如提供给 Java 程序。select TAX_SEQUENCE.NEXTVAL from dual 判断字段值是否为数字将数字字符转变为空格，再去空格，为空的则表示原字段值为纯数字字符组成。 12-- 字段值为数字select * from table where trim(translate(column,'0123456789',' ')) is NULL;]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈SpringMVC之注解]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%B5%85%E8%B0%88SpringMVC%E4%B9%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文介绍一下在 Spring MVC 中常会使用的注解。 @Controller &amp; @RequestMapping@Controller@Controller 作用于类， Controller 负责处理从 DispatcherServlet 分发的请求。 需要注意的是 @Controller 实际是 说明性注解 ，几乎等同于 @Component ，会被 Spring 识别为 bean ，需要配合 @RequestMapping 才能成为真正处理请求的处理器。 @RequestMapping@RequestMapping 注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上，作用于 Controller 类或方法。 属性 说明 value 指定请求的实际地址，指定的地址可以是 URI Template 模式。 method 指定请求的method类型， GET / POST / PUT / DELETE 等。 consumes 指定处理请求的提交内容类型（Content-Type），例如： application/json , text/html 。 produces 指定返回的内容类型，仅当 request 请求头中的( Accept )类型中包含该指定类型才返回。 params 指定 request 中必须包含某些参数值是，才让该方法处理。 headers 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。 @RequestParam &amp; @PathVariable两个都是作用于 Controller 方法参数，用于参数绑定。 注解 说明 @RequestParam 主要用于接受普通的请求参数，非必需。 @PathVariable 取出 URI 模板中的变量作为参数，主要用于处理 RESTful 风格的请求。 @RequestParam 1http://localhost:8080/Demo/list?userId=123 12345@RequestMapping(value = "/list", method = RequestMethod.GET)public String toUpload(@RequestParam String userId, Model model)&#123; model.addAttribute("userId", userId); return "upload";&#125; @PathVariable 1http://localhost:8080/Demo/list/123 12345@RequestMapping(value = "/list/&#123;userId&#125;", method = RequestMethod.GET)public String toUpload(@PathVariable String userId, Model model)&#123; model.addAttribute("userId", userId); return "upload";&#125; @RequestBody &amp; @ResponseBody 注解 说明 @RequestBody 用于 Controller 的方法参数 ，从 Request 对象的 Body 数据区中取出数据。一般用于解析字符串类型的 Json 信息。 @ResponseBody 用于 Controller 的方法 ，将返回的对象放入到 Response 对象的 Body 数据区中。使用后将不会返回页面而是数据，一般用于非 String 的对象作为 json 数据返回。 @ModelAttribute &amp; @SessionAttributes这两个注解可以实现在不同的模型（model）和控制器之间共享数据。 注解 说明 @ModelAttribute （若作用于普通方法） 若用于普通方法，该 Controller 的所有方法在调用前，先执行此方法。 @ModelAttribute （若作用于 Controller 的方法参数） 若作用于 Controller 的方法参数，进行参数绑定，类似 @RequestParam 。 @SessionAttributes 用于类上，将值放到session作用域中。]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈SpringMVC之数据绑定]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%B5%85%E8%B0%88SpringMVC%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[Spring MVC 拥有强大的数据绑定数据功能 ，本文介绍一下其对各种数据类型的绑定。 数据绑定 : 将请求中的字段按照 名字匹配 的原则填入模型对象中。 相关请求测试可以使用Chrome插件提交，推荐：Restlet Client 。 基本类型 &amp; 包装类型 &amp; 数组 对于这种类型的数据，直接使用 名字匹配 即可，不需要特殊处理。 基本类型 &amp; 包装类型 推荐直接使用 包装类型 代替 基本类型 。 数据类型 传递要求 类型要求 基本类型 （如 int ） 默认参数必须传，反之 HTTP Status 500 。 类型必须一致（如 int ），反之 HTTP Status 400 。 包装类型 （如 Integer ） 参数可以不传，若如此为 null 。 类型必须一致（如 int ），反之 HTTP Status 400 。 数组 推荐只作用于 基本类型 , 包装类型 , String 。 对于 基本类型 , 包装类型 , String 数组的数据绑定，和单个数据采取的 绑定方式 和 注意点 相同。 对象简单对象 / 多层级对象为了便于讲解，本文模拟使用 get 请求类型，且不进行转义（chrome 会自动转义）。 1234# 简单对象http://localhost:8080/binding/ObjectType1?username=Tom&amp;age=12# 多层级对象http://localhost:8080/binding/ObjectType1?username=Tom&amp;age=12&amp;contactInfo.phone=911 以下是 Controller 的对应方法， 其中 User类包含了同名属性。 123456/** 绑定简单对象 / 绑定多层级对象 */@RequestMapping(value = "/binding/objectType1")@ResponseBodypublic User objectType1(User user)&#123; return user;&#125; 同属性多对象因为 SpringMVC 是通过类的 setter 进行绑定的，所以当绑定多个对象且具有相同属性时，默认同属性都会被赋值，这时需要特殊处理。 1http://localhost:8080/binding/ObjectType2?user.username=Tom&amp;age=12&amp;admin.username=Jack 12345678910111213141516/** 绑定同属性多对象（User和Admin属性完全相同） */@RequestMapping(value = "/binding/objectType2")@ResponseBodypublic String objectType2(User user, Admin admin)&#123; return user.toString() + admin.toString();&#125;/** 在进入此Controller前，会先初始化此方法，完成绑定，再执行url对应方法 */@InitBinder("user")public void initUser(WebDataBinder binder) &#123; /** 将有user.前缀的属性绑定到user对象上（若没有前置，同属性都会赋值） */ binder.setFieldDefaultPrefix("user.");&#125;@InitBinder("admin")public void initAdmin(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix("admin.");&#125; List &amp; Set &amp; Map Spring 对于此类对象绑定需要使用 数据收集对象 。 List通过 数据收集对象 内的 setter 进行绑定，角标索引可确定 size 。 1http://localhost:8080/binging/listType?users[0].username=Tom&amp;users[1].username=Jack *From.java 12345678910111213141516171819public class UserListForm &#123; private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return "UserListForm&#123;" + "users=" + users + '&#125;'; &#125;&#125; *Controller.java 123456/** 绑定list */@RequestMapping(value = "/binging/listType")@ResponseBodypublic String listType(UserListForm userListForm)&#123; return userListForm.toString();&#125; Set 不推荐使用，当需要去重时，可以使用 List 接收再使用 Set 去重。 SpringMVC 对 Set 的支持不太好，不仅需要 数据收集对象 和手动初始化 Set ，还需要前后台 size 一致（自己的demo显示，重写 equals 和 hashCode 后无法添加多个元素，即使判定不同）。 Map1http://localhost:8080/binding/mapType?users[&apos;X&apos;].username=Tom&amp;users[&apos;Y&apos;].username=Jack *Form.java 12345678910111213141516171819public class UserMapForm &#123; private Map&lt;String, User&gt; users; public Map&lt;String, User&gt; getUsers() &#123; return users; &#125; public void setUsers(Map&lt;String, User&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return "UserMapForm&#123;" + "users=" + users + '&#125;'; &#125;&#125; *Controller.java 123456/** 绑定map */@RequestMapping(value = "mapType")@ResponseBodypublic String mapType(UserMapForm userMapForm)&#123; return userMapForm.toString();&#125; json绑定 json 数据需要 jackson-databind 依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt; *.json 1234567&#123; "username": "Tom", "age": 12, "contactInfo":&#123; "phone": "1234567890" &#125;&#125; *Controller.java 需要使用 @RequestBody注解 。 123456/** 绑定json */@RequestMapping(value = "jsonType")@ResponseBodypublic String jsonType(@RequestBody User user)&#123; return user.toString();&#125; xml绑定 xml 数据需要 spring-oxm 依赖。 123456&lt;!--xml数据绑定--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;4.1.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; *.xml 12345&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;people&gt; &lt;name&gt;Jim&lt;/name&gt; &lt;age&gt;16&lt;/age&gt;&lt;/people&gt; *entity.java 需要使用 @XmlRootElement 注解。 123456789101112131415161718192021222324252627282930313233/** 为xml绑定提供的实体类(注解需要JDK1.7以上支持) */@XmlRootElement(name = "people")public class People &#123; private String name; private Integer age; @XmlElement(name = "name") public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @XmlElement(name = "age") public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "People&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; *Controller.java 需要使用 @RequestBody 注解。 123456789/** * 绑定xml（推荐使用Restlet Client调试 ） * 注意People需要使用注解 */@RequestMapping(value = "xmlType")@ResponseBodypublic String xmlType(@RequestBody People people)&#123; return people.toString();&#125; Date 一般开发时，喜欢使用 String 类型接受，然后到 sql 层面进行类型转换。 123456/** 一般绑定时间类型方式 */@RequestMapping(value = "date")@ResponseBodypublic String date(@DateTimeFormat(iso = DateTimeFormat.ISO.DATE, pattern = "yyyy-MM-dd") Date date)&#123; return date.toString();&#125; 自定义类型转化器使用自定义的类型转化器可以满足 复杂多样的数据绑定 ，这里 模拟 对 2017-01-17 格式的字符串绑定到 Date 对象上。类似的还可以绑定：各种时间格式/货币格式/数据格式等。 Spring 提供了一些类型转化接口，如下： 类型转化接口 用途 说明 PropertyEditor 作用 局部 ；绑定借助 WebDataBinder 。 Spring3 前，内置的可扩展性。 Formatter 作用局部/全局；自动绑定； 参数为String 。 Spring3 后，内置的可扩展性。 Converter 作用局部/全局；自动绑定；参数为自定义。 Spring3 后，内置的不可扩展性。 Ⅰ PropertyEditor这种方式 只能作用于局部 ，需要配合 @InitBinder 使用。 1http://localhost:8888/binding/date1?date1=2017-01-17 *Controller.java 123456789101112/** 借助PropertyEditor转换数据，完成绑定 */@RequestMapping(value = "date1")@ResponseBodypublic String date1(Date date1)&#123; return date1.toString();&#125;@InitBinder("date1")public void initDate1(WebDataBinder binder)&#123; /** 将对应格式的字符串转化为Date类型(true:可以为空) */ binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true));&#125; Ⅱ Formatter这种方式 只能接受 String 参数 ，需要实现 Formatter接口 。 1http://localhost:8888/binding/date2?date2=2017-01-17 *Formatter.java 自定义格式化转换器，实现 Formatter接口 。 123456789101112/** 实现Formatter，自定义格式化转换器Demo */public class MyDateFormatter implements Formatter&lt;Date&gt; &#123; public Date parse(String text, Locale locale) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); return sdf.parse(text); &#125; public String print(Date object, Locale locale) &#123; return null; &#125;&#125; spring-web.xml 注册自定义格式化转化器。 12345678910&lt;mvc:annotation-driven conversion-service="myDateFormatter"/&gt;&lt;!--注册自定义格式化转化器--&gt;&lt;bean id="myDateFormatter" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="formatters"&gt; &lt;set&gt; &lt;bean class="org.demo.web.formatter.MyDateFormatter" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; *Controller.java 123456/** 借助Formatter转换数据，完成绑定（全局） */@RequestMapping(value = "date2")@ResponseBodypublic String date2(Date date2)&#123; return date2.toString();&#125; Ⅲ Converter这种方式可以接受自定义类型，需要实现实现 Converter接口 。 1http://localhost:8888/binding/date3?date3=2017-01-17 *Converter.java 自定义格式化转换器，实现 Converter接口 。 123456789101112/** 实现Converter，自定义格式化转换器Demo */public class MyDateConverter implements Converter&lt;String, Date&gt; &#123; public Date convert(String source) &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); try &#123; return sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; spring-web.xml 注册自定义格式化转化器。 12345678910&lt;mvc:annotation-driven conversion-service="myDateConverter"/&gt;&lt;!--注册自定义格式化转化器--&gt;&lt;bean id="myDateConverter" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="org.demo.web.converter.MyDateConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; *Controller.java 123456/** 借助Converter转换数据，完成绑定（全局） */@RequestMapping(value = "date3")@ResponseBodypublic String date3(Date date3)&#123; return date3.toString();&#125;]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Spring之DI注解]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%B5%85%E8%B0%88Spring%E4%B9%8BDI%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring 在管理 Bean 时会使用到各种注解 ，本文介绍一下开发中常会用到的注解。 以下是常用DI注解比较： DI 常用注解 说明 用途 @Autowired 自动装配，从ApplicationContext中取出 同类型 的bean装配到被注解项上。 属性 / setter / 构造器 @Qualifier 因为 @Autowired 按照类型自动装配可能存在多个bean实例，可以用 @Qualifier(&quot;beanId&quot;) 限定 id 筛选出指定的bean。 xml 中也有qualifier 标签。 配合 @AutoWired 使用，限定 id ， 但不推荐使用 ，可以直接使用 @Resource 代替。 @Resource 装配资源，默认从ApplicationContext中取出 同名 的bean装配到被注解项上。@Resource 可以通过 byName / byType 两种方式，只是一般使用默认 byName 匹配装载。 属性 / setter @Required 表示被修饰属性项，在初始化时一定要配置明确值。 setter @Required表示被修饰属性项，在初始化时一定要配置明确值。可以用于属性 / setter。 @Autowired自动装配，从ApplicationContext中取出 同类型 的bean装配到被注解项上。可以用于 属性 / setter / 构造器。 注意事项 : 当没有合适的bean时会抛异常，可以使用 @Autowired(required=false) 避免。 每个类只有一个构造器可以被标记为 required=true 。但 当有必要属性时推荐用 @Required 。 可以注解Spring众所周知的解析依赖性接口，即spring自带bean。 如 BeanFactory , Applicationcontext , Environment , ResourceLoader , ApplicationEventPublisher , MessageSource 等。 @Autowired 不能注解 BeanPostProcessor / BeanFactoryPostProcessor ，可以使用 @Bean 代替。 因为 @Autowired 为 BeanPostProcessor 处理，会产生循环依赖。 可以用来装配List/String的Map等集合，如果希望List有序，可以使用 @Order(n) 或使bean实现 Ordered 接口。 @Qualifier因为 @Autowired 按照类型自动装配可能存在多个bean实例，可以用 @Qualifier(&quot;beanId&quot;) 限定 id 筛选出指定的bean。 xml 中也有qualifier标签 。配合 @AutoWired 使用，限定 id ， 但 不推荐使用 ，可以直接使用 @Resource 代替。 和 @Component 一样，可以用作元注解，自定义限定注解。 即使不使用 @Qualifier 作注解依然可以注册自己的qualifier注解类型。 12345678&lt;bean id="customAutowireConfigurer" class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt; &lt;property name="customQualifierTypes"&gt; &lt;set&gt; &lt;value&gt;example.CustomQualifier&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; @Resource JSR-250 标准的注解，在 Java EE 5/6 通用，spring同样支持。 装配资源，默认从ApplicationContext中取出 同名 的bean装配到被注解项上。用于属性/只有一个多参数 setter 其实 @Resource 可以通过 byName / byType 两种方式，只是一般使用默认 byName 匹配装载。 注意事项 : 集合/Map类型很多都无法通过类型直接匹配， 即 @Autowired 不可使用。此时可以使用唯一名称 id 进行匹配。 使用 name 属性可以指定被注入bean的名称，默认是属性的名称或setter名称 之后，会由 ApplicationContext 中的 CommonAnnotationBeanPostProcessor 发现并处理。 当 CommonAnnotationBeanPostProcessor 在 ApplicationContext 中注册，不仅能识别 JSR-250 的 @Resource ，还支持 Spring2.5 引入的用于初始化回调/销毁回调的 @PostConstruct / @PreDestroy 。 @Bean基于java的容器注解，配置和初始化一个由SpringIoc容器管理的新对象的方法，类似于 xml 配置中的 &lt;bean&gt;&lt;/bean&gt; 。通常配合 @Configuration 使用。 以下的 java 配置 和 xml配置 等效。 12345678@Configurationpublic class AppConfig&#123; @Bean public DemoService myService()&#123; return new DemoServiceImpl(); &#125;&#125; 123&lt;beans&gt; &lt;bean id="myService" class="org.Demo.Service.MyServiceImpl"/&gt;&lt;/beans&gt; 可以使用 @Scope 注解控制作用域和代理方式。 123456789@Configurationpublic class AppConfig&#123; @Bean(name = "myService", initMethod="init", destroyMethod="cleanup") @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS) public DemoService myService()&#123; return new DemoServiceImpl(); &#125;&#125; 注意事项 : @Bean 的name默认是方法名，也可以使用 @Bean(&quot;Demo&quot;) 自定义bean名称。 可以使用 @Bean(initMethod=&quot;init&quot;) 和 @Bean(destroyMethod=&quot;cleanup&quot;) 指定初始化和销毁bean的方法（一般在return的类中定义相关方法）。 基于泛型的自动装配（//TODO） @Bean 和 @Autowired 配合可以实现泛型的自动装配。 @Inject / @Name从 Spring3.0 开始支持 JSR330 标准注解（依赖注入注解），其扫描方式与Spring注解一致。 需要以下依赖: 12345&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; @Inject @Inject 等效于 @Autowired ，可以用作类，属性，方法，构造器。 @Name 可以表示bean，和 @Component 等效。 可以限制依赖注入的bean名称，和 @Resource 等效。]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈字符编码]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%B5%85%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编程中常会遇到一些字符处理问题，这里来介绍一下前后台关于字符编码的问题。 常见的字符编码种类如下： 常用字符编码 描述 补充说明 ASCII 1字节，字符范围0-127，包含26个基本拉丁字母、阿拉伯数目字和英式标点符号。 只能显示现代美国英语，即使其扩展 EASCII （字符范围0-255）也只解决了部分西欧语言的显示。 ISO-8859-1 1字节，字符范围0-255，兼容 ASCII 。 只支持欧洲语言，在其他编码的配合下可以显示中文等。 GB2312 / GBK 1-2字节，兼容 ISO-8859-1 ，一般ascii码占1字节，其他占2字节。 GB2312 支持简体字； GBK 支持简/繁体字，兼容 GB2312 。（注意：区分全角和半角） Unicode 定长2字节（也有4字节的）。 不兼容任何编码 ，但是定长编码便于计算机处理。包含所有语言的字符，但占用空间大。 UTF-8 1-6字节，一般英文占1字节，中文占3字节，包含所有语言。兼容 ISO-8859-1 。 针对 Unicode 与 ISO-8859-1 不兼容，且占用空间大的问题，产生了 UTF-8 。utf8为UTF-8的简写，只有数据库(mysql)中使用utf8，其他推荐使用UTF-8（IE可能不识别utf8）。 HTML 编码问题因为HTML语言的本身特性导致一些字符需要转换为 字符实体 才可使用。这实际上是常见的 转义 操作， 和本文所要说的的 编码 并不是一件事。 在线工具：HTML编码/解码 ， 常见转义符号如下： 符号（描述） HTML转义 XHTML转义 （空格） &amp;nbsp; &amp;#160; &lt;（大于号） &amp;lt; &amp;#60; &gt; （小于号） &amp;gt; &amp;#62; &quot; （冒号） &amp;quot; &amp;#34; URL 编码问题URL 只能使用 ASCII 字符集 来通过因特网进行发送，所以 非ASCII 需要编码才可以在URL中使用。 URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 URL 不能包含空格。URL 编码通常使用 + 来替换空格。 前端编码encodeURI() 与 encodeURIComponent() 常用方法 说明 encodeURI() 常用于URL整体编码，不会对URL保留字符进行URL转义，如 ? / ! / : 等共10个。 encodeURIComponent() 常用于参数值编码，会对URL保留字符进行URL转义。 URL 保留字符URL 具有一些保留字符，他们具有特殊含义，当传参中有保留字符，应该转义，否则可能导致异常。 URL 保留字符 说明 + 表示空格。 / 用于分隔目录或子目录。 ? 用于分隔 URL 和参数。 % 指定特殊字符。 # 表示页面中的书签。 &amp; 参数间的分隔符。 = 指定参数的值。 二次编解码问题 一般字符乱码问题，是因为 c/s 或 b/s 字符集不同造成的，所以先客户端编码，后服务端解码即可避免。但是我们会经常遇到，有时 不编解码 / 编解码 / 两次编解码 都不会出现字符乱码问题。 为了便于理解，需要知道以下信息： URL只能存在 ASCII字符 。 Tomcat的 request.getParameter(paramName) 默认是 iso-8859-1 解码。 encodeURI() 与 encodeURIComponent() 使用的是 UTF-8 编码。 UTF-8 / ISO-8859-1 / GBK 包含 ASCII 且都是相同的码值。 以下为字符 中 的二次编解码过程： 因为第一次编码后只存在 ASCII字符 ，所以第二次 UTF-8编码 等同于 iso-8859-1编码 。 12// js : 二次编码encodeURI(encodeURI(paramName)); 1234// servlet : 二次解码URLDecoder.decode(request.getParameter(paramName), "UTF-8")// struts2 : 二次解码URLDecoder.decode(URLDecoder.decode(paramName, "UTF-8"), "UTF-8"); HTTP 编码问题理解了二次编码问题我们就可以分析和解决 get方法 乱码问题，但对于 SpringMVC 还有更方便的方法。 以下只针对 SpringMVC 乱码问题 。 GET修改 tomcat 配置文件 conf/server.xml ，添加编码和工程编码一致，推荐使用 UTF-8 。 因为 URL 只能存在 ASCII 字符集 ，所以浏览器默认会对汉字进行编码。 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8"/&gt; POST在 web.xml 中配置 CharacterEncodingFilter 即可。 1234567891011121314151617&lt;!--字符过滤器（只针对post）--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; IDE 相关IDEA 中的 Reload 与 Convert一般IDE会使用其默认设置解读文件，如果IDE的字符集和文件本身的字符集不同就会出现乱码。 此时可以改变编码方式，如IDEA中会出现两种方式。 Reload : 重载，使用指定的编码方式解读文件，文件本身编码不改变。 Convert : 转变，将当前看到的内容以指定的编码方式写入到文件中，文件本身编码可能改变。]]></content>
      <categories>
        <category>② 知识梳理</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
        <tag>HTML</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Pages搭建个人博客]]></title>
    <url>%2F2018%2F10%2F31%2F%E4%BD%BF%E7%94%A8GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本教程基于 Mac 系统，所用指令可能不适用其他平台！ 使用 GitHub Pages + Hexo + NexT 快速搭建一个功能完善的个人博客。 准备工作 Git : 本地需要安装 git。 Github : 拥有账号，配置好 SSH keys，并了解基本操作，如：创建远程仓库等。 Node.js : Hero 和 NexT 是基于 Node.js 的，可以到Node.js官网下载，一路下一步即可。 初见成效：GitHub Pages + Hexo安装 Hexo Hexo官网教程 当 Node.js 和 Git 都安装好后 ，终端执行如下命令： 1$ sudo npm install -g hexo 是不是卡住了，没反应？😁 这就对了，好好感受天朝爸爸对你的爱 🤣 。。。 可能 npm 没法使用，需要安装 cnpm ，这是淘宝的做的镜像。 12345$ npm install -g cnpm --registry=https://registry.npm.taobao.org$ sudo cnpm install -g hexo# 查看版本$ hexo -v 初始化 Hexo创建一个文件夹（如 hexo），作为站点根目录，用于存放 Hexo 等配置文件。 1234$ cd hexo$ hexo init$ hexo install 以下为 Hexo 默认目录结构： 12345678910111213.├── README.md├── _config.yml # 站点配置文件├── db.json ├── .deploy # hexo d 生成，部署到GitHub上的内容目录├── node_modules ├── package.json # hexo参数和所依赖插件├── public # hexo g 生成，输出的静态网页内容目录├── scaffolds # layout模板文件目录，其中的md文件可以编辑├── source # 文章源码目录，该目录下的markdown可以被hexo解析│ ├── _drafts # 草稿文章，不会发布，可使用以下命令生成：hexo new draft "草稿名"│ ├── _posts # 发布文章└── themes # 主题文件目录 启动 Hero 服务器 可以缩写成 $ hexo s 1$ hexo server 如果一起顺利，可以在 http://localhost:4000 看到启动页面。 这就是当前博客的面貌，使用的是 Hexo 的默认主题，只是还在本地。 将 Hexo 部署到 GitHub Pages创建 GitHub Pages 仓库，即在 GitHub 上创建一个普通仓库，但是要符合以下命名规则： 用户名.github.io 。 该仓库地址为：https://github.com/用户名/用户名.github.io.git 修改 站点配置文件 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件 ， 后者称为 主题配置文件 。 123$ cd hexo$ vim _config.yml 修改 repository 仓库位置： 注意 : 号后面要加空格 。 1234deploy: type: git repository: https://github.com/用户名/用户名.github.io.git branch: master 生成网站静态页面 可以缩写成 $ hexo g 1$ hexo generate 123456若出现如下报错：ERROR Local hexo not found in ~/hexoERROR Try runing: &apos;npm install hexo --save&apos;则执行命令：$ cnpm install hexo --save若无报错，自行忽略此步骤。 把网站部署到 GitHub 可以缩写成 $ hexo d 1$ hexo deploy 1234若报错：无法连接git或找不到git则执行命令：$ cnpm install hexo-deployer-git --save若无报错，自行忽略此步骤。 如果一切顺利，一般需要等待3分钟，就可以在 https://用户名.github.io 看到和之前所见的博客页面了。 这表明你的博客网站已经发布成功，之前的仓库 用户名.github.io 也更新了，就是之前生成的静态网页， 不包含你的MarkDown源文件 。 安装主题 NexT 安装 NexT 能美化 Hexo ，而且其还提供了很多插件，完善博客功能。 细节请参考： NexT官网 下载主题123$ cd hexo# 将 next 克隆到 hexo/themes/next 目录git clone https://github.com/iissnan/hexo-theme-next themes/next 以下为 NexT 默认目录结构： 12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 启动主题 修改 站点配置文件 ，修改 theme 字段。 1theme: next 验证主题 启动 Hexo 本地站点，并开启调试模式，可以看到异常信息。 1$ hexo s --debug Blog 流程 Hexo 安装成功后，就可以发布博客了。发布流程如下： 可以不使用指令，直接 删除 和 新建 文件。 123456789101112# 创建文章，会在 hexo/source/_posts 新建 md 文件$ hexo new "文章名字"# 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo clean# 生成缓存和静态文件$ hexo g# 启动 Hexo 本地站点，预览效果。$ hexo s# 重新部署到服务器，将文章发布到 GitHub$ hexo d 站点文件管理完成以上步骤后，还会存在以下问题： 站点开发环境只存在本地，不利于随时管理站点。 实际发布的是 md 被转变后的 html 文件，md 源文件没有被有效保管。 🤣喜大普奔， 2019.01.07 ，GitHub 已提供免费私有仓库，站点文件放到私有仓库就好！！！ 创建分支管理对于以上问题，可以在 GitHub Pages 仓库创建了一个分支，来保管站点环境，其也就包含了 md 源文件。具体操作 ，如下： 1234567# 克隆 GitHub Pages 仓库$ git clone git@github.com:用户名/用户名.github.io.git# 查看当前分支$ git branch# 创建 并 切换 到分支 config$ git checkout -b config 清空文件夹(仅保留.git)，将 hexo 文件内所有文件 拷贝到 其中 。 因为 next 也是个 git 仓库，需要手动删除其 .git 目录，或者根据提示操作。 1234# 将 git 仓库变动保存，并 push 到 远程仓库分支 config$ git add .$ git commit -m "GitHub Pages 站点环境"$ git push origin config 可以登录 GitHub，将 远程默认分支 切换为 config 。 实际上， master分支 存放的是站点的静态文件，其都是由 Hexo 自动生成的，所以 master分支 对我们而言没有太大意义，以后再也不用切换到 master分支 了。]]></content>
      <categories>
        <category>④ 麻瓜教程</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站日志]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[2019-06-03 修改了 code 高亮 （ custom.styl ）。 2019-05-03升级 NexT : 7.0.1 -&gt; 7.1.1+ 解决 hexo-symbols-count-time 字数统计严重不准问题。 2019-04-05 图片预览: fancybox3 延迟加载: lazyload 2019-03-08 添加实时在线聊天 : DaoVoice 。 搜索功能切换 : Algolia Search -&gt; Local Search 。 开启版权声明。 2019-03-03 升级 NexT : 5.1.4 -&gt; 7.0.1 自定义样式迁移: highlight.styl , theme.styl post-details.js , algolia-search.styl 等。 添加 v6+ 移除和变更的插件 : 进度条: theme-next-pace 动画: theme-next-canvas-nest 字数统计: hexo-symbols-count-time Hexo 添加萌萌哒😁 : live2d hexo-helper-live2d live2d模型: live2d-widget-models 模型预览 标签样式修改 文章标签样式修改（ custom.styl ）。 文章摘要添加标签（ post.swig , custom.styl ）。 2019-02-13 修改 MakeDown 语法渲染样式。 调整 code 过小（ highlight.styl ）。 调整 td 等宽的不当样式（ tables.styl ）。 自定义语法高亮样式（ theme.styl ）。 去除修改文章后，文章目录的新增加标识（ post-details.js ）。 2019-02-02🤣由于将站点环境分离等，导致所有站点提交记录丢失，所以感觉有必要记录站点发展。 以下为丢失的站点提交记录概要，包括但不限于： 根据 官方文档 定制了 NexT 配置文件。 启动 algolia-search插件，并修改搜索列表不显示分页的 bug（algolia-search.styl）。 2018-10-30基于 GitHub Pages + Hexo + NexT 搭建博客。 NexT 为 5.1.4版本。 NexT官方 NexT仓库]]></content>
  </entry>
</search>
